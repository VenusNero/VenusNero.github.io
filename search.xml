<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>题解 CF Round 564 Div.2</title>
      <link href="/2019/06/12/solution_cfr564div2/"/>
      <url>/2019/06/12/solution_cfr564div2/</url>
      
        <content type="html"><![CDATA[<p>有幸参加验题……不过只验了 $A,B,C,D$，$F$ 题是后来会的，有点菜（</p><p>感谢 Sooke 吖qwq</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=425100599&auto=0&height=66"></iframe><a id="more"></a><p>所有题目见：<a href="https://www.luogu.org/problemnew/lists?name=Nauuo&amp;orderitem=pid&amp;tag=&amp;content=0&amp;type=" target="_blank" rel="noopener">Link</a></p><h1 id="A-Nauuo-and-Votes"><a href="#A-Nauuo-and-Votes" class="headerlink" title="A Nauuo and Votes"></a>A Nauuo and Votes</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我喜欢 2A (votes)。简单的分支结构，实际的题目环境，非常的适合新人。</span><br><span class="line"> - By Sooke</span><br></pre></td></tr></table></figure><p>模拟。</p><p>直接按题意模拟即可，具体的方法就是把 $z$ 个人全部丢到 upvote，或者全部丢到 downvote 里再判断一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="keyword">if</span>(x+z&lt;y) <span class="built_in">puts</span>(<span class="string">"-"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(y+z&lt;x) <span class="built_in">puts</span>(<span class="string">"+"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==y &amp;&amp; !z) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"?"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="B-Nauuo-and-Chess"><a href="#B-Nauuo-and-Chess" class="headerlink" title="B Nauuo and Chess"></a>B Nauuo and Chess</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我喜欢 2B (chess)。不太难想的构造，但在 div.2 场 有一定的区分作用。</span><br><span class="line"> - By Sooke</span><br></pre></td></tr></table></figure><p>结论题。</p><p>题目的要求是两点的曼哈顿距离大于等于两点的编号差，显然，一个边长为 $m$ 的棋盘，最多可以容纳 $m\times 2-1$ 个棋子，用贪心的思想我们可以把第 $1$ 个棋子和第 $n$ 个棋子分别放到棋盘的左上角和右下角，就可以很容易地得到这个结论。</p><p>那么确定了边长之后，就是怎么摆的问题了。这点非常容易，直接沿着边摆过去就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">reg <span class="keyword">int</span> m=n/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m &amp;&amp; i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,<span class="number">1</span>,i);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n-m+<span class="number">1</span>;i++) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,m);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="C-Nauuo-and-Cards"><a href="#C-Nauuo-and-Cards" class="headerlink" title="C Nauuo and Cards"></a>C Nauuo and Cards</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我喜欢 2C/1A (cards)。很考验代码细心能力，是一道好题。</span><br><span class="line"> - By Sooke</span><br></pre></td></tr></table></figure><p>结论题。</p><p>考虑使用 $0$ 牌和不使用 $0$ 牌，如果必须使用 $0$ 牌，那么最好的办法就是把所有数字牌拿到手中，再按顺序摆回去，这样的操作次数是 $\max(pos[i]-i+n+1)$，否则次数为第一个 $pos[i]≥i$ 的 $pos[i]-i$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1919810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[MAXN],b[MAXN],pos[MAXN],ans,Ans=inf;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">pos[b[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=max(ans,pos[i]-i+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pos[i]&gt;=i)</span><br><span class="line">&#123;</span><br><span class="line">Ans=pos[i]-i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((pos[i]&lt;i &amp;&amp; Ans&lt;pos[i]-i+n+<span class="number">1</span>) || (pos[i]&gt;=i &amp;&amp; Ans!=pos[i]-i))</span><br><span class="line">&#123;</span><br><span class="line">Ans=inf;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ans==inf?ans:Ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="D-Nauuo-and-Circle"><a href="#D-Nauuo-and-Circle" class="headerlink" title="D Nauuo and Circle"></a>D Nauuo and Circle</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我喜欢 2D/1B (circle)。结论很简单也很美丽，证明需要一定观察能力。</span><br><span class="line"> - By Sooke</span><br></pre></td></tr></table></figure><p>结论题。</p><p>（这道题是 Sooke 大概半年前和我说的，本来说要给洛咕出一次 CF 模拟赛，结果洛咕的 CF 赛制一直咕，所以直接给 CF 出了233）</p><p>考虑 $f[u]$ 作为 $u$ 这棵子树的方案数，由乘法原理可以得：$f[u]=(siz[u]+[u\not=root])!\times\prod_{v\in son[u]}f[v]$（注意：那个感叹号是阶乘），拉出来就是每个点的度数的阶乘的积。</p><p>（记得用 $\texttt{1ll}$ 或者开 $\texttt{long long}$）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,deg[MAXN],ans;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Mul</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1l</span>l*x*y<span class="number">-1l</span>l*x*y/Mod*Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">ans=n;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">deg[x]++;</span><br><span class="line">deg[y]++;</span><br><span class="line">ans=Mul(ans,Mul(deg[x],deg[y]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="F-Nauuo-and-Portals"><a href="#F-Nauuo-and-Portals" class="headerlink" title="F Nauuo and Portals"></a>F Nauuo and Portals</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我喜欢 2F/1D (portals)。构造算是挺有趣的，想对方向就可以过，对大部分人来说要想比较久的时间。</span><br><span class="line"> - By Sooke</span><br></pre></td></tr></table></figure><p>可以把一个 $n\times n$ 的问题转变成 $(n-1)\times (n-1)$ 的问题，具体做法为：</p><ul><li><p>如果已经满足，那就直接转化。</p></li><li><p>如果还未满足，那就找到应该在第一行中放在第一列那个，和应该在第一列中放在第一行那个，两个位置各放一个。</p></li></ul><p>官方题解也有说，这题显然是可以 $\Theta(n)$ 解决的，但是 checker 要写 $\Theta(n^2)$，比较有意思。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Portal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ax,ay,bx,by;</span><br><span class="line">&#125;ans[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,tot,a[MAXN],b[MAXN],posa[MAXN],posb[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">        posb[b[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        posa[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(reg <span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==i &amp;&amp; b[i]==i) <span class="keyword">continue</span>;</span><br><span class="line">        ans[++tot].ax=i;</span><br><span class="line">        ans[tot].ay=a[i];</span><br><span class="line">        ans[tot].bx=b[i];</span><br><span class="line">        ans[tot].by=i;</span><br><span class="line">        a[posa[i]]=a[i];</span><br><span class="line">        posa[a[i]]=posa[i];</span><br><span class="line">        b[posb[i]]=b[i];</span><br><span class="line">        posb[b[i]]=posb[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tot);</span><br><span class="line">    <span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>,ans[i].ax,ans[i].ay,ans[i].bx,ans[i].by);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 比赛 </tag>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P4883 mzf的考验</title>
      <link href="/2019/05/21/solution_p4883/"/>
      <url>/2019/05/21/solution_p4883/</url>
      
        <content type="html"><![CDATA[<p>平衡树。</p><p>给定一个数列，有三种操作：翻转区间，区间异或，区间查和。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=467509812&auto=0&height=66"></iframe><a id="more"></a><p>非常裸的平衡树，带翻转似乎只有平衡树能做了吧（</p><p>反正 $\texttt{fhq}$ 天下第一就是了【暴论】</p><p>依然是区间翻转打标记，区间查询就维护一个 $\texttt{sum}$ 数组，比较难搞的是这个区间异或，注意到题目中有写：$\texttt{d}\in[0,2^{20})$，考虑使用常用的套路，即将它拆成一位一位的分别维护，由于只有 $20$ 位，所以可以很轻松地存下来。</p><p>（尝试了一下新的毒瘤码风，各位感性理解一下吧qaq）</p><p><img src="http://wx3.sinaimg.cn/large/0060lm7Tly1g39abmz8sxj30ap05at8w.jpg" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FHQTreap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> ch[MAXN][<span class="number">2</span>],siz[MAXN],val[MAXN],key[MAXN],tag[MAXN],root,sze,num[MAXN][K+<span class="number">5</span>],fg[MAXN],stk[MAXN],top;</span><br><span class="line"><span class="keyword">int</span> sum[MAXN];</span><br><span class="line"><span class="keyword">bool</span> rev[MAXN];</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">Mxr</span><span class="params">(reg <span class="keyword">int</span> rt,reg <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tag[rt]^=v;</span><br><span class="line">val[rt]^=v;</span><br><span class="line">sum[rt]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=K;i++) fg[i]=(v&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=K;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fg[i]) num[rt][i]=siz[rt]-num[rt][i];</span><br><span class="line">sum[rt]+=(<span class="number">1</span>&lt;&lt;i)*num[rt][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">Psu</span><span class="params">(reg <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[rt]=siz[ch[rt][<span class="number">0</span>]]+siz[ch[rt][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">sum[rt]=sum[ch[rt][<span class="number">0</span>]]+sum[ch[rt][<span class="number">1</span>]]+val[rt];</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=K;i++) num[rt][i]=num[ch[rt][<span class="number">0</span>]][i]+num[ch[rt][<span class="number">1</span>]][i]+((val[rt]&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">Psd</span><span class="params">(reg <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rev[rt])</span><br><span class="line">&#123;</span><br><span class="line">swap(ch[rt][<span class="number">0</span>],ch[rt][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(ch[rt][<span class="number">0</span>]) rev[ch[rt][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(ch[rt][<span class="number">1</span>]) rev[ch[rt][<span class="number">1</span>]]^=<span class="number">1</span>;</span><br><span class="line">rev[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tag[rt])</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> v=tag[rt];</span><br><span class="line">tag[rt]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ch[rt][<span class="number">0</span>]) Mxr(ch[rt][<span class="number">0</span>],v);</span><br><span class="line"><span class="keyword">if</span>(ch[rt][<span class="number">1</span>]) Mxr(ch[rt][<span class="number">1</span>],v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mrg</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x+y;</span><br><span class="line"><span class="keyword">if</span>(key[x]&lt;key[y])</span><br><span class="line">&#123;</span><br><span class="line">Psd(x);</span><br><span class="line">ch[x][<span class="number">1</span>]=Mrg(ch[x][<span class="number">1</span>],y);</span><br><span class="line">Psu(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Psd(y);</span><br><span class="line">ch[y][<span class="number">0</span>]=Mrg(x,ch[y][<span class="number">0</span>]);</span><br><span class="line">Psu(y);</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spt</span><span class="params">(reg <span class="keyword">int</span> rt,reg <span class="keyword">int</span> pos,reg <span class="keyword">int</span> &amp;x,reg <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!rt) x=y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Psd(rt);</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=siz[ch[rt][<span class="number">0</span>]])</span><br><span class="line">&#123;</span><br><span class="line">y=rt;</span><br><span class="line">Spt(ch[rt][<span class="number">0</span>],pos,x,ch[rt][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">x=rt;</span><br><span class="line">Spt(ch[rt][<span class="number">1</span>],pos-siz[ch[rt][<span class="number">0</span>]]<span class="number">-1</span>,ch[rt][<span class="number">1</span>],y);</span><br><span class="line">&#125;</span><br><span class="line">Psu(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Nwd</span><span class="params">(reg <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">reg <span class="keyword">int</span> rt=++sze;</span><br><span class="line">siz[rt]=<span class="number">1</span>;</span><br><span class="line">val[rt]=v;</span><br><span class="line">key[rt]=rand();</span><br><span class="line">tag[rt]=rev[rt]=<span class="number">0</span>;</span><br><span class="line">ch[rt][<span class="number">0</span>]=ch[rt][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Bld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(stk,<span class="number">0</span>,<span class="keyword">sizeof</span>(stk));</span><br><span class="line">top=<span class="number">0</span>;</span><br><span class="line">reg <span class="keyword">int</span> x,pre;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=Nwd(a[i]);</span><br><span class="line">pre=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; key[stk[top]]&gt;key[x])</span><br><span class="line">&#123;</span><br><span class="line">Psu(stk[top]);</span><br><span class="line">pre=stk[top];</span><br><span class="line">stk[top--]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(top) ch[stk[top]][<span class="number">1</span>]=x;</span><br><span class="line">ch[x][<span class="number">0</span>]=pre;</span><br><span class="line">stk[++top]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(top) Psu(stk[top--]);</span><br><span class="line"><span class="keyword">return</span> stk[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(reg <span class="keyword">int</span> l,reg <span class="keyword">int</span> r,reg <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">reg <span class="keyword">int</span> x,y,z;</span><br><span class="line">Spt(root,r,x,z);</span><br><span class="line">Spt(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">Mxr(y,v);</span><br><span class="line">root=Mrg(Mrg(x,y),z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(reg <span class="keyword">int</span> l,reg <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">reg <span class="keyword">int</span> x,y,z;</span><br><span class="line">Spt(root,r,x,z);</span><br><span class="line">Spt(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">rev[y]^=<span class="number">1</span>;</span><br><span class="line">root=Mrg(Mrg(x,y),z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(reg <span class="keyword">int</span> l,reg <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">reg <span class="keyword">int</span> x,y,z;</span><br><span class="line">Spt(root,r,x,z);</span><br><span class="line">Spt(x,l<span class="number">-1</span>,x,y);</span><br><span class="line">reg <span class="keyword">int</span> res=sum[y];</span><br><span class="line">root=Mrg(Mrg(x,y),z);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">T.root=T.Bld();</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> opt,x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;opt,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>) T.Rev(x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;z);</span><br><span class="line">T.Mdy(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,T.Qry(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> FHQTreap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 模拟赛 5-12</title>
      <link href="/2019/05/15/solution_2019_5_12/"/>
      <url>/2019/05/15/solution_2019_5_12/</url>
      
        <content type="html"><![CDATA[<p>菜的抠脚。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1365422876&auto=0&height=66"></iframe><a id="more"></a><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>给定一棵树，改变最少的结点使其成为一棵二叉搜索树，求出点数。$n\leq 1e5$。</p><p>我们知道，一棵严格二叉搜索树的中序遍历一定是一个严格上升序列，所以第一步肯定是求出中序遍历，然后有的同学就会想去求出它的 $\texttt{LIS}$，然后贪心做法减一减，但这样显然是不行的，因为不一定能做到严格上升，所以我们可以对求出的中序遍历中每个 $a_i$ 减去 $i$，再求 $\texttt{LIS}$，再减就没问题了。</p><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>定义区间 $[L,R]$ 为特殊的，当且仅当存在一个 $a_k (L\leq k\leq R)$，使得区间内的每个数都是 $a_k$ 的倍数，求出最长特殊区间的长度 $ans$ 及所有长度为 $ans$ 的特殊区间的 $L$。$n\leq 5e5$</p><p>做法听说是 二分 + $\texttt{ST}$ 表，但是我们并不会这么高级的做法，考虑暴力做法，对每个点向左右进行扩展，找到边界，计算区间长度与 $ans$ 进行比较，记录答案即可。</p><p>在数据随机的情况下复杂度可以到达优秀的 $\Theta(n\log n)$，轻松过掉（甚至暴力碾标算）。</p><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>给定排列 $\texttt{p}$，定义排列 $\texttt{q}$ 是优美的，当且仅当对一个排列 $\texttt{s}=\{1,2,…,n\}$ 进行 $n$ 次交换，每次交换 $s_{q_i}$ 和 $s_{q_i+1}$ 后能使得 $\texttt{s}=\texttt{p}$，求出优美的排列的个数。$n\leq 50$。</p><p>考虑区间 $\texttt{DP}$，定义 $f[i][j]$ 为将区间 $[i,j]$ 变换为目标状态的方案数，我们可以发现一个限制，就是如果我们交换了 $k$ 和 $k+1$，那么前面那段就不可能交换到后面了，后面那段也不可能交换到前面，所以我们要令 $k$ 前面的全部 $\leq k$，后面的全部 $≥k$，记忆化搜索优化 $\texttt{DP}$ 即可，方程式为 $f[i][j]=f[i][j]+\texttt{Dfs}(i,k) \times \texttt{Dfs}(k+1,j) \times \texttt{C}(j-i-1,k-i)$。</p><p>最终为 $\Theta(n^4)$ 的优秀复杂度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 比赛 </tag>
            
            <tag> DP </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P5331 [SNOI2019]通信</title>
      <link href="/2019/05/12/solution_p5331/"/>
      <url>/2019/05/12/solution_p5331/</url>
      
        <content type="html"><![CDATA[<p>费用流。</p><p>$n$ 个排成一列的哨站要进行通信。第 $i$ 个哨站的频段为 $a_i$。</p><p>每个哨站 $i$ 需要选择以下二者之一：</p><p> 1.直接连接到控制中心，代价为 $W$；<br> 2.连接到前面的某个哨站 $j (j&lt;i)$，代价为 $|a_i-a_j|$。 每个哨站只能被后面的至多一个哨站连接。</p><p>请你求出最小可能的代价和。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28496172&auto=0&height=66"></iframe><a id="more"></a><p>首先这个题面以及数据范围已经可以看出一点网络流的影子了，配合费用进行考虑就是费用流，那么考虑每个点都可以 <strong>向别人连</strong>，或者 <strong>被别人连</strong>，考虑拆点，将 $i$ 拆出 $i’$，分别代表 <strong>连向</strong> 和 <strong>被连向</strong>。显然，这样会喜提 $\texttt{TLE}$，因为边数实在太多了，已经到达了 $n^2$，而网络流算法中往往是要乘上 $m$ 的。那么有什么方法可以减少边数呢？</p><p>写题解的此时此刻，我想到了神鱼枫姐姐曾经和我说过的话：</p><p><img src="https://i.loli.net/2019/05/12/5cd82b1dcb30c.png" alt=""></p><p>没错，数据结构优化建边。可以使用一个类似分治的算法很快地建出一个很简洁的图。别的 $\texttt{julao}$ 说是主席树，但窝看不大出来，觉得更像一个 $\texttt{cdq}$ 分治，因为我印象中的主席树都是：</p><p><img src="https://i.loli.net/2019/05/12/5cd82c17cfc11.png" alt=""></p><p>（码风不忍直视）</p><p>不过这不是重点，重点是经过一个建虚点之后连点的过程后，我们就可以直接跑费用流而不 $\texttt{TLE}$ 了。</p><p>依然推荐使用 $\texttt{zkw}$ 费用流。</p><p>（写法略暴力，如 $\texttt{define int long long}$，见谅）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (long long)4340410370284600380</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>,fst[MAXN&lt;&lt;<span class="number">1</span>],nxt[MAXM],to[MAXM],w[MAXM],cot[MAXM],cur[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,W,a[MAXN],t[MAXN],S,T,dis[MAXN&lt;&lt;<span class="number">1</span>],mincost,tot,sum;</span><br><span class="line"><span class="keyword">bool</span> inq[MAXN&lt;&lt;<span class="number">1</span>],vis[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(reg <span class="keyword">int</span> u,reg <span class="keyword">int</span> v,reg <span class="keyword">int</span> c,reg <span class="keyword">int</span> fl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">cot[cnt]=fl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">bool</span> <span class="title">Spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">60</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="keyword">sizeof</span>(inq));</span><br><span class="line">q.push_front(T);</span><br><span class="line">dis[T]=<span class="number">0</span>;</span><br><span class="line">inq[T]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop_front();</span><br><span class="line">inq[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[u]-cot[i] &amp;&amp; w[i^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]-cot[i];</span><br><span class="line"><span class="keyword">if</span>(!inq[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!q.empty() &amp;&amp; dis[v]&lt;dis[q.front()]) q.push_front(v);</span><br><span class="line"><span class="keyword">else</span> q.push_back(v);</span><br><span class="line">inq[v]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[S]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(reg <span class="keyword">int</span> u,reg <span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(u==T || !flow) <span class="keyword">return</span> flow;</span><br><span class="line">reg <span class="keyword">int</span> used=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=cur[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line">cur[u]=i;</span><br><span class="line">reg <span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dis[v]==dis[u]-cot[i] &amp;&amp; w[i] &amp;&amp; !vis[v])</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> fl=Dfs(v,min(flow,w[i]));</span><br><span class="line"><span class="keyword">if</span>(fl)</span><br><span class="line">&#123;</span><br><span class="line">used+=fl;</span><br><span class="line">flow-=fl;</span><br><span class="line">w[i]-=fl;</span><br><span class="line">w[i^<span class="number">1</span>]+=fl;</span><br><span class="line"><span class="keyword">if</span>(!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">zkwMCMF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(Spfa())</span><br><span class="line">&#123;</span><br><span class="line">vis[T]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(vis[T])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(cur,fst,<span class="keyword">sizeof</span>(fst));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">reg <span class="keyword">int</span> fl=Dfs(S,inf);</span><br><span class="line">mincost+=dis[S]*fl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Link</span><span class="params">(reg <span class="keyword">int</span> l,reg <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">reg <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=l;i&lt;=r;i++) t[++tot]=a[i];</span><br><span class="line">sort(t+<span class="number">1</span>,t+tot+<span class="number">1</span>);</span><br><span class="line">tot=unique(t+<span class="number">1</span>,t+tot+<span class="number">1</span>)-t<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;tot;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i+sum,i+sum+<span class="number">1</span>,inf,t[i+<span class="number">1</span>]-t[i]);</span><br><span class="line">AddEdge(i+sum+<span class="number">1</span>,i+sum,<span class="number">0</span>,t[i]-t[i+<span class="number">1</span>]);</span><br><span class="line">AddEdge(i+sum+<span class="number">1</span>,i+sum,inf,t[i+<span class="number">1</span>]-t[i]);</span><br><span class="line">AddEdge(i+sum,i+sum+<span class="number">1</span>,<span class="number">0</span>,t[i]-t[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> pos=lower_bound(t+<span class="number">1</span>,t+tot+<span class="number">1</span>,a[i])-t;</span><br><span class="line"><span class="keyword">if</span>(i&lt;=mid)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(pos+sum,i+n,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">AddEdge(i+n,pos+sum,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i,pos+sum,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">AddEdge(pos+sum,i,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum+=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;W);</span><br><span class="line">S=<span class="number">0</span>;</span><br><span class="line">T=n*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">sum=n*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(S,i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">AddEdge(i,S,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">AddEdge(i,T,<span class="number">1</span>,W);</span><br><span class="line">AddEdge(T,i,<span class="number">0</span>,-W);</span><br><span class="line">AddEdge(i+n,T,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">AddEdge(T,i+n,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">Link(<span class="number">1</span>,n);</span><br><span class="line">zkwMCMF();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mincost);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 费用流 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P5323 [BJOI2019] 光线</title>
      <link href="/2019/04/29/solution_p5323/"/>
      <url>/2019/04/29/solution_p5323/</url>
      
        <content type="html"><![CDATA[<p>递推。</p><p>$n$ 片玻璃，每片玻璃的透光率为 $a_i\%$，反射率为 $b_i\%$，求 $1$ 单位的光照入后，能有多少光经过这 $n$ 片玻璃。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=60525&auto=0&height=66"></iframe><a id="more"></a><p>每片玻璃有反射和透过两种情况，每束光有从上方来和从下方来两种可能，看似情况非常多，但是我们可以分析一下，事实上最终一共只有两种情况：即光向上或向下，我们不妨令 $f[i]$ 表示第 $i$ 片玻璃向下的光，$g[i]$ 表示向上的光，那么可以得到两个显然的式子，即：</p><script type="math/tex; mode=display">f[i]=f[i-1]\times a[i]+g[i+1]\times b[i]</script><script type="math/tex; mode=display">g[i]=f[i-1]\times b[n]+g[i+1]\times a[i]</script><p>显然这个东西是不能直接递推求的，因为求第 $i$ 项要第 $i-1$ 和第 $i+1$ 项，我们考虑换一种思路，令 $f[i]$ 表示光从第 $1$ 到第 $i$ 片玻璃的透光率，$g[i]$ 表示光从第 $i$ 到第 $1$ 片玻璃的反光率，枚举光的反射次数为 $j$，可以得到：</p><script type="math/tex; mode=display">f[i]=f[i-1]\times a[i]\times \sum_{j=0}^{\infty}(g[i-1]\times b[i])^{j}</script><script type="math/tex; mode=display">g[i]=b[i]+g[i-1]\times a[i]^2\times \sum_{j=0}^{\infty}(g[i-1]\times b[i])^{j}</script><p>可以看出这是一个无限项的等比数列，而无限项等比数列 $a_n=a_{n-1}\times p$ 求和公式为（经百度）$\sum=\frac{a_{1}}{1-p}$，显然上面两个式子的公比 $p=g[i-1]\times b[i]$，所以我们可以得出：</p><script type="math/tex; mode=display">f[i]=\frac{f[i-1]\times a[i]}{1-p}</script><script type="math/tex; mode=display">g[i]=b[i]+\frac{g[i-1]\times a[i]^{2}}{1-p}</script><p>直接递推求解即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[MAXN],b[MAXN],f[MAXN],g[MAXN];</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Add</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y&gt;Mod?x+y-Mod:x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Dec</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x-y&lt;<span class="number">0</span>?x-y+Mod:x-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Mul</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*y-x*y/Mod*Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">reg <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=Mul(x,x)) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=Mul(res,x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">reg <span class="keyword">int</span> inv=Pow(<span class="number">100</span>,Mod<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">a[i]=Mul(inv,a[i]);</span><br><span class="line">b[i]=Mul(inv,b[i]);</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> p=Pow(Dec(<span class="number">1</span>,Mul(g[i<span class="number">-1</span>],b[i])),Mod<span class="number">-2</span>);</span><br><span class="line">f[i]=Mul(Mul(f[i<span class="number">-1</span>],a[i]),p);</span><br><span class="line">g[i]=Add(b[i],Mul(Mul(Mul(g[i<span class="number">-1</span>],a[i]),a[i]),p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 递推 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P5305 [GXOI/GZOI2019]旧词</title>
      <link href="/2019/04/17/solution_p5305/"/>
      <url>/2019/04/17/solution_p5305/</url>
      
        <content type="html"><![CDATA[<p>树链剖分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我真傻，真的。我单知道 NOIP 会出原题，我没想到省选也会出原题。</span><br><span class="line">——鲁迅</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28138493&auto=0&height=66"></iframe><a id="more"></a><p>亲，这边建议去看一下 $\texttt{[LNOI2014]LCA}$ 呢。</p><p>考虑 $k=1$ 时，每次询问 $(x,y)$，可以考虑把 $\text{dep}$ 均摊到根到 $y$ 的路径上，然后可以直接查询，但是这样显然会变成 $\text{O}(n)$ 处理，我们反过来考虑，对 $x$ 进行处理，那么可以离线做，把询问排序，然后每个询问把所有 $i\in[1,x]$ 的点到根的权值都加 $1$，然后直接查询根到 $y$ 的权值和，所有 $x$ 相同的询问都可以一起处理。</p><p>那么要怎么扩展到 $k&gt;1$ 呢？我们分析一下 $k=1$ 时的本质，我们加上的这个 $1$ 其实就是 $\text{dep}_x-\text{dep}_{fa[x]}$，那么现在是 $\text{dep}^k$ 的情况，所以我们可以直接扩展到 $k$ 次的情况，即加上的就是 $\text{dep}_x^k-\text{dep}_{fa[x]}^k$，那么依然和 $k=1$ 时一样做，询问离线，然后把 $x$ 相等的一起处理了。不过这个 $\text{dep}_x^k-\text{dep}_{fa[x]}^k$ 需要预处理一下，不然处理非常麻烦。</p><p>算法当然就是树剖+线段树了。（听说 $\texttt{LCT}$ 也可以做，当然我是不会的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stc static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line">stc <span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line">stc <span class="keyword">int</span> n,q,k,a[MAXN],sum[MAXN],ans[MAXN];</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Add</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y&gt;Mod?x+y-Mod:x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Dec</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x-y&lt;<span class="number">0</span>?x-y+Mod:(x-y&gt;Mod?x-y-Mod:x-y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Mul</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*y-x*y/Mod*Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">reg <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=Mul(x,x)) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=Mul(res,x);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(reg <span class="keyword">int</span> u,reg <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">inl <span class="keyword">void</span> <span class="title">Read</span><span class="params">(reg T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line">reg <span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">reg <span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeSplit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> t[MAXN&lt;&lt;<span class="number">2</span>],tag[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> siz[MAXN],son[MAXN],dfn[MAXN],Idx,top[MAXN],faz[MAXN],rk[MAXN],dep[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(reg <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">Dfs1(v);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[v]&gt;siz[son[u]]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(reg <span class="keyword">int</span> u,reg <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u]=++Idx;</span><br><span class="line">rk[Idx]=u;</span><br><span class="line">top[u]=rt;</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==son[u] || v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(reg <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[rt]=Add(t[rt&lt;&lt;<span class="number">1</span>],t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(reg <span class="keyword">int</span> rt,reg <span class="keyword">int</span> l,reg <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag[rt])</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">t[rt&lt;&lt;<span class="number">1</span>]=Add(t[rt&lt;&lt;<span class="number">1</span>],Mul(tag[rt],Dec(sum[mid],sum[l<span class="number">-1</span>])));</span><br><span class="line">t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=Add(t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],Mul(tag[rt],Dec(sum[r],sum[mid])));</span><br><span class="line">tag[rt&lt;&lt;<span class="number">1</span>]=Add(tag[rt&lt;&lt;<span class="number">1</span>],tag[rt]);</span><br><span class="line">tag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=Add(tag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],tag[rt]);</span><br><span class="line">tag[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(reg <span class="keyword">int</span> rt,reg <span class="keyword">int</span> l,reg <span class="keyword">int</span> r,reg <span class="keyword">int</span> tl,reg <span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr)</span><br><span class="line">&#123;</span><br><span class="line">t[rt]=Add(t[rt],Dec(sum[r],sum[l<span class="number">-1</span>]));</span><br><span class="line">tag[rt]++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">reg <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">PushDown(rt,l,r);</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(reg <span class="keyword">int</span> rt,reg <span class="keyword">int</span> l,reg <span class="keyword">int</span> r,reg <span class="keyword">int</span> tl,reg <span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line">reg <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">PushDown(rt,l,r);</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res=Add(res,Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res=Add(res,Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">Mdy</span><span class="params">(reg <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;u;u=faz[top[u]]) Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Qry</span><span class="params">(reg <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">reg <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;u;u=faz[top[u]]) res=Add(res,Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;Query&gt; vec[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Read(n);</span><br><span class="line">Read(q);</span><br><span class="line">Read(k);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Read(T.faz[i]);</span><br><span class="line">AddEdge(T.faz[i],i);</span><br><span class="line">AddEdge(i,T.faz[i]);</span><br><span class="line">&#125;</span><br><span class="line">T.dep[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">T.Dfs1(<span class="number">1</span>);</span><br><span class="line">T.Dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=Dec(Pow(T.dep[i],k),Pow(T.dep[i]<span class="number">-1</span>,k));</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=Add(sum[i<span class="number">-1</span>],a[T.rk[i]]);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> x,y;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">vec[x].push_back((Query)&#123;y,i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">T.Mdy(i);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="keyword">int</span>)vec[i].size();j++) ans[vec[i][j].id]=T.Qry(vec[i][j].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P5304 [GXOI/GZOI2019]旅行者</title>
      <link href="/2019/04/17/solution_p5304/"/>
      <url>/2019/04/17/solution_p5304/</url>
      
        <content type="html"><![CDATA[<p>Dijkstra。</p><p>这道题目简直是弟弟级别的……</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=410042097&auto=0&height=66"></iframe><a id="more"></a><p>考虑每条边 $(u,v,w)$ 的贡献，我们可以处理出城市中离 $u$ 最近的距离为 $dis_1$，离 $v$ 最近的距离为 $dis_2$，那么这条边的权值就是 $dis_1+dis_2+w$，然后找到最短的一条就行了。</p><p>同时，我们还要记录这个城市的编号，如果两个城市相同，那么相当于走了一个环回到其本身了，不能计入答案。</p><p>正反跑两边 Dijkstra，分别染色。染色也就是在跑 Dijkstra 的过程中记录离这个点最近的城市，具体可以见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],to[MAXM],nxt[MAXM],w[MAXM];</span><br><span class="line"><span class="keyword">int</span> n,m,k,col[<span class="number">2</span>][MAXN],a[MAXN],fr[MAXM],tx[MAXM],ww[MAXM];</span><br><span class="line">ll dis[<span class="number">2</span>][MAXM];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u;</span><br><span class="line">ll dis;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.dis&lt;dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;Node&gt; q;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">inl <span class="keyword">void</span> <span class="title">Read</span><span class="params">(reg T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line">reg <span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">reg <span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(reg <span class="keyword">int</span> u,reg <span class="keyword">int</span> v,reg <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(reg <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis[id],<span class="number">60</span>,<span class="keyword">sizeof</span>(dis[id]));</span><br><span class="line"><span class="built_in">memset</span>(col[id],<span class="number">0</span>,<span class="keyword">sizeof</span>(col[id]));</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">dis[id][a[i]]=<span class="number">0</span>;</span><br><span class="line">col[id][a[i]]=a[i];</span><br><span class="line">q.push((Node)&#123;a[i],<span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">reg Node now=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">reg <span class="keyword">int</span> u=now.u;</span><br><span class="line">reg ll d=now.dis;</span><br><span class="line"><span class="keyword">if</span>(d!=dis[id][u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dis[id][v]&gt;dis[id][u]+w[i])</span><br><span class="line">&#123;</span><br><span class="line">dis[id][v]=dis[id][u]+w[i];</span><br><span class="line">col[id][v]=col[id][u];</span><br><span class="line">q.push((Node)&#123;v,dis[id][v]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Time;</span><br><span class="line">Read(Time);</span><br><span class="line"><span class="keyword">while</span>(Time--)</span><br><span class="line">&#123;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(fst,<span class="number">0</span>,<span class="keyword">sizeof</span>(fst));</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line">Read(k);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">Read(z);</span><br><span class="line">fr[i]=x;</span><br><span class="line">tx[i]=y;</span><br><span class="line">ww[i]=z;</span><br><span class="line"><span class="keyword">if</span>(x^y) AddEdge(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) Read(a[i]);</span><br><span class="line">Dijkstra(<span class="number">0</span>);</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(fst,<span class="number">0</span>,<span class="keyword">sizeof</span>(fst));</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(fr[i]^tx[i]) AddEdge(tx[i],fr[i],ww[i]);</span><br><span class="line">Dijkstra(<span class="number">1</span>);</span><br><span class="line">reg ll ans=<span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> u=fr[i],v=tx[i],c=ww[i];</span><br><span class="line"><span class="keyword">if</span>(col[<span class="number">0</span>][u] &amp;&amp; col[<span class="number">1</span>][v] &amp;&amp; col[<span class="number">0</span>][u]!=col[<span class="number">1</span>][v]) ans=min(ans,dis[<span class="number">0</span>][u]+dis[<span class="number">1</span>][v]+c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About Me</title>
      <link href="/2019/04/16/about_me/"/>
      <url>/2019/04/16/about_me/</url>
      
        <content type="html"><![CDATA[<h2 id="我是谁？"><a href="#我是谁？" class="headerlink" title="我是谁？"></a>我是谁？</h2><p>ZJ 最菜的菜鸡，被各种吊打。</p><a id="more"></a><h3 id="「愿你唱遍梨园繁华，回首依然笑靥如花」"><a href="#「愿你唱遍梨园繁华，回首依然笑靥如花」" class="headerlink" title="「愿你唱遍梨园繁华，回首依然笑靥如花」"></a>「愿你唱遍梨园繁华，回首依然笑靥如花」</h3><iframe src="//player.bilibili.com/player.html?aid=36570707&cid=74641034&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="min-height:450px;min-width:600px;"> </iframe><h2 id="个人信息（伪）"><a href="#个人信息（伪）" class="headerlink" title="个人信息（伪）"></a>个人信息（伪）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">各种地方的 ID：Venus / VenusNero / DKACVenus / VenusNer0</span><br><span class="line">（其中 DKACVenus 非常少用，VenusNer0 是 ubisoft 专属qwq）</span><br><span class="line">QQ：2314701302（工作日用）/ 953854419（假期用）</span><br><span class="line">爱好：写代码 / FGO</span><br><span class="line">码风：大括号换行</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>题解 P4151 [WC2011]最大XOR和路径</title>
      <link href="/2019/04/15/solution_p4151/"/>
      <url>/2019/04/15/solution_p4151/</url>
      
        <content type="html"><![CDATA[<p>线性基 + 搜索。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">考虑一个边权为非负整数的无向连通图，节点编号为 1 到 N，试求出一条从 1 号节点到 N 号节点的路径，使得路径上经过的边的权值的 XOR 和最大。</span><br><span class="line"></span><br><span class="line">路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 XOR 和时也要被计算相应多的次数，具体见样例。</span><br></pre></td></tr></table></figure><p>智推几度推到此题，奈何当时惧于题目难度没有细做，今日无意间又做此题，方才发现——</p><p><del>这 TM 不一 ** 题吗</del></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=489092574&auto=0&height=66"></iframe><a id="more"></a><p>说回这道题，要使路径的异或和最大，说到异或和，就想起线性基。<del>再次两开花</del></p><p>题目说可以在环上走来走去，那么我们就考虑在每个环上走来走去产生的影响，显然，影响就相当于异或上这个环的异或和，所以我们考虑处理出每个环的异或和，把它丢到线性基里面去，最后计算一遍就可以带走这道题了。</p><p><del>感觉是黑题里最简单的那种了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stc static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">stc <span class="keyword">int</span> cnt,fst[MAXN],to[MAXM&lt;&lt;<span class="number">1</span>],nxt[MAXM&lt;&lt;<span class="number">1</span>];</span><br><span class="line">stc <span class="keyword">int</span> n,m;</span><br><span class="line">stc ll dis[MAXN],w[MAXM&lt;&lt;<span class="number">1</span>],p[K&lt;&lt;<span class="number">1</span>];</span><br><span class="line">stc <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">inl <span class="keyword">void</span> <span class="title">Read</span><span class="params">(reg T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line">reg <span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">reg <span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(reg <span class="keyword">int</span> u,reg <span class="keyword">int</span> v,reg ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">Modify</span><span class="params">(reg ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=K;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x&amp;(<span class="number">1l</span>l&lt;&lt;i))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]) x^=p[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p[i]=x;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(reg <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(vis[v]) Modify(dis[u]^dis[v]^w[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]^w[i];</span><br><span class="line">Dfs(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl ll <span class="title">Query</span><span class="params">(reg ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">reg ll res=x;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=K;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>((res^p[i])&gt;res) res^=p[i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> x,y;</span><br><span class="line">reg ll z;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">Read(z);</span><br><span class="line">AddEdge(x,y,z);</span><br><span class="line">AddEdge(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line">Dfs(<span class="number">1</span>);</span><br><span class="line">ll ans=Query(dis[n]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> Dfs </tag>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 模拟赛 4-9</title>
      <link href="/2019/04/09/solution_2019_4_9/"/>
      <url>/2019/04/09/solution_2019_4_9/</url>
      
        <content type="html"><![CDATA[<p>有点菜，$100+100+80=280$，第三题因为太麻瓜了没 AC，不然就 AK 了。</p><p>隔壁的 Sinner AK 了，Orz。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=101106&auto=0&height=66"></iframe><a id="more"></a><hr><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>$n$ 只有 $7$，每个根也不过 $[1,20]$，范围非常小。那么现在最大的问题就是判重根。</p><p>考虑一个数 $x$ 是方程 $f(x)=0$ 的根的条件是对于 $f$ 的 $0$ ~ $k-1$ 阶导数都有 $f’(x)=0$，所以我们可以直接枚举它的所有导数进行计算。</p><p>至于如何求导，多项式的求导谁应该都会。实在不行可以看一下“多项式算法学习笔记”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stc static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">//#define getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line">stc <span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line">stc <span class="keyword">int</span> n,a[MAXN],sum[K+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">inl <span class="keyword">void</span> <span class="title">Read</span><span class="params">(reg T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line">reg <span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">inl T <span class="title">Max</span><span class="params">(reg T x,reg T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">inl T <span class="title">Min</span><span class="params">(reg T x,reg T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">GetDev</span><span class="params">(reg <span class="keyword">int</span> *A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) A[i<span class="number">-1</span>]=A[i]*i;</span><br><span class="line">A[n]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">reg <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x;</span><br><span class="line">x=x*x;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Calc</span><span class="params">(reg <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) res+=a[i]*QuickPow(x,i);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Read(n);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) Read(a[i]);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">0</span>;n&gt;=<span class="number">1</span>;n--,i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=K;j++) <span class="keyword">if</span>(sum[j]==i &amp;&amp; !Calc(j)) sum[j]++;</span><br><span class="line">GetDev(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(;sum[i];sum[i]--) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>见到“配对”，就想到二分图匹配。<del>两开花</del></p><p>那么就可以开始搞了。考虑先筛出质数，然后将奇数和偶数分别作为左右点（因为奇数加偶数一定是奇数，大于 $2$ 的数只有奇数是质数），然后爆枚每两个数，加起来是质数就连一条边，最后可以用网络流或者匈牙利一波带走。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K 3000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stc static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">stc <span class="keyword">int</span> cnt=<span class="number">1</span>,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>],w[MAXN&lt;&lt;<span class="number">1</span>],cur[MAXN];</span><br><span class="line">stc <span class="keyword">int</span> n,a[MAXN],pri[MAXN+<span class="number">5</span>],tot,S,T,dep[MAXN];</span><br><span class="line">stc <span class="keyword">bool</span> isp[MAXN+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">inl <span class="keyword">void</span> <span class="title">Read</span><span class="params">(reg T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line">reg <span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(reg <span class="keyword">int</span> u,reg <span class="keyword">int</span> v,reg <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">bool</span> <span class="title">Bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">q.push(S);</span><br><span class="line">dep[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(!dep[v] &amp;&amp; w[i])</span><br><span class="line">&#123;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dep[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u==T || !flow) <span class="keyword">return</span> flow;</span><br><span class="line">reg <span class="keyword">int</span> used=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> &amp;i=cur[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span> &amp;&amp; w[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fl=Dfs(v,min(flow,w[i]));</span><br><span class="line"><span class="keyword">if</span>(fl)</span><br><span class="line">&#123;</span><br><span class="line">used+=fl;</span><br><span class="line">flow-=fl;</span><br><span class="line">w[i]-=fl;</span><br><span class="line">w[i^<span class="number">1</span>]+=fl;</span><br><span class="line"><span class="keyword">if</span>(!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(Bfs())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(cur,fst,<span class="keyword">sizeof</span>(fst));</span><br><span class="line">res+=Dfs(S,inf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">GetPrime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=K;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!isp[i]) pri[++tot]=i;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot &amp;&amp; i*pri[j]&lt;=K;j++)</span><br><span class="line">&#123;</span><br><span class="line">isp[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!(i%pri[j])) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GetPrime();</span><br><span class="line">Read(n);</span><br><span class="line">S=<span class="number">0</span>;</span><br><span class="line">T=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Read(a[i]);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]%<span class="number">2</span> &amp;&amp; !(a[j]%<span class="number">2</span>) &amp;&amp; !isp[a[i]+a[j]])</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i,j,<span class="number">1</span>);</span><br><span class="line">AddEdge(j,i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(S,i,<span class="number">1</span>);</span><br><span class="line">AddEdge(i,S,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i,T,<span class="number">1</span>);</span><br><span class="line">AddEdge(T,i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">reg <span class="keyword">int</span> ans=Dinic();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>爆枚打出哪一张麻将，然后再爆枚抽到哪一张麻将，判断一下能不能胡，能的话就计算一下牌堆里还有几张，加到答案里就行了。</p><p>（判胡应该是要用爆搜的，但是当时脑残了没有用，所以没有满分）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 205</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> stc static</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num,opt;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x,<span class="keyword">const</span> Node &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.opt==y.opt?x.num&lt;y.num:x.opt&lt;y.opt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Node &amp;x,<span class="keyword">const</span> Node &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.opt==y.opt &amp;&amp; x.num==y.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*void out()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">printf(" $ : %d %s\n",num,opt==1?"Íò":(opt==2?"Í²":"Ìõ"));</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;a[MAXN],t[MAXN],q[MAXN];</span><br><span class="line">stc <span class="keyword">int</span> n=<span class="number">14</span>,m=<span class="number">12</span>,ans,maxn,tot;</span><br><span class="line">stc <span class="keyword">bool</span> used[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sort(t+<span class="number">1</span>,t+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=n;p++)<span class="comment">//Ã¶¾Ù p Îª½«ÅÆ </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line">used[p]=<span class="number">1</span>;</span><br><span class="line">reg <span class="keyword">bool</span> fg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> r=<span class="number">1</span>;r&lt;=n;r++)<span class="comment">//ÕÒµ½ÏàÍ¬ÅÆ </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(t[p]==t[r] &amp;&amp; p!=r)</span><br><span class="line">&#123;</span><br><span class="line">used[r]=<span class="number">1</span>;</span><br><span class="line">fg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!fg) <span class="keyword">continue</span>;</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!used[i]) q[++tot]=t[i];</span><br><span class="line">sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line">fg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i+=<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(q[i].opt!=q[i<span class="number">-1</span>].opt || q[i].opt!=q[i+<span class="number">1</span>].opt)</span><br><span class="line">&#123;</span><br><span class="line">fg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((q[i].num==q[i<span class="number">-1</span>].num &amp;&amp; q[i].num==q[i+<span class="number">1</span>].num) || (q[i].num==q[i<span class="number">-1</span>].num+<span class="number">1</span> &amp;&amp; q[i].num==q[i+<span class="number">1</span>].num<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!fg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*printf("  µ±Ç°ÅÆÎª : ");</span></span><br><span class="line"><span class="comment">for(reg int i=1;i&lt;=m;i++) printf(" %d %s ",q[i].num,q[i].opt==1?"Íò":(q[i].opt==2?"Í²":"Ìõ"));</span></span><br><span class="line"><span class="comment">puts("");</span></span><br><span class="line"><span class="comment">printf("  @ ½«ÅÆÎª : %d %s\n\n",t[p].num,t[p].opt==1?"Íò":(t[p].opt==2?"Í²":"Ìõ"));*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1£ºÍò 2£ºÍ² 3£ºÌõ </span></span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%c"</span>,&amp;x,&amp;ch);</span><br><span class="line">a[i].num=x;</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">'w'</span>) a[i].opt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'p'</span>) a[i].opt=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'s'</span>) a[i].opt=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf("  ´ò³ö : %d\n\n",i);</span></span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(t,a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">t[i].num=j;</span><br><span class="line">t[i].opt=k;</span><br><span class="line">reg <span class="keyword">bool</span> fg=Check();</span><br><span class="line"><span class="keyword">if</span>(fg)</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> sum=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=n;l++) <span class="keyword">if</span>(l!=i &amp;&amp; a[l].opt==k &amp;&amp; a[l].num==j) sum--;</span><br><span class="line">res+=sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res&gt;maxn)</span><br><span class="line">&#123;</span><br><span class="line">ans=i;</span><br><span class="line">maxn=res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans,maxn);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 爆搜 </tag>
            
            <tag> 模拟赛 </tag>
            
            <tag> 二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P5280 [ZJOI2019]线段树</title>
      <link href="/2019/04/02/solution_p5280/"/>
      <url>/2019/04/02/solution_p5280/</url>
      
        <content type="html"><![CDATA[<p>DP + 线段树。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=101085&auto=0&height=66"></iframe><a id="more"></a><p>神仙题啊神仙题……我这种蒟蒻赛场上啥也不会，打了一个 $20$ 分的暴力就滚粗了……DP 有一点苗头但是因为我是 DP 低能儿，所以推式子什么的还是不大可能的……</p><p>赛后在各路神仙的帮助下总算是搞懂了一些……</p><p>Sooke 把点分成了 $5$ 种，但其实也可以分成 $4$ 种。</p><p>令操作区间为 $[tl,tr]$，线段树上当前节点为 $[l,r]$，则：</p><ol><li><p>节点会被访问，即 $tl\leq l\leq r\leq tr$，显然它一定是 $1$，所以它的贡献要加上 $2^{i-1}$（$i$ 为操作编号）。</p></li><li><p>节点未被访问，即未被修改或下传，显然其贡献不变，而因为线段树的数量翻倍，则其贡献 $\times 2$。</p></li><li><p>该节点为 $1.$ 类的祖先，则其显然会在当前操作中被下放，所以贡献不变。</p></li><li><p>只被下放，但没有访问过的结点。对于这种点，我们令 $f_i$ 表示使 $i$ 到根节点存在 $1$ 的操作情况数，而这些点的贡献需要加上 $f_i$。</p></li></ol><p>显然，只要能够维护 $f$，那么 $1,3,4$ 操作都可以 $\log n$ 维护，我们考虑 $1,3$ 操作产生的贡献 $sum$，那么 $ans$ 只需要更新为 $(ans-sum)\times 2+sum$ 即可，这样相当于直接 $\times 2$，就不用考虑 $2$ 操作了。</p><p>那么问题回到如何处理 $f$，其实也非常简单，对于 $1.$，我们直接加上 $2^{i-1}$，因为它自己就是 $1$；对于 $2,4$，因为复制前后都不变，所以 $\times 2$ 即可；而对于 $3$，显然它和它的祖先都是 $0$，所以不变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inl inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">//#define getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,T,t[MAXN&lt;&lt;<span class="number">2</span>],f[MAXN&lt;&lt;<span class="number">2</span>],tag[MAXN&lt;&lt;<span class="number">2</span>],taga[MAXN&lt;&lt;<span class="number">2</span>],tagm[MAXN&lt;&lt;<span class="number">2</span>],ans,sum;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">inl <span class="keyword">void</span> <span class="title">Read</span><span class="params">(reg T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line">reg <span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">reg <span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Add</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y&gt;Mod?x+y-Mod:x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Dec</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x-y&lt;<span class="number">0</span>?x-y+Mod:x-y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">int</span> <span class="title">Mul</span><span class="params">(reg <span class="keyword">int</span> x,reg <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*y-x*y/Mod*Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">MulT</span><span class="params">(reg <span class="keyword">int</span> rt,reg <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[rt]=Mul(t[rt],x);</span><br><span class="line">tagm[rt]=Mul(tagm[rt],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">MulF</span><span class="params">(reg <span class="keyword">int</span> rt,reg <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[rt]=Mul(f[rt],x);</span><br><span class="line">tag[rt]=Mul(tag[rt],x);</span><br><span class="line">taga[rt]=Mul(taga[rt],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">AddF</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[rt]=Add(f[rt],x);</span><br><span class="line">taga[rt]=Add(taga[rt],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">inl <span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(reg <span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tagm[rt]&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">MulT(rt&lt;&lt;<span class="number">1</span>,tagm[rt]);</span><br><span class="line">MulT(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tagm[rt]);</span><br><span class="line">tagm[rt]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tag[rt]&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">MulF(rt&lt;&lt;<span class="number">1</span>,tag[rt]);</span><br><span class="line">MulF(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tag[rt]);</span><br><span class="line">tag[rt]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(taga[rt])</span><br><span class="line">&#123;</span><br><span class="line">AddF(rt&lt;&lt;<span class="number">1</span>,taga[rt]);</span><br><span class="line">AddF(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,taga[rt]);</span><br><span class="line">taga[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(reg <span class="keyword">int</span> rt,reg <span class="keyword">int</span> l,reg <span class="keyword">int</span> r,reg <span class="keyword">int</span> tl,reg <span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr)</span><br><span class="line">&#123;</span><br><span class="line">ans=Dec(ans,t[rt]);</span><br><span class="line">t[rt]=Add(t[rt],T);</span><br><span class="line">tagm[rt]=Mul(tagm[rt],<span class="number">2</span>);</span><br><span class="line">AddF(rt,T);</span><br><span class="line">sum=Add(sum,t[rt]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tl&gt;r || l&gt;tr)</span><br><span class="line">&#123;</span><br><span class="line">ans=Dec(ans,t[rt]);</span><br><span class="line">t[rt]=Add(t[rt],f[rt]);</span><br><span class="line">tagm[rt]=Mul(tagm[rt],<span class="number">2</span>);</span><br><span class="line">MulF(rt,<span class="number">2</span>);</span><br><span class="line">sum=Add(sum,t[rt]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">reg <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">PushDown(rt);</span><br><span class="line">ans=Dec(ans,t[rt]);</span><br><span class="line">sum=Add(sum,t[rt]);</span><br><span class="line">Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line">Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line">T=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(reg <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">4</span>;i++) tag[i]=tagm[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">reg <span class="keyword">int</span> opt,x,y;</span><br><span class="line">Read(opt);</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">ans=Add(Mul(ans,<span class="number">2</span>),sum);</span><br><span class="line">T=Mul(T,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DP </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦想与现实的交点——浙江省选 2019 游记</title>
      <link href="/2019/03/28/ZJOI_2019/"/>
      <url>/2019/03/28/ZJOI_2019/</url>
      
        <content type="html"><![CDATA[<h1 id="一试"><a href="#一试" class="headerlink" title="一试"></a>一试</h1><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今年菜爆啦，只能以非正式选手的身份去玩了，对自己来说只能算是和好久没见到的小伙伴的面基会了。</p><p>还可以找到失踪的 SaoFish。</p><p>咱机房还是有几位正式选手的，希望他们能进队吖。（奶* 1）</p><a id="more"></a><hr><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h1><p>吃完饭 zjq 突然和我说：你不能去玩了。</p><p>心里一惊：wtf？不能去省选了？月考怎么办要死人的woc</p><p>回机房，发现老师把名单发群里了，最后那个是我（我是最菜的）。</p><p>问候了 zjq 一顿，其还美其名曰“惊喜”，惊的我 TM 都快吓死。</p><p>这两天 zjq 和 bzt 天天早上在机房里做♂题，估计已经强到不行了。（奶* 2）</p><p>找 ljx 扯了两句，得知 LJ 和其住同一个宾馆，大写的惨字。</p><hr><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h1><p>没干啥事，放学直接回家玩了。</p><hr><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>水了一天的全民 K 歌的抢麦，真 TM 好玩，还有小姐姐说我声音好听，有点开心。</p><p>准备东西ing，把之前被某人拍坏后来修好的 mac 拿来用了，敲着这个贼爽的键盘，真是 high 到不行了。</p><p>lhy 过来问多项式 $\exp$ 的问题，然而并不会，所以先 %%%lhy 了。</p><p>记得去年 Sooke 说啥都听不懂，还在和 zjq 玩三国杀，今年他们都要进队了，该轮到我玩三国杀了。（奶* 3）</p><p>当然，玩三国杀的还有 SaoFish。</p><p>不多说了，都是泪啊。</p><hr><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>昨天晚上有个小学同学让我晚上给她寝室打电话，我：？？？</p><p>早上困得1P，和 Sinner 坐一起，后面是 bzt，压力山大。</p><p>他们都在调代码就我在水游记，emm羞愧难当。</p><p>车挺小，挤得非常满，有点头晕。</p><p>到填海估计中午了，到时候就可以去找老熟人玩了。</p><hr><p>十一点多的时候到酒店了，成功见到了 SaoFish，果然是在* 中emm</p><p>阿中的好像住得很远，可能今天都见不到了吧，不知道下午的颁奖会上能不能碰到。</p><p>反正我是上不了台领奖的【笑】。</p><hr><p>成功在填海门口遇见 Dilute，还看到 Sooke 了，emm几个月不见 Sooke 的发型更加飘逸了。</p><p>还看见 xxc（吹雪吹雪吹）了，但是机会没把握好，没打成招呼，wxw（LJC00118）和 wyl（memset0）等人则根本没看见人影。</p><p>阿中的人好多啊，整整一大巴的人，咱小地方的高中就一中巴的人，不过阿中的人都没开始就回去了。</p><p>脑补：</p><ul><li><p>LJ：啊呀你们就不要去了，完全就是浪费时间，txc 那几个领奖的和我走一趟</p><p>（然后哼着小曲走掉了）</p></li></ul><p>进场之后发现 LJ 其实就在我们这一排，而且坐的离我们非常近，不过我这个位置离他比较远，大概是发现不了。</p><p>咱这个位置非常神奇啊，第二排，前面一排全是妹子，结果发现大概不是 OIer，是负责颁奖的。</p><p><img src="https://i.loli.net/2019/04/09/5caca40583f4b.jpg" alt=""></p><p><img src="https://i.loli.net/2019/04/09/5caca404a4f04.jpg" alt=""></p><p><img src="https://i.loli.net/2019/04/09/5caca407174e2.jpg" alt=""></p><p>（图一：颁奖现场；图二：偷拍的 LJ；图三：填海发的袋子）</p><p>本以为进行两个小时的颁奖会半个小时就弄完了，真的神奇……</p><p>回酒店和 bzt 乱搞一通，写写游记，看看能不能水两题，等吃晚饭了。</p><hr><p>吃完饭依然没啥事干啊……和 SaoFish 还有遥远的 xuxing 颓了一会儿，看看 FMT 好了。</p><p>（注：FMT 指咕咕见面会，而非快速莫比乌斯变换）</p><hr><h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>上午听填海神仙 lyx 讲课，居然是传说中的《具体数学》，从头开始就听不懂了……</p><p>勉强理解了一番，和 Sooke 瞎扯了一会儿，感觉一脸懵。</p><p>下课的时候成功和 wxw 搞到了一起，还见到了 yyh 和 xxc，感觉海星。</p><p>然而现在一群人正在疯狂试图连接到大屏幕……</p><p>下午听说是孔爷讲课，期待。</p><p><img src="https://i.loli.net/2019/04/09/5caca40401be3.jpg" alt=""></p><p>（图：讲课中途第一次休息时的 Sooke）</p><hr><p>孔爷开始讲课啦，帅炸啦。</p><p><img src="https://i.loli.net/2019/04/09/5caca403f3dff.jpg" alt=""></p><p>（图：孔爷 &amp; 题目）</p><hr><p>下午孔爷讲课的时候，题面一放就跑去水群了……不愧是julao……</p><p>不过我啥也没听懂……</p><p>wxw 表示这一天上午学会了打麻将，下午练习了打麻将……</p><p>（雀魂或占领 OI 界）</p><p>晚饭后去试了机，地方超级窄……不过写代码还是可以写的……</p><p>把 Sooke 和 wxw 拉到酒店里来深入交♂流了一下（指喝了奶茶），然后就是等晚上颓废啦。</p><hr><p>晚上打联谊赛，带错符文心态崩了。</p><hr><h1 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day 2"></a>Day 2</h1><p>上午讲数据结构题……一脸懵逼……</p><hr><p>下午讲随机算法，能听懂一点，海星。</p><p>不过除了最小圆覆盖咱都没学过，有点自闭……</p><hr><p>晚上还是比较开心的，打了一把很快乐的巨魔。</p><p>等明天比赛吧。</p><hr><h1 id="Day-3-1"><a href="#Day-3-1" class="headerlink" title="Day 3"></a>Day 3</h1><p>终于到比赛日了，反正咱是来玩的，爆个零也无所谓吧。</p><p>解压密码：JYB@Xzc!!3Yue* ，疯狂暗示什么。</p><p>第一题，“九条可怜是一个喜欢打麻将的女孩子”。</p><p>艹，昨天 Sooke 说会有打麻将结果还真有了，大概率是雀魂了。</p><p>雀魂果然要占领 OI 界吗……</p><p>神仙期望题，本来想写爆搜骗个分，但看到数据范围非常犹豫，毕竟 $10!$ 就已经承受不了了，况且还想不到有什么比较好的办法来判断能否胡牌。</p><p>想了一会儿，先丢到一边，跑去看第二题了。</p><p>第二题，“九条可怜是一个喜欢数据结构的女孩子”。</p><p>$20$ 分看着非常可做，先写了。至于剩下的？</p><p>瞎猜了一个性质，发现会被交叉的区间卡，不管了直接写了，特判一下分别跑吧。</p><p>第三题，“九条可怜是一个喜欢玩游戏的女孩子”。</p><p>什么神仙题……据说部分分有 $50$，但是根本不知道怎么写啊……</p><p>溜了溜了……</p><p>Scape 鸽鸽：队线 $200+$ 吧……</p><p>猜一下二试的题：</p><ol><li><p>打麻将</p></li><li><p>麻打将</p></li><li><p>将麻打</p></li></ol><p><img src="https://uploadfiles.nowcoder.com/files/20190409/225283853_1554818406991_5caca3ff70b9d.png" alt=""></p><hr><h1 id="二试"><a href="#二试" class="headerlink" title="二试"></a>二试</h1><hr><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h1><p>咱居然能来二试……有点开森……</p><hr><h1 id="Day-0-1"><a href="#Day-0-1" class="headerlink" title="Day 0"></a>Day 0</h1><p>下午来的，发现绍一的比我们快了一个多小时……阿中那边的话，Sooke 不理我【哭】，还好 wxw 提供了一些有用的情报……</p><p>晚饭去传说中的“江谈笑风生”（指华莱士）吃，结果发现衢二一群人都在那里……</p><p>晚饭后回去玩的，本来啥事没有，结果十一点多的时候突然有人来敲门，我还以为查水表的来了……结果开门是 ykj，说隔壁的 jjc 骨折了，从凳子上摔下来了，搞得我慌的 1P，赶紧让打了 120，结果弄了半天发现我啥事也干不上，手机还被 ykj 拿走了……</p><p>于是回去继续打游戏，打完突然想起来：他拿走我手机不知道我密码啊……</p><p>赶紧联系我的手机，总算是 ojbk 了。弄到零点多，ykj 还记得回来还手机，舒服。</p><hr><h1 id="Day-1-2"><a href="#Day-1-2" class="headerlink" title="Day 1"></a>Day 1</h1><p>听说下午 zzq 讲课，瑟瑟发抖……</p><p>上午讲点分边分啥的，众所周知我都不会，所以下线的很早。硬着头皮听了一会儿，突然发现 ljx 就在正后方，于是就跑过去玩了。</p><p>快乐元气进行中，结果莫名非常卡，人物都在瞬移，还是挺烦的。</p><p>老 K 跑到我们这里来逛了一会儿该，不知道为啥。</p><p>混着混着就到下午了，终于亲眼见到 zzq 巨神了，激动。</p><p>结果又是“杂题选讲”【哭】，看到这四个字我都不想听了，蓝瘦滴很。</p><p>听了一会儿又下线了，完全不知道在说什么。</p><p>晚饭吃完又跑去和阿中的颓了，感觉海星。</p><hr><h1 id="Day-2-2"><a href="#Day-2-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>全天水题选讲……不过感觉没有 D1 难度高，所以 杂题&gt;水题【雾】</p><p>上午依然是快乐颓废，本来想找 xy ljx 和 Sooke 打雀魂，结果维护……真的是愁死我了……</p><p>好不容易熬过上午，还咕了十几分钟才开服。</p><p>开服之后赶紧拉上 ljx 和 xy 打了一局，结果……</p><p>第一局，xy 满贯，2.4w 点砸到 Sooke 的头上。</p><p>又过了两局，Sooke 飞了……</p><p>说再来一局，结果 Sooke 突然把老 K 拉了进来，瑟瑟发抖……</p><p>结果老 K 的两个清一色直接就被 ljx 两个断幺九弄没了……扎心了。</p><p>窝唯一胡的一把，两巡的时候就立直了…然后瞬间就自摸胡掉了，大概用掉了一辈子的运气。</p><p>晚上依然是快乐联盟，耍个剑姬被 qwk 的诺手打爆了，心态小崩。</p><hr><h1 id="Day-3-2"><a href="#Day-3-2" class="headerlink" title="Day 3"></a>Day 3</h1><p>比赛日啦，目标依然是不爆零。</p><p>解压密码：HI!9527@you#Too%，不知道是在暗示什么 <del>（zlw 说是 too young too simple）</del>。</p><p>看了一下题目名字，居然没有麻将或者自走棋，猜错了……</p><p>T1 依然是神仙期望，看着感觉有点想法，但是做不来。</p><p>T2 感觉比较可做，<del>虽然我做不来</del> 打了个 40 分暴力滚粗了。</p><p>（事后说是线段树合并，并不会qaq）</p><p>T3 一个很迷的模拟题，有一点想法，但是代码太复杂了，最后还是瞎骗了一点分……</p><p>滚粗了滚粗了</p><p><img src="https://uploadfiles.nowcoder.com/files/20190409/225283853_1554818406991_5caca3ff70b9d.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
            <tag> ZJOI2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 模拟赛 3-19</title>
      <link href="/2019/03/19/solution_2019_3_19/"/>
      <url>/2019/03/19/solution_2019_3_19/</url>
      
        <content type="html"><![CDATA[<p>因为 IDE 的一些问题没删成功 freopen，少了 80+ 分，自闭。</p><p>得分 $100+100+0=200$。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=658318&auto=0&height=66"></iframe><a id="more"></a><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>爆搜每个没有被染色的格子的颜色和它最多能往外扩展多少即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;<span class="number">1</span> || x&gt;n || y&lt;<span class="number">1</span> || y&gt;m || a[x<span class="number">-1</span>][y]==col || a[x][y<span class="number">-1</span>]==col || a[x+<span class="number">1</span>][y]==col || a[x][y+<span class="number">1</span>]==col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> T=<span class="number">1</span>;T&lt;=n;T++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!a[x+len][y] &amp;&amp; !a[x][y+len] &amp;&amp; !Check(x+len,y,col) &amp;&amp; !Check(x,y+len,col))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> fg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;col;i++) <span class="keyword">if</span>(!Check(x,y+len,i)) fg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(fg) <span class="keyword">break</span>;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;x+len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;y+len;j++) a[i][j]=col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!a[i][j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++) <span class="keyword">if</span>(Dfs(i,j,k)) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,<span class="keyword">char</span>(a[i][j]+<span class="number">64</span>));</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>先跑 floyd，然后枚举起点 $S$ 和终点 $T$，同时枚举每条边 $i-T$ 是否在 $S-T$ 的最短路上，如果是则令 $sum[i]+1$，$sum$ 加完之后再枚举终点，枚举中间点 $i$，如果 $i-T$ 的最短路在 $S-T$ 的最短路上，则让 $ans[S][T]$ 加上 $sum[i]$，即可得到答案。</p><p>思想和 dp 比较像。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 250005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,sum[MAXN],g[MAXN][MAXN],dis[MAXN][MAXN],ans[MAXN][MAXN];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> dis[S][x]&lt;dis[S][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"test.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">60</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">60</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="keyword">int</span> inf=dis[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">Read(z);</span><br><span class="line">g[x][y]=g[y][x]=z;</span><br><span class="line">dis[x][y]=dis[y][x]=z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i][i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(i!=j &amp;&amp; j!=k &amp;&amp; dis[i][k]!=inf &amp;&amp; dis[k][j]!=inf) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">&#123;</span><br><span class="line">S=u;</span><br><span class="line"><span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=i;</span><br><span class="line"><span class="keyword">if</span>(u==v || dis[u][v]==inf) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(g[j][v]!=inf &amp;&amp; dis[u][j]+g[j][v]==dis[u][v]) sum[v]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=i;</span><br><span class="line"><span class="keyword">if</span>(u==v || dis[u][v]==inf) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(u!=j &amp;&amp; dis[u][j]+dis[j][v]==dis[u][v]) ans[u][v]+=sum[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>这种问题不是网络流就是并查集（不考虑爆搜）……</p><p>考虑破环成链，如果删除的点周围（左上右上左下右下也算）有一个已删除的点，它在并查集中的祖先记为 $x$，它的复制的周围也有一个已删除的点，它的祖先记为 $y$，如果有任意 $x=y$，则这个点不能被删除，因为显然如果满足上述条件，它就是自上到下的必经路程。</p><p>修改时将删除点和它的复制周围的点的祖先改为它即可。</p><p>（感觉没问题但并不能 AC？只能拿 $84$ pts）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="comment">//#define getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q,a[MAXN][MAXN&lt;&lt;<span class="number">1</span>],f[MAXN*MAXN*<span class="number">2</span>],ans;</span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x==f[x]?x:f[x]=Find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Id</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x<span class="number">-1</span>)*m*<span class="number">2</span>+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line">Read(q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*m*<span class="number">2</span>;i++) f[i]=i;</span><br><span class="line"><span class="keyword">while</span>(q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line"><span class="keyword">bool</span> fg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx=x+dx[i],ny=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(a[nx][ny])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> idi=Id(nx,ny);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mx=x+dx[j],my=y+m+dy[j];</span><br><span class="line">my=(my<span class="number">-1</span>)%(m*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mx][my])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> idj=Id(mx,my);</span><br><span class="line"><span class="keyword">if</span>(Find(idi)==Find(idj))</span><br><span class="line">&#123;</span><br><span class="line">fg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!fg) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!fg) <span class="keyword">continue</span>;</span><br><span class="line">ans++;</span><br><span class="line">a[x][y]=<span class="number">1</span>;</span><br><span class="line">a[x][y+m]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> idn=Id(x,y),idm=Id(x,y+m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx=x+dx[i],ny=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(a[nx][ny]) f[Find(Id(nx,ny))]=idn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mx=x+dx[i],my=y+m+dy[i];</span><br><span class="line">my=(my<span class="number">-1</span>)%(m*<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mx][my]) f[Find(Id(mx,my))]=idm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 比赛 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 爆搜 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式算法学习笔记</title>
      <link href="/2019/03/19/poly_algorithm_note/"/>
      <url>/2019/03/19/poly_algorithm_note/</url>
      
        <content type="html"><![CDATA[<p>这里是一个菜鸡的多项式学习笔记……</p><p>只会背板子不会原理哇qaq</p><p>目前更新至：多项式除法</p><p>Todolist：多项式三角函数</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31108205&auto=0&height=66"></iframe><a id="more"></a><h1 id="1-多项式乘法"><a href="#1-多项式乘法" class="headerlink" title="1 多项式乘法"></a>1 多项式乘法</h1><p>基础中的基础吧……</p><p>珂以用 FFT 或者 NTT 求解，其中 FFT 没有限制，NTT 精度更高，但 NTT 需要限制模数为 $998244353$。</p><p>FFT 也有两种形式，即递归与非递归，非递归要快上很多。</p><p>FFT（非递归）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span> + (Complex a,Complex b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Complex)&#123;a.x+b.x,a.y+b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span> - (Complex a,Complex b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Complex)&#123;a.x-b.x,a.y-b.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span> * (Complex a,Complex b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Complex)&#123;a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;f[<span class="number">1000005</span>],g[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *x,<span class="keyword">int</span> Type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++) <span class="keyword">if</span>(i&lt;R[i]) swap(x[i],x[R[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxn;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex W=(Complex)&#123;<span class="built_in">cos</span>(Pi/i),Type*<span class="built_in">sin</span>(Pi/i)&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxn;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Complex w=(Complex)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                Complex a=x[j+k],b=w*x[i+j+k];</span><br><span class="line">                x[j+k]=a+b;</span><br><span class="line">                x[i+j+k]=a-b;</span><br><span class="line">                w=W*w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FFT 的代码比较老，凑合着看吧。</p><p>其中 Type 为 $1$ 时为正变换，Type 为 $-1$ 时为逆变换。</p><p>NTT（Gi 为 $3$，Mod 为 $998244353$）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> typ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) <span class="keyword">if</span>(i&lt;rev[i]) swap(A[i],A[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> mid=<span class="number">1</span>;mid&lt;lim;mid&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn=QuickPow(Gi,(Mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lim;j+=mid&lt;&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> W=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;mid;k++,W=W*Wn%Mod)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x=A[j+k],y=W*A[j+k+mid]%Mod;</span><br><span class="line">                A[j+k]=(x+y)%Mod;</span><br><span class="line">                A[j+k+mid]=(x-y+Mod)%Mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(typ==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> inv=QuickPow(lim,Mod<span class="number">-2</span>);</span><br><span class="line">    reverse(A+<span class="number">1</span>,A+lim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) A[i]=A[i]*inv%Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板题 FFT 的速度在 $2000$~$3000$ ms，而 NTT 在 $1000$~$2000$ ms，快了 $1000$ ms 左右。</p><hr><h1 id="2-多项式求逆"><a href="#2-多项式求逆" class="headerlink" title="2 多项式求逆"></a>2 多项式求逆</h1><p>已知 $F(x)$，要求 $G(x)$ 令 $F(x)\times G(x)\equiv 1 ( \text{mod}  x^n )$</p><p>采用递归的思想，假设我们现在求出了 $G’$：</p><script type="math/tex; mode=display">F\times G'\equiv 1\ (\text{mod}\ \ x^{\lceil {n\over 2}\rceil})</script><p>则：</p><script type="math/tex; mode=display">F\times G\equiv 1\ (\text{mod}\ \ x^{\lceil {n\over 2}\rceil})</script><p>相减得：</p><script type="math/tex; mode=display">G'-G\equiv 0\ (\text{mod}\ \ x^n)</script><p>两边平方，拆开来：</p><script type="math/tex; mode=display">G'^2-2GG'+G^2\equiv 0\ (\text{mod}\ \ x^n)</script><p>两边同乘上 $F$，因为 $F(x)\times G(x)\equiv 1 ( \text{mod}  x^n )$，所以：</p><script type="math/tex; mode=display">FG'^2-2G'+G\equiv 0\ (\text{mod}\ \ x^n)</script><p>移项，则可得：</p><script type="math/tex; mode=display">G=2G'-FG'^2\equiv 0\ (\text{mod}\ \ x^n)</script><p>递推式 get√，自下往上递归求解即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetInv</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> *g,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g[<span class="number">0</span>]=QuickPow(f[<span class="number">0</span>],Mod<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GetInv(f,g,len+<span class="number">1</span>&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    lim=<span class="number">1</span>;</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;(len&lt;&lt;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(m<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) C[i]=f[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&lt;lim;i++) C[i]=<span class="number">0</span>;</span><br><span class="line">    NTT(C,<span class="number">1</span>);</span><br><span class="line">    NTT(g,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) g[i]=((<span class="number">2l</span>l-g[i]*C[i]%Mod)+Mod)%Mod*g[i]%Mod;</span><br><span class="line">    NTT(g,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&lt;lim;i++) g[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-多项式对数函数"><a href="#3-多项式对数函数" class="headerlink" title="3 多项式对数函数"></a>3 多项式对数函数</h1><p>已知 $F(x)$，要求 $G(x)$ 令 $G(x)\equiv \ln F(x) (\text{mod}  x^n)$。</p><p>这个东西其实不难求，我们令函数 $f(x)=\ln(x)$，则原式可以化作：</p><script type="math/tex; mode=display">G(x)\equiv f(F(x))\ (\text{mod}\ \ x^n)</script><p>然后两边求导，可以发现 $f(F(x))$ 是个复合函数，复合函数求导公式为 $f(g(x))’=f’(g(x))g’(x)$，所以左右求导之后为：</p><script type="math/tex; mode=display">G'(x)=f'(F(x))F'(x)\ (\text{mod}\ \ x^n)</script><p>此时我们可以想一想 $\ln$ 的求导公式，$\ln’(x)={1\over x}$，所以接着可以化为：</p><script type="math/tex; mode=display">G'(x)={F'(x)\over F(x)}\ (\text{mod}\ \ x^n)</script><p>这个时候你可能要问了：诶多项式除法？你在逗我吗？</p><p>当然不是辣……我们刚刚才学多项式的逆元，反正我们不要求商只要求余数，为什么不拿出来用呢？</p><p>所以我们只需要将读入的 $G$ 求导作为 $a$，求逆作为 $b$，计算出 $a\times b (\text{mod}  998244353)$，此时求出的是 $G’$，对它求积分就可以得出我们要求的 $G$ 了。</p><p>什么？你不会求导和积分？<del>em那你为什么要做多项式题</del></p><p>给出求导与积分公式如下：</p><script type="math/tex; mode=display">{x^a}'=ax^{a-1},\quad \int x^{a}dx={1\over a+1}x^{a+1}</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetDev</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> *g,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++) g[i<span class="number">-1</span>]=i*f[i]%Mod;</span><br><span class="line">    g[len<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetInvDev</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> *g,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++) g[i]=f[i<span class="number">-1</span>]*QuickPow(i,Mod<span class="number">-2</span>)%Mod;</span><br><span class="line">    g[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLn</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> *g,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GetDev(f,a,len);</span><br><span class="line">    GetInv(f,b,len);</span><br><span class="line">    lim=<span class="number">1</span>;</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;(len&lt;&lt;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(m<span class="number">-1</span>));</span><br><span class="line">    NTT(a,<span class="number">1</span>);</span><br><span class="line">    NTT(b,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) a[i]=a[i]*b[i]%Mod;</span><br><span class="line">    NTT(a,<span class="number">-1</span>);</span><br><span class="line">    GetInvDev(a,g,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-多项式指数函数"><a href="#4-多项式指数函数" class="headerlink" title="4 多项式指数函数"></a>4 多项式指数函数</h1><p>神仙方法……需要先学泰勒展开，然后借助泰勒展开学会牛顿迭代，然后才能做……</p><p>泰勒展开就不讲了，牛顿迭代可以见<a href="http://blog.miskcoo.com/2015/06/polynomial-with-newton-method" target="_blank" rel="noopener">这里</a>，反正最后可以得到：</p><script type="math/tex; mode=display">F(z)\equiv F_0(z)-{G(F_0(z))\over G'(F_0(z))}\ (\text{mod}\ \ z^n)</script><p>所以我们考虑求 $G(x)$ 使 $G(x)=e^{F(x)}$，直接求显然是不现实的，那么我们因为刚刚学了对数函数，而对数和指数是逆运算，所以我们考虑把它转化成指数：</p><script type="math/tex; mode=display">\ln G(x)-F(x)=0</script><p>出现了 $0$，那么我们刚刚学牛顿迭代，所以我们考虑用它来求零点，令 $f(G(x))=\ln G(x)-F(x)$，珂以把 $F(x)$ 看成常数项，所以求导出来是：$f’(G(x))={1\over G(x)}$，把这两个代进牛顿迭代的式子，珂以得到：</p><script type="math/tex; mode=display">G(x)\equiv G_0(x)-{\ln G_0(x)-F(x) \over {1\over G_0(x)}} \ (\text{mod}\ \ x^n)</script><script type="math/tex; mode=display">G(x)\equiv G_0(x)-(\ln G_0(x)-F(x) )\times G_0(x) \ (\text{mod}\ \ x^n)</script><script type="math/tex; mode=display">G(x)\equiv G_0(x)(1-\ln G_0(x)+F(x)) \ (\text{mod}\ \ x^n)</script><p>依然递归求解即可。</p><p>（求 $\ln$ 的时候记得清空 a 数组……）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetExp</span><span class="params">(<span class="keyword">int</span> *f,<span class="keyword">int</span> *g,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GetExp(f,g,len+<span class="number">1</span>&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    lim=<span class="number">1</span>;</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;(len&lt;&lt;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(m<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(len&lt;&lt;<span class="number">1</span>);i++) d[i]=e[i]=<span class="number">0</span>;</span><br><span class="line">    GetLn(g,d,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) e[i]=f[i];</span><br><span class="line">    NTT(g,<span class="number">1</span>);</span><br><span class="line">    NTT(d,<span class="number">1</span>);</span><br><span class="line">    NTT(e,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) g[i]=(<span class="number">1l</span>l-d[i]+e[i]+Mod)*g[i]%Mod;</span><br><span class="line">    NTT(g,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&lt;lim;i++) g[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="5-多项式快速幂"><a href="#5-多项式快速幂" class="headerlink" title="5 多项式快速幂"></a>5 多项式快速幂</h1><p>这个好“简单”的……</p><p>前置芝士为 多项式 $\exp$ 和 多项式 $\ln$……</p><p>考虑对数函数的性质，即：$log_ab^k=klog_ab$，这个对多项式也适用。</p><p>那么我们知道，$\exp$ 其实就是 $e^x$，$\ln$ 其实就是 $log_ex$，那么……</p><p>要求 $G(x)$ 使得 $G(x)=F^k(x)$，两边取自然对数，得：</p><script type="math/tex; mode=display">\ln G(x)=k\ln F(x)</script><p>所以我们把 $F(x)$ 求 $\ln$，把系数乘上 $k$，然后做一遍 $\exp$ 就得到了 $G(x)$。</p><p><del>（简不简单吖~）</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %s"</span>,&amp;n,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++) k=((k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+(s[i]<span class="number">-48</span>))%Mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;F[i]);</span><br><span class="line">    GetLn(F,G,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) G[i]=G[i]*k%Mod;</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">    GetExp(G,T,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,T[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="6-多项式开根"><a href="#6-多项式开根" class="headerlink" title="6 多项式开根"></a>6 多项式开根</h1><p>又是一道简单题……</p><p>要求 $G(x)$ 使得 $G(x)^2=F(x)$，想一想多项式快速幂的结论，想一想对数的性质：$log_ab^k=klog_ab$，于是可以将它化成：</p><script type="math/tex; mode=display">2\ln G(x)=\ln F(x)</script><p>和多项式快速幂一样的处理方法，求出 $\ln$ 后将系数除 $2$（乘 $2$ 的逆元），然后一遍 $\exp$ 带走。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;F[i]);</span><br><span class="line">    GetLn(F,G,n);</span><br><span class="line">    <span class="keyword">int</span> inv=QuickPow(<span class="number">2</span>,Mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) G[i]=G[i]*inv%Mod;</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">    GetExp(G,T,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,T[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="7-多项式除法"><a href="#7-多项式除法" class="headerlink" title="7 多项式除法"></a>7 多项式除法</h1><p>神奇的方法……</p><p>这个还是背结论吧……</p><p>给出 $F(x)$ 和 $G(x)$，要求出 $Q(x)$ 和 $R(x)$ 使得 $F(x)\equiv Q(x)\times G(x)+R(x)$。</p><p>我们设多项式 $A$ 的 $A_r=x^nA({1\over x})$，也就相当于把系数全部倒过来，然后珂以开始化式子：</p><script type="math/tex; mode=display">F(x)=Q(x)\times G(x)+R(x)</script><script type="math/tex; mode=display">F(\frac{1}{x})=Q(\frac{1}{x})\times G(\frac{1}{x})+R(\frac{1}{x})</script><script type="math/tex; mode=display">x^nF(\frac{1}{x})=x^{n-m}Q(\frac{1}{x})\times x^mG(\frac{1}{x})+x^{n-m+1}\times x^{m-1}\times R(\frac{1}{x})</script><script type="math/tex; mode=display">F_r(x)=Q_r(x)\times G_r(x)+x^{n-m+1}\times R_r(x)\ (\text{mod}\ \ x^{n-m+1})</script><script type="math/tex; mode=display">F_r(x)=Q_r(x)\times G_r(x)\ (\text{mod} \ \ x^{n-m+1})</script><script type="math/tex; mode=display">Q_r(x)=F_r(x)\times G_r^{-1}(x)\ (\text{mod} \ \ x^{n-m+1})</script><p>所以我们可以先求出 $F_r$ 和 $G_r$，然后求出 $G_r$ 的逆元，乘起来之后再反过来就可以得到 $Q$ 了，最后把 $Q$ 和 $G$ 乘起来，用 $F$ 减去之后就得到 $R$ 了。</p><p>（记得要把 $F_r$ 和 $G_r$ 的无关元素删掉，不然算 $Q$ 的时候要出事）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    n++;</span><br><span class="line">    m++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;F[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;G[i]);</span><br><span class="line">    <span class="keyword">int</span> x=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++,x--) FF[i]=F[x];</span><br><span class="line">    x=m<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++,x--) GG[i]=G[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n-m+<span class="number">1</span>;i&lt;lim;i++) GG[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len=n-m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&lt;n;i++) FF[i]=GG[i]=<span class="number">0</span>;</span><br><span class="line">    GetInv(GG,IV,len);</span><br><span class="line">    lim=<span class="number">1</span>;</span><br><span class="line">    mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;(len&lt;&lt;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        mx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(mx<span class="number">-1</span>));</span><br><span class="line">    NTT(FF,<span class="number">1</span>);</span><br><span class="line">    NTT(IV,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) FF[i]=FF[i]*IV[i]%Mod;</span><br><span class="line">    NTT(FF,<span class="number">-1</span>);</span><br><span class="line">    x=len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Q[i]=FF[x];</span><br><span class="line">        x--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len;i&lt;n;i++) Q[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,Q[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    len=n;</span><br><span class="line">    lim=<span class="number">1</span>;</span><br><span class="line">    mx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lim&lt;(len&lt;&lt;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        mx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lim;i++) rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(mx<span class="number">-1</span>));</span><br><span class="line">    NTT(Q,<span class="number">1</span>);</span><br><span class="line">    NTT(G,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) Q[i]=Q[i]*G[i]%Mod;</span><br><span class="line">    NTT(Q,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,(F[i]-Q[i]+Mod)%Mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 多项式算法 </tag>
            
            <tag> NTT </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 SP2906 GCD2 - GCD2</title>
      <link href="/2019/03/11/solution_sp2906/"/>
      <url>/2019/03/11/solution_sp2906/</url>
      
        <content type="html"><![CDATA[<p>神奇的做法。</p><p>求 $\gcd(a,b)$，其中 $b$ 为极大值。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=628591&auto=0&height=66"></iframe><a id="more"></a><p>首先看到 $b\leq10^{250}$，首先想到<del>自己是个250</del>肯定不是普通做法能做的了，此时我们有两种做法，一种就是老老实实写高精加减，然后写更相减损术，如果您能保证高精不出锅的话也不失为一种稳妥的办法，但显然不是这题的最优解，因为题中还有一个条件：$a\leq4\times10^{4}$，既然 $a$ 能直接存下，那么心中应该有点数了，显然是有别的办法可以做的。</p><p>考虑辗转相除法的流程，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> !y?x:Gcd(y,x%y);</span><br></pre></td></tr></table></figure><p>其中 $x$ 初始为 $a$，$y$ 初始为 $b$，那么很显然，在递归了很多遍之后，如果 $b$ 远大于 $a$，那么 $b$ 必然会被 $a$ $\%$ 很多次，而 $a$ 则不会有变化，我们可以利用这个思想，在预处理时可以提前将 $b$ 对 $a$ 取模，然后最后做一遍辗转相除就可以求得答案了。</p><p>什么？你问 $b&lt;a$ 怎么办？那显然预处理时 $b$ 不会变化，对结果也不会有影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 255</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> ch[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> !y?x:Gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Time;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Time);</span><br><span class="line"><span class="keyword">while</span>(Time--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,len;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %s"</span>,&amp;x,ch+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,ch+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">len=<span class="built_in">strlen</span>(ch+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) res=((res&lt;&lt;<span class="number">3</span>)+(res&lt;&lt;<span class="number">1</span>)+(ch[i]<span class="number">-48</span>))%x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Gcd(res,x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 乱搞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 SP19985 GCDEX2 - GCD Extreme (hard)</title>
      <link href="/2019/03/10/solution_sp19985/"/>
      <url>/2019/03/10/solution_sp19985/</url>
      
        <content type="html"><![CDATA[<p>杜教筛。</p><p>求：</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=i+1}^{n}gcd(i,j)</script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1350160463&auto=0&height=66"></iframe><a id="more"></a><p>有点神奇的一道题目……</p><p>第一套路，枚举 gcd：</p><script type="math/tex; mode=display">\sum_{d=1}^{n}\sum_{i=1}^{n}\sum_{j=i+1}^{n}d\times[gcd(i,j)=d]</script><p>然后用莫比乌斯反演：</p><script type="math/tex; mode=display">\sum_{d=1}^{n}\sum_{i=1}^{\lfloor{n\over d}\rfloor}\sum_{j=i+1}^{\lfloor{n\over d}\rfloor}\sum_{k|gcd(i,j)}\mu(k)\times d</script><p>数论分块套数论分块？时间复杂度 $\text{O}(n)$ 啊……怎么破……</p><p>隔壁 Sinner：哇 你个 ** 你知不知道什么叫 $\varphi$ 啊？！【批判一番】</p><p>em感觉自己就是个蒟蒻（其实就是个蒟蒻）</p><p>所以我们可以直接把它化成：</p><script type="math/tex; mode=display">\sum_{d=1}^{n}d\times\sum_{i=1}^{\lfloor{n\over d}\rfloor}\varphi(i)</script><p>杜教筛直接上就行了…… $\varphi * I=id$ 好写的 1P ……</p><p>（有些细节要注意，比如计算 $I$ 的前缀和的时候，为了防止溢出之后出错判断奇偶性等）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,pri[MAXN/<span class="number">10</span>+<span class="number">5</span>],tot,phi[MAXN+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> isp[MAXN+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetPrime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">isp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAXN;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!isp[i])</span><br><span class="line">&#123;</span><br><span class="line">pri[++tot]=i;</span><br><span class="line">phi[i]=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot &amp;&amp; i*pri[j]&lt;=MAXN;j++)</span><br><span class="line">&#123;</span><br><span class="line">isp[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%pri[j]) phi[i*pri[j]]=phi[i]*(pri[j]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">phi[i*pri[j]]=phi[i]*pri[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAXN;i++) phi[i]+=phi[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x&amp;<span class="number">1</span>)?((x+<span class="number">1</span>)/<span class="number">2</span>*x):(x/<span class="number">2</span>*(x+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=MAXN) <span class="keyword">return</span> phi[x];</span><br><span class="line"><span class="keyword">if</span>(f.count(x)) <span class="keyword">return</span> f[x];</span><br><span class="line"><span class="keyword">int</span> res=G(x),l=<span class="number">2</span>,r;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=x)</span><br><span class="line">&#123;</span><br><span class="line">r=x/(x/l);</span><br><span class="line">res-=(r-l+<span class="number">1</span>)*GetSum(x/l);</span><br><span class="line">l=r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">f[x]=res;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GetPrime();</span><br><span class="line"><span class="keyword">int</span> Time;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%llu"</span>,&amp;Time);</span><br><span class="line"><span class="keyword">while</span>(Time--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>,l=<span class="number">1</span>,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%llu"</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(l&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">r=n/(n/l);</span><br><span class="line">res+=(GetSum(n/l)<span class="number">-1</span>)*(G(r)-G(l<span class="number">-1</span>));</span><br><span class="line">l=r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%llu\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 杜教筛 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 数论分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3934 Nephren Ruq Insania</title>
      <link href="/2019/03/05/solution_p3934/"/>
      <url>/2019/03/05/solution_p3934/</url>
      
        <content type="html"><![CDATA[<p>扩展欧拉定理。</p><p>两种操作，区间加和区间查询 $a[l]^{a[l+1]^{a[l+2]}}…\mod p$。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1341733740&auto=0&height=66"></iframe><a id="more"></a><p>好毒瘤的题……之前有一道 <code>CF906D Power Tower</code> 有一种神奇的写法，为了满足扩展欧拉定理中 $b≥\varphi(p)$ 的限制，可以在进行 $\%$ 运算的时候加上一个 $p$，因为 $p&gt;\varphi(p)$，所以就可以不用管限制，最后只要把多出的 $\%$ 掉就行了，但是这道题并不刑【哭】，写法不好就会爆精度，所以我们要考虑别的写法。</p><p>首先，我们在做那道题的时候可以使用递归的写法，但是看看这道题的出题人，emmm于是我们应该使用线性的写法，也就是可以预处理出每一次 $\%$ 的 $\varphi(p)$，然后考虑 $b≥\varphi(p)$ 的限制，我们依然是在运算时额外加上一个 $p$，但是和之前的做法不同，之前是任何运算结束后都要进行判断，我们已经知道了这样会爆精度，所以我们考虑在快速幂过程中记录是否要加上 $p$，最后再加上。</p><p>至于怎么判断是否要加 $p$，因为只要进行了 $\%$ 运算，$b$ 就有可能会 $&lt;\varphi(p)$，所以我们就记录有没有进行 $\%$ 运算即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 20000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,c[MAXN+<span class="number">5</span>],pri[MAXN+<span class="number">5</span>],tot,phi[MAXN+<span class="number">5</span>],ha[MAXN+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> isp[MAXN+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetPrime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">isp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAXN;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!isp[i])</span><br><span class="line">&#123;</span><br><span class="line">pri[++tot]=i;</span><br><span class="line">phi[i]=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot &amp;&amp; i*pri[j]&lt;=MAXN;j++)</span><br><span class="line">&#123;</span><br><span class="line">isp[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%pri[j]) phi[i*pri[j]]=phi[i]*(pri[j]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">phi[i*pri[j]]=phi[i]*pri[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">c[x]+=val;</span><br><span class="line">x+=lowbit(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">res+=c[x];</span><br><span class="line">x-=lowbit(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mod</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> p,<span class="keyword">bool</span> &amp;fg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=p)</span><br><span class="line">&#123;</span><br><span class="line">x%=p;</span><br><span class="line">fg=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> fg=<span class="number">0</span>;</span><br><span class="line">Mod(x,p,fg);</span><br><span class="line"><span class="keyword">while</span>(y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">res=res*x;</span><br><span class="line">Mod(res,p,fg);</span><br><span class="line">&#125;</span><br><span class="line">x=x*x;</span><br><span class="line">Mod(x,p,fg);</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res+fg*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen("data.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("outp.out","w",stdout);</span></span><br><span class="line">GetPrime();</span><br><span class="line"><span class="keyword">int</span> pre=<span class="number">0</span>;</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">Read(x);</span><br><span class="line">Modify(i,x-pre);</span><br><span class="line">pre=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> opt,x,y,z;</span><br><span class="line">Read(opt);</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">Read(z);</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Modify(x,z);</span><br><span class="line">Modify(y+<span class="number">1</span>,-z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> pos=x;</span><br><span class="line">ha[pos]=z;</span><br><span class="line">z=phi[z];</span><br><span class="line"><span class="keyword">while</span>(z&gt;<span class="number">1</span> &amp;&amp; pos&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">ha[++pos]=z;</span><br><span class="line">z=phi[z];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;pos&gt;=x;pos--) res=QuickPow(Query(pos),res,ha[pos]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res%ha[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（既然是 ynoi 的题解，在结尾给一张 Nephren 的图吧qwq）</p><p><img src="https://z4a.net/images/2019/03/05/64050525_p0.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 扩展欧拉定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF906D Power Tower / 欧拉定理 &amp; 扩展欧拉定理学习笔记</title>
      <link href="/2019/03/04/solution_cf906d_euler_theorem_note/"/>
      <url>/2019/03/04/solution_cf906d_euler_theorem_note/</url>
      
        <content type="html"><![CDATA[<p>扩展欧拉定理。</p><p>在了解这东西之前，我们首先要知道欧拉定理是什么。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1309896289&auto=0&height=66"></iframe><a id="more"></a><p>欧拉定理：</p><script type="math/tex; mode=display">\text{当}\ \gcd(a,p)=1 \ \text{时，有}\ a^{\varphi(p)}\equiv1\ (\text{mod}\ p)</script><p>所以可以得：</p><script type="math/tex; mode=display">a^b\equiv a^{b\ \text{mod}\ \varphi(p)}\ (\text{mod}\ p)</script><p>但是因为有一个 $\gcd(a,p)=1$ 的限制，所以不能对所有情况适用，此时我们就需要引入扩展欧拉定理了。</p><script type="math/tex; mode=display">\text{当}\ b≥\varphi(p)\ \text{时，有}\ a^b\equiv a^{b\ \text{mod}\ \varphi(p)+\varphi(p)}\ (\text{mod}\ p)</script><p>$b&lt;\varphi(p)$ 时就正常算就行了。</p><p>知道这个之后我们可以怎么做呢？显然，我们可以递归求解一些形如 $a^b \text{mod} p$ 的问题了，对于这题，也可以不递归，递推即可。</p><p>当然，因为 $m\leq1e9$，所以线筛 $\varphi$ 的办法是刑不通的，我们可以直接暴力算，然后开一个 map 存下我们算的值，重复调用时可以省下很多复杂度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,Mod,a[MAXN+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; phi;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Phi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=x,pos=x;</span><br><span class="line"><span class="keyword">if</span>(phi.count(x)) <span class="keyword">return</span> phi[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(x%i))</span><br><span class="line">&#123;</span><br><span class="line">res=res/i*(i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>(!(x%i)) x/=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">1</span>) res=res/x*(x<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> phi[pos]=res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&lt;p?x:(x%p+p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=Mo(res*x,p);</span><br><span class="line">x=Mo(x*x,p);</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (l==r || p==<span class="number">1</span>)?Mo(a[l],p):QuickPow(a[l],Dfs(l+<span class="number">1</span>,r,Phi(p)),p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"data.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">Read(n);</span><br><span class="line">Read(Mod);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Read(a[i]);</span><br><span class="line">Read(m);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Dfs(x,y,Mod)%Mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 欧拉定理 </tag>
            
            <tag> 扩展欧拉定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 SP5971 LCMSUM - LCM Sum</title>
      <link href="/2019/02/21/solution_sp5971/"/>
      <url>/2019/02/21/solution_sp5971/</url>
      
        <content type="html"><![CDATA[<p>欧拉函数。</p><p>求 $\sum_{i=1}^{n}lcm(i,n)$。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=536601&auto=0&height=66"></iframe><a id="more"></a><p>算是对 BJpers2 巨佬的代码补充，推公式过程如下：</p><script type="math/tex; mode=display">\sum_{i=1}^{n}lcm(i,n)=\sum_{i=1}^{n}{in\over gcd(i,n)}=n\sum_{i=1}^{n}{i\over gcd(i,n)}</script><p>转化 $gcd$：</p><script type="math/tex; mode=display">=n\sum_{d|n}\sum_{i=1}^{n}{i\over d}[gcd(i,n)=d]</script><script type="math/tex; mode=display">=n\sum_{d|n}\sum_{i=1}^{n\over d}{i\over d}[gcd(id,n)=d]</script><script type="math/tex; mode=display">=n\sum_{d|n}\sum_{i=1}^{n\over d}i[gcd(i,{n\over d})=1]</script><script type="math/tex; mode=display">=n\sum_{d|n}\sum_{i=1}^{d}i[gcd(i,d)=1]</script><p>后面这个等于 $\frac{φ(d)d}{2}$，所以原式最终为：</p><script type="math/tex; mode=display">=n\sum_{d|n}{\frac{φ(d)d}{2}}</script><p>可以预处理时把每个 $i$ 的倍数加上 $\frac{φ(i)i}{2}$，然后最后输出时乘上 $n$。（$i$ 等于 $1$ 时值为 $1$）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> pri[MAXN+<span class="number">5</span>],tot,phi[MAXN+<span class="number">5</span>];</span><br><span class="line">ll f[MAXN+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> isp[MAXN+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetPrime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">isp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAXN;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!isp[i])</span><br><span class="line">&#123;</span><br><span class="line">pri[++tot]=i;</span><br><span class="line">phi[i]=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot &amp;&amp; i*pri[j]&lt;=MAXN;j++)</span><br><span class="line">&#123;</span><br><span class="line">isp[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%pri[j]) phi[i*pri[j]]=phi[i]*phi[pri[j]];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">phi[i*pri[j]]=phi[i]*pri[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAXN;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i*j&lt;=MAXN;j++) f[i*j]+=(i==<span class="number">1</span>?<span class="number">1</span>:<span class="number">1l</span>l*phi[i]*i/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GetPrime();</span><br><span class="line"><span class="keyword">int</span> Time;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Time);</span><br><span class="line"><span class="keyword">while</span>(Time--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]*<span class="number">1l</span>l*n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3704 [SDOI2017]数字表格</title>
      <link href="/2019/02/21/solution_p3704/"/>
      <url>/2019/02/21/solution_p3704/</url>
      
        <content type="html"><![CDATA[<p>莫比乌斯反演。</p><p>求：</p><script type="math/tex; mode=display">\prod_{i=1}^{n}\prod_{j=1}^{n}f_{gcd(i,j)}</script><p>（其中 $f_i$ 为斐波那契数列的第 $i$ 项）</p><p>（什么毒瘤题啊这是……）</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1345820742&auto=0&height=66"></iframe><a id="more"></a><p>出现了 $gcd$，那么就用一个惯用技巧：枚举之，所以式子变成：</p><script type="math/tex; mode=display">\prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}f_d\times[gcd(i,j)=d]</script><p>因为有许多重复的 $f_d$ 被记录到答案里，我们不妨将它化成 $f_d^x$ 的形式，如下：</p><script type="math/tex; mode=display">\prod_{d=1}^{n}f_d ^{\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]}</script><p>上面这坨好像有点眼熟？单独拎出来看看：</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]</script><p>这也太熟悉了吧……化简之：</p><script type="math/tex; mode=display">=\sum_{i=1}^{n\over d}\sum_{j=1}^{m\over d}[gcd(i,j)=1]</script><p>根据 $\mu$ 的性质：$\sum_{d|n}\mu(d)=[n=1]$，可以将它展开成：</p><script type="math/tex; mode=display">=\sum_{i=1}^{n\over d}\sum_{j=1}^{m\over d}\sum_{k|gcd(i,j)}\mu(k)</script><p>$k|gcd(i,j)$ 看着很不爽，把它化成枚举的形式：</p><script type="math/tex; mode=display">=\sum_{i=1}^{n\over d}\sum_{j=1}^{m\over d}\sum_{k=1}^{n\over d}\mu(k)\times [k|gcd(i,j)]</script><p>因为有许多重复的 $\mu(k)$ 被累加，所以我们可以将它提到前面去：</p><script type="math/tex; mode=display">=\sum_{k=1}^{n\over d}\mu(k)\sum_{i=1}^{n\over d}\sum_{j=1}^{m\over d}[k|gcd(i,j)]</script><p>由于只有满足后面这个才会对答案产生贡献，所以我们可以发现，只有 $i,j$ 都是 $k$ 的倍数时能有贡献，因此可以化简出一个很经典的式子：</p><script type="math/tex; mode=display">=\sum_{k=1}^{n\over d}\mu(k)\lfloor {n\over dk} \rfloor \lfloor {m\over dk} \rfloor</script><p>这个式子可以数论分块求，不赘述。</p><p>回到原式，将这个代入，可得：</p><script type="math/tex; mode=display">\prod_{d=1}^{n}f_d ^{\sum_{i=1}^{n\over d}\mu(k)\lfloor {n\over id} \rfloor \lfloor {m\over id} \rfloor}</script><p>按照之前某道题的套路，我们可以枚举 $id=T$，对式子进行进一步化简：</p><script type="math/tex; mode=display">\prod_{T=1}^{n}\prod_{d|T}f_T^{\mu({T\over d})\lfloor {n\over T} \rfloor \lfloor {m\over T} \rfloor}</script><p>为了方便求，加个括号：</p><script type="math/tex; mode=display">\prod_{T=1}^{n}(\prod_{d|T}f_T^{\mu({T\over d})})^{\lfloor {n\over T} \rfloor \lfloor {m\over T} \rfloor}</script><p>令：</p><script type="math/tex; mode=display">F(n)=\prod_{d|n}f_d^{\mu({n\over d})}</script><p>则原式最终等于</p><script type="math/tex; mode=display">\prod_{T=1}^{n}F(T)^{\lfloor {n\over T} \rfloor \lfloor {m\over T} \rfloor}</script><p>内层的 $F(T)$ 可以暴力求，外层的 $\lfloor {n\over T} \rfloor \lfloor {m\over T} \rfloor$ 就是一个很明显的数论分块式了，直接上数论分块就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,pri[MAXN+<span class="number">5</span>],tot,f[MAXN+<span class="number">5</span>],inv[MAXN+<span class="number">5</span>],F[MAXN+<span class="number">5</span>],mu[MAXN+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> isp[MAXN+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=<span class="number">1l</span>l*res*x%Mod;</span><br><span class="line">x=<span class="number">1l</span>l*x*x%Mod;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetPrime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">isp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAXN;i++)</span><br><span class="line">&#123;</span><br><span class="line">f[i]=(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>])%Mod;</span><br><span class="line">inv[i]=QuickPow(f[i],Mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">if</span>(!isp[i])</span><br><span class="line">&#123;</span><br><span class="line">pri[++tot]=i;</span><br><span class="line">mu[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot &amp;&amp; i*pri[j]&lt;=MAXN;j++)</span><br><span class="line">&#123;</span><br><span class="line">isp[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%pri[j]) mu[i*pri[j]]=mu[i]*mu[pri[j]];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">mu[i*pri[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=MAXN;i++) F[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAXN;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!mu[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=MAXN;j+=i) F[j]=<span class="number">1l</span>l*F[j]*(mu[i]==<span class="number">1</span>?f[j/i]:inv[j/i])%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAXN;i++) F[i]=<span class="number">1l</span>l*F[i]*F[i<span class="number">-1</span>]%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GetPrime();</span><br><span class="line"><span class="keyword">int</span> Time;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Time);</span><br><span class="line"><span class="keyword">while</span>(Time--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">if</span>(n&gt;m) swap(n,m);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1</span>,INV;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">r=min(n/(n/l),m/(m/l));</span><br><span class="line">INV=<span class="number">1l</span>l*F[r]*QuickPow(F[l<span class="number">-1</span>],Mod<span class="number">-2</span>)%Mod;</span><br><span class="line">ans=<span class="number">1l</span>l*ans*QuickPow(INV,(<span class="number">1l</span>l*(n/l)*(m/l))%(Mod<span class="number">-1</span>))%Mod;</span><br><span class="line">l=r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(ans+Mod)%Mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演 &amp; 杜教筛学习笔记</title>
      <link href="/2019/02/20/mobius_inverse_note/"/>
      <url>/2019/02/20/mobius_inverse_note/</url>
      
        <content type="html"><![CDATA[<p>莫比乌斯反演这个东西……怎么说呢，只是看着非常难非常高大上，但是原理其实挺好理解的……不过通常都只是用于推导，还要配合数论分块或者筛法食用，不同情景不同思考，还是很需要随机应变的。</p><p>（数论题天下第二毒瘤！）</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1332491711&auto=0&height=66"></iframe><a id="more"></a><h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>当 $f(a)\times f(b)=f(ab)$，其中仅在 $a$ 与 $b$ 互质的情况下成立的函数为积性函数，在所有情况下成立的函数为完全积性函数。</p><p>常见的积性函数：$φ$，$\mu$，$etc.$</p><p>常见的完全积性函数：$I$，$\epsilon$，$id$，$etc.$</p><p>其中 $\mu$ 为莫比乌斯函数，其定义如下：</p><script type="math/tex; mode=display">\mu(n)=\left\{\begin{array}{rcl}1       &      & {n=1}\\(-1)^k     &      & {n=\prod_{i=1}^{k}p_i\ \ \ \forall p_i\not= p_j}\\0     &      & {otherwise.}\end{array} \right.</script><p>当一个数拥有 $2$ 个及以上的质因子的时候，它的莫比乌斯函数的值就是 $0$，不然就和质因子个数有关。</p><p>关于其他函数的解释：$I(x)=1$，$\epsilon(x)=[x=1]$，$id(x)=x$，其中 $\epsilon$ 被称为莫比乌斯反演的“单位元”。</p><hr><h2 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h2><p>这个算是前置芝士了，狄利克雷卷积的符号为 $ * $ ，$(f * g)$ 代表 $f$ 和 $g$ 的卷积，公式是这样的：</p><script type="math/tex; mode=display">(f * g)(d)=\sum_{d|n}{f(d)g(\frac{n}{d})}</script><p>这个应该很好背，经常要用上，它满足交换律、结合律、逐点加的分配律，是一个相当重要的式子。</p><hr><h2 id="莫比乌斯反演-1"><a href="#莫比乌斯反演-1" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>先给出一些结论：</p><ol><li><p>$\mu * I=\epsilon$</p><p>证明：</p><script type="math/tex; mode=display">\mu * I=\sum_{d|n}\mu(d)I(\frac{n}{d})=\sum_{d|n}\mu(d)=[n=1]=\epsilon</script></li><li><p>$φ * I=id(n)$</p><p>证明：</p><script type="math/tex; mode=display">φ * I=\sum_{d|n}φ(d)I(\frac{n}{d})=\sum_{d|n}φ(d)=n=id(n)</script></li><li><p>$id * \mu=φ$</p><p>证明：</p><script type="math/tex; mode=display">id * \mu=φ \rightarrow φ * I * \mu=id * \mu \rightarrow φ * \epsilon=id * \mu \rightarrow φ=id * \mu</script></li></ol><p>然后莫比乌斯反演就只有一个式子，如下：</p><p>若：</p><script type="math/tex; mode=display">f(n)=\sum_{d|n}g(d)</script><p>则有：</p><script type="math/tex; mode=display">g(n)=\sum_{d|n}f(\frac{n}{d})\mu(d)</script><p>就没了（</p><p>所以说莫比乌斯反演大多数都是用来推的，真正算还是要用其他的方法辅助。</p><p>证明：</p><script type="math/tex; mode=display">f * \mu=g * I * \mu=g * \epsilon=g</script><hr><h1 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h1><p>杜教筛是用来求积性函数前缀和，即：</p><script type="math/tex; mode=display">S(n)=\sum_{i=1}^{n}f(i)</script><p>这个函数的值的，那么怎么求呢？</p><p>我们再找一个积性函数 $g$，考虑 $(f * g)$ 的前缀和：</p><script type="math/tex; mode=display">\sum_{i=1}^{n}(f * g)(i)=\sum_{i=1}^{n}\sum_{d|i}f(d)g(\frac{i}{d})=\sum_{d=1}^{n}g(d)\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor }f(i)=\sum_{d=1}^{n}g(d)S(\lfloor \frac{n}{d}\rfloor)</script><p>接下来要怎么求呢？考虑 $g(1)S(n)$，利用容斥可以求出：</p><script type="math/tex; mode=display">g(1)S(n)=\sum_{i=1}^{n}g(i)S(\lfloor \frac{n}{i}\rfloor)-\sum_{i=2}^{n}g(i)S(\lfloor \frac{n}{i}\rfloor)</script><p>将之前求出的代入，可得：</p><script type="math/tex; mode=display">=\sum_{i=1}^{n}(f * g)(i)-\sum_{i=2}^{n}g(i)S(\lfloor \frac{n}{i}\rfloor)</script><p>这个就是杜教筛的核心式了，我们可以通过找到一个合适的 $g$，使得 $f * g$ 和 $g$ 的前缀和好求，然后利用数论分块递归求解就可以了。裸杜教筛的时间复杂度是 $\text{O}(n^{\frac{3}{4}})$，预处理一下可以优化到 $\text{O}(n^{\frac{2}{3}})$。</p><p>至于怎么选择 $g$，以模板题为例，求 $\mu$ 和 $φ$ 的前缀和，因为之前有说过，$\mu * I=\epsilon$，$I$ 和 $\epsilon$ 的前缀和自然都很弱智，一个是 $n$，另一个是 $1$。</p><p>至于 $φ$ 的前缀和，之前也有说，$φ * I=id$，$I$ 和 $id$ 的前缀和自然也很好求，一个是 $n$，一个是 $\frac{n(n+1)}{2}$。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>杜教筛的限制好像还挺大的……虽然也挺好写，$\text{min}$_$\text{25}$ 筛这种神仙算法还是到时候再说吧（</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 模拟赛 2-12</title>
      <link href="/2019/02/12/solution_2019_2_12/"/>
      <url>/2019/02/12/solution_2019_2_12/</url>
      
        <content type="html"><![CDATA[<p>得分 $100+100+0=200$，我还是太菜了。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=506196018&auto=0&height=66"></iframe><a id="more"></a><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>将数划分成两个集合 $A$ 和 $B$，对每个数枚举放到 $A$ 还是 $B$，加一点剪枝即可。</p><p>时间复杂度 $\text{O}(玄学)$，估计得分 $100$，实际得分 $100$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1010580540</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[MAXN],b[MAXN];</span><br><span class="line"><span class="keyword">bool</span> fg;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fg || sum&gt;n/<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(sum==n/<span class="number">2</span> &amp;&amp; s==n)</span><br><span class="line">&#123;</span><br><span class="line">fg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">b[sum]=a[s];</span><br><span class="line">Dfs(s+<span class="number">1</span>,sum+<span class="number">1</span>);</span><br><span class="line">b[s]=inf;</span><br><span class="line"><span class="keyword">if</span>(s-sum+<span class="number">1</span>&lt;=sum &amp;&amp; a[s]==b[s-sum]) Dfs(s+<span class="number">1</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"split.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"split.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> Time;</span><br><span class="line">Read(Time);</span><br><span class="line"><span class="keyword">while</span>(Time--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">60</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">Read(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) Read(a[i]);</span><br><span class="line">fg=<span class="number">0</span>;</span><br><span class="line">Dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">puts</span>(fg?<span class="string">"Good job!!"</span>:<span class="string">"What a pity!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>设长度为 $n$ 非 $010$ 串的个数为 $f[n]$，这些非 $010$ 串中以 $01$ 结尾的串个数为 $a[n]$（因为在结尾加 $0$ 时，它们会变成 $010$），以 $0$ 结尾的串个数为 $b[n]$（因为它们在结尾加 $1$ 后会变成 $01$），可以得到递推式：</p><p>$f[n]=f[n-1]\times 2-a[n-1]$</p><p>$a[n]=b[n-1]$</p><p>$b[n]=f[n-1]-a[n-1]$</p><p>很明显可以套矩阵快速幂，如下：</p><script type="math/tex; mode=display"> \left[ \begin{matrix}   f_{i-1} & a_{i-1} & b_{i-1}   \end{matrix}  \right]\times \left[ \begin{matrix}   2 & 0 & 1 \\   -1 & 0 & -1 \\   0 & 1 & 0  \end{matrix}  \right]  = \left[ \begin{matrix}   f_{i} & a_{i} & b_{i}   \end{matrix}  \right]</script><p>记得处理一下负数即可。</p><p>时间复杂度 $\text{O}(logn)$，估计得分 $100$，实际得分 $100$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> ll Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll n,f[MAXN],b[MAXN],cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ll a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;x,<span class="keyword">const</span> Matrix &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">Matrix cnt;</span><br><span class="line">cnt.Reset();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">2</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line">cnt.a[i][j]=(cnt.a[i][j]%Mod+(x.a[i][k]%Mod)*(y.a[k][j]%Mod)%Mod+Mod)%Mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T,ans;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickPow</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x&amp;<span class="number">1</span>) ans=T*ans;</span><br><span class="line">T=T*T;</span><br><span class="line">x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"string.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"string.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">Read(n);</span><br><span class="line"><span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>),<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"2"</span>),<span class="number">0</span>;</span><br><span class="line">n--;</span><br><span class="line">T.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">T.a[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">-1</span>;</span><br><span class="line">T.a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">T.a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">-1</span>;</span><br><span class="line">T.a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">ans.a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">ans.a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">ans.a[<span class="number">2</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">QuickPow(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans.a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>容易想到对每一位分别考虑，我们可以从高位向低位枚举，将数分成当前位为 $0$ 和当前位为 $1$ 的两个集合，因为高位不同的异或和肯定更大，然后就可以找一条权最小的边将两个集合连起来，这个可以用 $\text{Trie}$ 维护，这样可以得到最小的权值。</p><p>至于方案数，有一个定理是一个点数为 $n$ 完全图的生成树有 $n^{n-2}$ 个，可以利用这个定理来算。</p><p>时间复杂度 $\text{O}(能过)$，估计得分 $100$，实际得分 $100$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[MAXN],b[MAXN],son[MAXN&lt;&lt;<span class="number">5</span>][<span class="number">2</span>],num[MAXN&lt;&lt;<span class="number">5</span>];</span><br><span class="line">ll ans,Ans;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x<span class="number">-2</span>;i++) res=res*x%Mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Calc</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> mid,<span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=S;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&amp;(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!son[now][<span class="number">1</span>]) son[now][<span class="number">1</span>]=++cnt;</span><br><span class="line">now=son[now][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!son[now][<span class="number">0</span>]) son[now][<span class="number">0</span>]=++cnt;</span><br><span class="line">now=son[now][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">num[now]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">2e9</span>;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">1</span>,val=<span class="number">1</span>&lt;&lt;S;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=S;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&amp;(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(son[now][<span class="number">1</span>]) now=son[now][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">now=son[now][<span class="number">0</span>];</span><br><span class="line">val+=<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(son[now][<span class="number">0</span>]) now=son[now][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">now=son[now][<span class="number">1</span>];</span><br><span class="line">val+=<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(val==res) sum+=num[now];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(val&lt;res)</span><br><span class="line">&#123;</span><br><span class="line">res=val;</span><br><span class="line">sum=num[now];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) son[i][<span class="number">0</span>]=son[i][<span class="number">1</span>]=num[i]=<span class="number">0</span>;</span><br><span class="line">ans+=res;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S&lt;<span class="number">0</span>) <span class="keyword">return</span> Get(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> x=l<span class="number">-1</span>,y=r+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&amp;(<span class="number">1</span>&lt;&lt;S)) b[++x]=a[i];</span><br><span class="line"><span class="keyword">else</span> b[--y]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x==r || y==l) Dfs(l,r,S<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) a[i]=b[i];</span><br><span class="line">ll res=Calc(l,r,x,S);</span><br><span class="line">res=res*Dfs(l,x,S<span class="number">-1</span>)%Mod;</span><br><span class="line">res=res*Dfs(y,r,S<span class="number">-1</span>)%Mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Read(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Read(a[i]);</span><br><span class="line">Ans=Dfs(<span class="number">1</span>,n,<span class="number">30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n%lld\n"</span>,ans,Ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 比赛 </tag>
            
            <tag> Dfs </tag>
            
            <tag> 矩阵快速幂 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 模拟赛 2-11</title>
      <link href="/2019/02/11/solution_2019_2_11/"/>
      <url>/2019/02/11/solution_2019_2_11/</url>
      
        <content type="html"><![CDATA[<p>得分 $100+10+20=130$，我还是太菜了。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1344874921&auto=0&height=66"></iframe><a id="more"></a><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>枚举块的大小 $x$，因为只有 $siz$ 是 $x$ 的倍数的结点才能将它和根分开，所以找这样的结点是否有 $n/x$ 个即可。</p><p>时间复杂度 $\text{O}(n\sqrt{n})$【貌似，估计得分 $100$，实际得分 $100$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,siz[MAXN],f[MAXN],ans;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> faz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz) <span class="keyword">continue</span>;</span><br><span class="line">Dfs(v,u);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line">&#125;</span><br><span class="line">f[siz[u]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Calc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=x) sum+=f[i];</span><br><span class="line"><span class="keyword">return</span> sum==n/x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"block.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"block.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">Read(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">AddEdge(x,y);</span><br><span class="line">AddEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">Dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!(n%i))</span><br><span class="line">&#123;</span><br><span class="line">ans+=Calc(i);</span><br><span class="line"><span class="keyword">if</span>(i*i!=n) ans+=Calc(n/i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>显然，只有每个位置的球都经过不同的漏斗，掉到同一个漏斗上才能保证最终在同一个位置，用 $L[i]$ 表示球从 $1$ 位置落下，从第 $i$ 个漏斗落出的最小花费，用 $R[i]$ 表示球从 $n$ 位置落下，从第 $i$ 个漏斗落出的最小花费，答案为 $\min (L[i]+R[i]-d[i])$，转移时要求区间 $\text{rmq}$，可以用线段树优化。</p><p>时间复杂度 $\text{O}(能过)$，估计得分 $100$，实际得分 $100$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line">ll ans=<span class="number">1e16</span>,t[MAXN&lt;&lt;<span class="number">4</span>],a[MAXN],b[MAXN],c[MAXN],d[MAXN],l[MAXN],r[MAXN],dat[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt]=<span class="number">1e16</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">t[rt]=min(t[rt&lt;&lt;<span class="number">1</span>],t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt]=min(t[rt],val);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid) Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,pos,val);</span><br><span class="line"><span class="keyword">else</span> Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">t[rt]=min(t[rt&lt;&lt;<span class="number">1</span>],t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll res=<span class="number">1e16</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res=min(res,Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res=min(res,Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Read(a[i]);</span><br><span class="line">Read(b[i]);</span><br><span class="line">Read(c[i]);</span><br><span class="line">Read(d[i]);</span><br><span class="line">dat[++cnt]=a[i];</span><br><span class="line">dat[++cnt]=b[i];</span><br><span class="line">dat[++cnt]=c[i];</span><br><span class="line">&#125;</span><br><span class="line">dat[++cnt]=<span class="number">1</span>;</span><br><span class="line">dat[++cnt]=m;</span><br><span class="line">sort(dat+<span class="number">1</span>,dat+cnt+<span class="number">1</span>);</span><br><span class="line">cnt=unique(dat+<span class="number">1</span>,dat+cnt+<span class="number">1</span>)-dat<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=lower_bound(dat+<span class="number">1</span>,dat+cnt+<span class="number">1</span>,a[i])-dat;</span><br><span class="line">b[i]=lower_bound(dat+<span class="number">1</span>,dat+cnt+<span class="number">1</span>,b[i])-dat;</span><br><span class="line">c[i]=lower_bound(dat+<span class="number">1</span>,dat+cnt+<span class="number">1</span>,c[i])-dat;</span><br><span class="line">&#125;</span><br><span class="line">BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,cnt,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">l[i]=Query(<span class="number">1</span>,<span class="number">1</span>,cnt,a[i],b[i])+d[i];</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,cnt,c[i],l[i]);</span><br><span class="line">&#125;</span><br><span class="line">BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,cnt,cnt,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">r[i]=Query(<span class="number">1</span>,<span class="number">1</span>,cnt,a[i],b[i])+d[i];</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,cnt,c[i],r[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=min(ans,l[i]+r[i]-d[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans==<span class="number">1e16</span>?<span class="number">-1</span>:ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>预处理每个点到它最近的加油站的距离，枚举每条边，如果这条边两端的点指向的最近的加油站不同，则新建一条边连通这两个加油站，长度为 $dis[u]+dis[v]+w[i]$，然后对得到的图跑最小生成树，对询问离线排序，用倍增求出给出的两个点在树上的链中的最长边，判断是否可行即可。因为得到的图每个点都是加油站，所以只要管最长边就行。</p><p>代码还没写，贴一个感觉好理解的吧。</p><p><a href="https://blog.csdn.net/pbihao/article/details/54882546" target="_blank" rel="noopener">来自这里</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200021</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;pii;</span><br><span class="line"><span class="keyword">int</span> n,m,s,C[maxn],ans[maxn],Q,head[maxn],cnt;</span><br><span class="line"><span class="keyword">int</span> dis[maxn],tot=<span class="number">1</span>,f[maxn],vis[maxn],near[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,d,id;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> que&amp; b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> d&lt;b.d;&#125;</span><br><span class="line">&#125;qu[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> data&amp; y)<span class="keyword">const</span>&#123;<span class="keyword">return</span> c&lt;y.c;&#125;</span><br><span class="line">&#125;nod[maxn*<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> v,next,w;&#125;e[maxn*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;e[tot].v=b,e[tot].next=head[a],e[tot].w=c;head[a]=tot++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> f[x]==x ? x : f[x]=find(f[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,greater&lt;pii&gt; &gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dis[i]=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++)&#123;</span><br><span class="line">dis[C[i]]=<span class="number">0</span>;near[C[i]]=C[i];q.push(make_pair(<span class="number">0</span>,C[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.top().second;q.pop();</span><br><span class="line"><span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v,i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v=e[i].v]&gt;dis[u]+e[i].w)&#123;</span><br><span class="line">dis[v]=dis[u]+e[i].w;near[v]=near[u];</span><br><span class="line">q.push(make_pair(dis[v],v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v,j=head[i];j;j=e[j].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(near[i]!=near[v=e[j].v])&#123;</span><br><span class="line">nod[++cnt]=(data)&#123;near[i],near[v],dis[i]+dis[v]+e[j].w&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;sort(nod+<span class="number">1</span>,nod+<span class="number">1</span>+cnt);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)f[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(now&lt;=cnt&amp;&amp;nod[now].c&lt;=qu[i].d)&#123;</span><br><span class="line"><span class="keyword">int</span> dx=find(nod[now].a),dy=find(nod[now].b);</span><br><span class="line"><span class="keyword">if</span>(dx!=dy)f[dx]=dy;</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dx=find(qu[i].x),dy=find(qu[i].y);</span><br><span class="line"><span class="keyword">if</span>(dx==dy)ans[qu[i].id]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ans[qu[i].id]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)<span class="keyword">if</span>(ans[i])<span class="built_in">puts</span>(<span class="string">"TAK"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NIE"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;s,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,C+i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a,b,c,i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">adde(a,b,c);adde(b,a,c);</span><br><span class="line">&#125;dijkstra();</span><br><span class="line">build();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;qu[i].x,&amp;qu[i].y,&amp;qu[i].d),qu[i].id=i;</span><br><span class="line">sort(qu+<span class="number">1</span>,qu+<span class="number">1</span>+Q);</span><br><span class="line">solve();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 比赛 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> DP </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 模拟赛 Round 3 1-29</title>
      <link href="/2019/01/29/solution_2019_1_29/"/>
      <url>/2019/01/29/solution_2019_1_29/</url>
      
        <content type="html"><![CDATA[<p>得分 $100+30+15=145$。我还是太菜了。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=411356060&auto=0&height=66"></iframe><a id="more"></a><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>将 $n\times x+m\times y=c$ 看作走 $x$ 步 $n$，$y$ 步 $m$ 能达到的所有高度，用 $f[i]$ 表示一直走 $m$ 在 $\% n$ 意义下能到达的最小高度，然后就能算出每个 $i$ 还能走多少次 $n$。这样算出来的是好的数，减一下就是不好的数了。</p><p>时间复杂度 $\text{O}(能过)$，估计得分 $100$，实际得分 $100$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll n,m,q,f[MAXN];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"simple.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"simple.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> Time;</span><br><span class="line">Read(Time);</span><br><span class="line"><span class="keyword">while</span>(Time--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line">Read(q);</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">register</span> ll pre=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!~f[(pre+m)%n])</span><br><span class="line">&#123;</span><br><span class="line">f[(pre+m)%n]=f[pre]+m;</span><br><span class="line">pre=(pre+m)%n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(~f[i] &amp;&amp; f[i]&lt;=q) ans+=(q-f[i])/n+<span class="number">1</span>;</span><br><span class="line">ans=q-ans+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>枚举因数 $g$，将所有权值是 $g$ 的<strong>倍数</strong>的边加入树中，用树形 $\text{DP}$ 找到最长链即是这个 $g$ 的答案。</p><p>时间复杂度 $\text{O}(能过)$，估计得分 $100$，实际得分 $100$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 800005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ecnt,efst[MAXN],enxt[MAXN],eto[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,maxlen,dfn[MAXN],fr[MAXN],uu[MAXN&lt;&lt;<span class="number">1</span>],ans[MAXN],Index;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> u,<span class="keyword">register</span> <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">uu[cnt]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">EAddEdge</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> u,<span class="keyword">register</span> <span class="keyword">int</span> v,<span class="keyword">register</span> <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">eto[++ecnt]=v;</span><br><span class="line">enxt[ecnt]=efst[c];</span><br><span class="line">efst[c]=ecnt;</span><br><span class="line">fr[ecnt]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u]=Index;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> son=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dfn[v]==Index) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> d=Dfs(v);</span><br><span class="line">maxlen=max(maxlen,son+d+<span class="number">1</span>);</span><br><span class="line">son=max(son,d+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> son;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"walk.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"walk.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">Read(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> x,y,z;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">Read(z);</span><br><span class="line">EAddEdge(x,y,z);</span><br><span class="line">maxn=max(maxn,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=maxn;len++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=len;i&lt;=maxn;i+=len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=efst[i];j;j=enxt[j])</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(fr[j],eto[j]);</span><br><span class="line">AddEdge(eto[j],fr[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Index++;</span><br><span class="line">maxlen=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(dfn[uu[i]]!=Index) Dfs(uu[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) fst[uu[i]]=<span class="number">0</span>;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">ans[maxlen]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) ans[i]=max(ans[i],ans[i+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>不会。输出 $-1$ 获得 $15 pts$。</p><p>到时候填坑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 比赛 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> DP </tag>
            
            <tag> 树形DP </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 模拟赛 Round 2 1-28</title>
      <link href="/2019/01/28/solution_2019_1_28/"/>
      <url>/2019/01/28/solution_2019_1_28/</url>
      
        <content type="html"><![CDATA[<p>得分 $60+40+20=120$。因为把 $x$ 写成 $n$，以及数组开小丢了 $100$ 分，血的教训。</p><p>最后得分 $100+100+20=220$。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=33984104&auto=0&height=66"></iframe><a id="more"></a><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>大力分解因数，用每个因数分别对每个数取模，记录答案。</p><p>时间复杂度 $\text{O}(m\sqrt{n}+fac\times m)$，估计得分 $100$，实际得分 $100$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 205</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,a[MAXM],ans[MAXM],fac[MAXN],tot;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Div</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=x;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x%i) <span class="keyword">continue</span>;</span><br><span class="line">fac[++tot]=i;</span><br><span class="line"><span class="keyword">if</span>(x/i!=i) fac[++tot]=x/i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Calc</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(!(a[i]%x)) res++;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"div.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"div.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line">ans[<span class="number">0</span>]=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">Read(a[i]);</span><br><span class="line">Div(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(fac+<span class="number">1</span>,fac+tot+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fac[i]&gt;n) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fac[i]==fac[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> ans[Calc(fac[i])]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) ans[<span class="number">0</span>]-=ans[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>用 $f[i]$ 表示价值为 $i$ 时最小的容量，离线处理询问，将询问按时间排序，每次将一段物品加入 $\text{DP}$，二分价值，如果 $f[mid]\leq M$ 就是可行的。</p><p>在 $\text{DP}$ 时应取最小值。</p><p>时间复杂度 $\text{O(能过)}$，估计得分 $100$，实际得分 $100$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 305</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> c,v,t;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x,<span class="keyword">const</span> Node &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.t&lt;y.t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> T,M,id;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp;x,<span class="keyword">const</span> Query &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.T&lt;y.T;</span><br><span class="line">&#125;</span><br><span class="line">&#125;q[MAXM];</span><br><span class="line"><span class="keyword">int</span> n,m,N,f[MAXN*MAXN],T,M,ans[MAXM];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=N;i&gt;=a[x].v;i--) f[i]=min(f[i],f[i-a[x].v]+a[x].c);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>;i;i--) f[i]=min(f[i],f[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=N,res;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(f[mid]&lt;=M)</span><br><span class="line">&#123;</span><br><span class="line">res=mid;</span><br><span class="line">l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"market.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"market.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">60</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line">N=n*<span class="number">300</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Read(a[i].c);</span><br><span class="line">Read(a[i].v);</span><br><span class="line">Read(a[i].t);</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">Read(q[i].T);</span><br><span class="line">Read(q[i].M);</span><br><span class="line">q[i].id=i;</span><br><span class="line">&#125;</span><br><span class="line">sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n &amp;&amp; a[x].t&lt;=q[i].T) Modify(x++);</span><br><span class="line">ans[q[i].id]=Solve(q[i].M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>只会暴力。</p><p>正解似乎是树剖，也可能是分治。到时候填坑。</p><p>时间复杂度 $\text{O}(n^3\times m)$，估计得分 $20$，实际得分 $20$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 70005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>],L[MAXN&lt;&lt;<span class="number">1</span>],R[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,minx,maxn,len;</span><br><span class="line"><span class="keyword">bool</span> fg;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> u,<span class="keyword">register</span> <span class="keyword">int</span> v,<span class="keyword">register</span> <span class="keyword">int</span> l,<span class="keyword">register</span> <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">L[cnt]=l;</span><br><span class="line">R[cnt]=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">register</span> <span class="keyword">int</span> u,<span class="keyword">register</span> <span class="keyword">int</span> pre,<span class="keyword">register</span> <span class="keyword">int</span> l,<span class="keyword">register</span> <span class="keyword">int</span> r,<span class="keyword">register</span> <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fg) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(u==T)</span><br><span class="line">&#123;</span><br><span class="line">minx=l;</span><br><span class="line">maxn=r;</span><br><span class="line">len=sum;</span><br><span class="line">fg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==pre) <span class="keyword">continue</span>;</span><br><span class="line">Dfs(v,u,max(l,L[i]),min(r,R[i]),sum+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"speed.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"speed.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> x,y,l,r;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">Read(l);</span><br><span class="line">Read(r);</span><br><span class="line">AddEdge(x,y,l,r);</span><br><span class="line">AddEdge(y,x,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> x,res=<span class="number">0</span>;</span><br><span class="line">Read(x);</span><br><span class="line"><span class="keyword">for</span>(S=<span class="number">1</span>;S&lt;=n;S++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(T=S+<span class="number">1</span>;T&lt;=n;T++)</span><br><span class="line">&#123;</span><br><span class="line">minx=<span class="number">2e9</span>;</span><br><span class="line">maxn=<span class="number">0</span>;</span><br><span class="line">len=<span class="number">0</span>;</span><br><span class="line">fg=<span class="number">0</span>;</span><br><span class="line">Dfs(S,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2e9</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(minx&lt;=x &amp;&amp; x&lt;=maxn) res=max(res,len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正解：将时间逆序考虑，对每个到达的 $R$ 执行加边操作，对每个到达的 $L$ 执行删边操作，可以看出每次询问就是询问的直径的长度，所以我们要考虑两个东西，一个是如何加边删边，另一个是合并后的直径如何转移。</p><p>加边删边的第一反应是 $\text{LCT}$，但是显然不能在这题用，我们考虑使用不带路径压缩的并查集即可。</p><p>另一个直径转移，我们假设两棵树的直径分别为 $s1-t1$，$s2-t2$，连的边为 $u-v$，那么合并后的直径一定是 $s1-t1$，$s2-t2$，$s1-u-v-s2$，$s1-u-v-t2$，$t1-u-v-s2$，$t1-u-v-t2$ 这 $6$ 条中最长的那条，分别计算转移即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 70005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>],L[MAXN&lt;&lt;<span class="number">1</span>],R[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,res,fr[MAXN],tx[MAXN],ans[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">L[cnt]=l;</span><br><span class="line">R[cnt]=r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrainSplit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> dfn[MAXN],Index,top[MAXN],faz[MAXN],dep[MAXN],son[MAXN],siz[MAXN],rk[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">Dfs1(v);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u]=++Index;</span><br><span class="line">rk[Index]=u;</span><br><span class="line">top[u]=rt;</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dep[u]&lt;dep[v]?u:v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dist</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lca=LCA(u,v);</span><br><span class="line"><span class="keyword">return</span> dep[u]+dep[v]-dep[lca]*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,s,t,siz;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFindSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> f[MAXN],s[MAXN],t[MAXN],siz[MAXN],top;</span><br><span class="line">Node stk[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">f[i]=s[i]=t[i]=i;</span><br><span class="line">siz[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x==f[x]?x:Find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u=Find(u);</span><br><span class="line">v=Find(v);</span><br><span class="line"><span class="keyword">if</span>(u==v) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> a,b,s1,s2,t1,t2;</span><br><span class="line"><span class="keyword">if</span>(siz[u]&lt;siz[v]) swap(u,v);</span><br><span class="line">stk[++top]=((Node)&#123;u,v,s[u],t[u],siz[u]&#125;);</span><br><span class="line">f[v]=u;</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line">s1=s[u];</span><br><span class="line">s2=s[v];</span><br><span class="line">t1=t[u];</span><br><span class="line">t2=t[v];</span><br><span class="line"><span class="keyword">if</span>(T.Dist(s[u],t[u])&lt;T.Dist(s[v],t[v]))</span><br><span class="line">&#123;</span><br><span class="line">s[u]=s[v];</span><br><span class="line">t[u]=t[v];</span><br><span class="line">&#125;</span><br><span class="line">a=T.Dist(s[u],t[u]);</span><br><span class="line">b=T.Dist(s1,s2);</span><br><span class="line"><span class="keyword">if</span>(b&gt;a)</span><br><span class="line">&#123;</span><br><span class="line">s[u]=s1;</span><br><span class="line">t[u]=s2;</span><br><span class="line">a=b;</span><br><span class="line">&#125;</span><br><span class="line">b=T.Dist(s1,t2);</span><br><span class="line"><span class="keyword">if</span>(b&gt;a)</span><br><span class="line">&#123;</span><br><span class="line">s[u]=s1;</span><br><span class="line">t[u]=t2;</span><br><span class="line">a=b;</span><br><span class="line">&#125;</span><br><span class="line">b=T.Dist(t1,s2);</span><br><span class="line"><span class="keyword">if</span>(b&gt;a)</span><br><span class="line">&#123;</span><br><span class="line">s[u]=t1;</span><br><span class="line">t[u]=s2;</span><br><span class="line">a=b;</span><br><span class="line">&#125;</span><br><span class="line">b=T.Dist(t1,t2);</span><br><span class="line"><span class="keyword">if</span>(b&gt;a)</span><br><span class="line">&#123;</span><br><span class="line">s[u]=t1;</span><br><span class="line">t[u]=t2;</span><br><span class="line">a=b;</span><br><span class="line">&#125;</span><br><span class="line">res=max(res,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;x)</span><br><span class="line">&#123;</span><br><span class="line">Node now=stk[top--];</span><br><span class="line"><span class="keyword">int</span> u=now.u,v=now.v;</span><br><span class="line">f[v]=v;</span><br><span class="line">siz[u]=now.siz;</span><br><span class="line">s[u]=now.s;</span><br><span class="line">t[u]=now.t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;F;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; g[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr)</span><br><span class="line">&#123;</span><br><span class="line">g[rt].push_back(val);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr,val);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=res,top=F.top,mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[rt].size();i++) F.Merge(fr[g[rt][i]],tx[g[rt][i]]);</span><br><span class="line"><span class="keyword">if</span>(l==r) ans[l]=res;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Query(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">F.Reset(top);</span><br><span class="line">res=now;</span><br><span class="line">&#125;</span><br><span class="line">&#125;ST;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"speed.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"speed.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;x,&amp;y,&amp;l,&amp;r);</span><br><span class="line">AddEdge(x,y,l,r);</span><br><span class="line">AddEdge(y,x,l,r);</span><br><span class="line">fr[i]=x;</span><br><span class="line">tx[i]=y;</span><br><span class="line">ST.Modify(<span class="number">1</span>,<span class="number">1</span>,n,l,r,i);</span><br><span class="line">&#125;</span><br><span class="line">F.Init();</span><br><span class="line">T.Dfs1(<span class="number">1</span>);</span><br><span class="line">T.Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">ST.Query(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 比赛 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> DP </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 模拟赛 Round 1 1-27</title>
      <link href="/2019/01/27/solution_2019_1_27/"/>
      <url>/2019/01/27/solution_2019_1_27/</url>
      
        <content type="html"><![CDATA[<p>得分 $100+100+40=240$，我还是太菜了。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=425298759&auto=0&height=66"></iframe><a id="more"></a><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>暴力硬干，枚举两个串的起点，计算使用 $k$ 次变换后最长能到哪里，记录答案。</p><p>时间复杂度 $\text{O}(n^3)$，估计得分 $100$，实际得分 $100$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 305</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,ans;</span><br><span class="line"><span class="keyword">char</span> s1[MAXN],s2[MAXN];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"master.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"master.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">Read(n);</span><br><span class="line">Read(k);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s1+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s2+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x=i,y=j,num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n &amp;&amp; y&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s1[x]!=s2[y])</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">if</span>(num&gt;k) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">x--;</span><br><span class="line">ans=max(ans,x-i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>$\text{bitset}$。枚举两个点 $i, j$，作为四个点中间的两个点，计算此时的答案，即 $(deg[i]-1)\times (deg[j]-1)$，但因为有可能选到同一个点，形成环，所以用 $\text{bitset}$ 维护连边情况，删去重复的答案即可。</p><p>时间复杂度 $\text{O}(n^2\times bitset)$，估计得分 $100$，实际得分 $100$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1505</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">bitset</span> &lt;MAXN&gt; s[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,deg[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">char</span> ch[MAXN];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"tour.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"tour.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">Read(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ch[j]==<span class="string">'1'</span>)</span><br><span class="line">&#123;</span><br><span class="line">s[i][j]=<span class="number">1</span>;</span><br><span class="line">deg[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j || !s[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">ans+=<span class="number">1l</span>l*(deg[i]<span class="number">-1</span>)*(deg[j]<span class="number">-1</span>);</span><br><span class="line">ans-=(s[i]&amp;s[j]).count();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>正解还暂时看不懂，到时候来填坑。</p><p>考场上使用了 $n^2$ 暴力建边，跑 $\text{Dijkstra}$ 的做法。</p><p>时间复杂度 $\text{O}(n^2+(n+m)logn)$，估计得分 $40$，实际得分 $40$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1010580540</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getchar() (p1==p2 &amp;&amp; (p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">21</span>],*p1=buf,*p2=buf;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,dis;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.dis&lt;dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;Node&gt; q;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXM],to[MAXM];</span><br><span class="line"><span class="keyword">int</span> n,m,a[MAXN],dis[MAXN];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">60</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">q.push((Node)&#123;x,<span class="number">0</span>&#125;);</span><br><span class="line">dis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">Node now=q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">int</span> u=now.u,d=now.dis;</span><br><span class="line"><span class="keyword">if</span>(d!=dis[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[u]+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">q.push((Node)&#123;v,dis[v]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"walk.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"walk.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Read(a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">AddEdge(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((a[i]&amp;a[j])==a[j]) AddEdge(i,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[i]==inf?<span class="number">-1</span>:dis[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正解：</p><p>我们可以额外建一张图，结点编号为给出的 $val_i$，然后每个点向它的子集连边，边权为 $0$，然后原图中的每个点向它对应的 $val_i$ 连边，边权为 $1$，同时连反向边，边权为 $0$，最后计算出距离即可。</p><p>我们可以一边 $\text{Dfs}$，一边计算子集，因为最多只有 $20$ 位，所以并不慢。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1300005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 700005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> base=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN][<span class="number">2</span>],nxt[MAXM],to[MAXM],w[MAXM];</span><br><span class="line"><span class="keyword">int</span> n,m,dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u][id];</span><br><span class="line">fst[u][id]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(~dis[u]) <span class="keyword">return</span>;</span><br><span class="line">q.push(u);</span><br><span class="line">dis[u]=d;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u][<span class="number">0</span>];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line">Dfs(v,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u&gt;=<span class="number">1</span>&lt;&lt;<span class="number">20</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) <span class="keyword">if</span>(u&gt;&gt;i&amp;<span class="number">1</span>) Dfs(u^(<span class="number">1</span>&lt;&lt;i),d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen(<span class="string">"walk.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"walk.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">Read(n);</span><br><span class="line">Read(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">AddEdge(x,i+base,<span class="number">0</span>);</span><br><span class="line">AddEdge(i+base,x,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">AddEdge(x+base,y+base,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">Dfs(base+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u][<span class="number">1</span>];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line">Dfs(v,dis[u]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[i+base]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 比赛 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> bitset </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P2526 [SHOI2001]小狗散步</title>
      <link href="/2019/01/27/solution_p2526/"/>
      <url>/2019/01/27/solution_p2526/</url>
      
        <content type="html"><![CDATA[<p>网络流。</p><p>Grant喜欢带着他的小狗Pandog散步。Grant以一定的速度沿着固定路线走，该路线可能自交。Pandog喜欢游览沿途的景点，不过会在给定的N个点和主人相遇。小狗和主人同时从(X1，Y1)点出发，并同时在(Xn，Yn)点汇合。小狗的速度最快是Grant的两倍。当主人从一个点以直线走向另一个点时，Pandog跑向一个它感兴趣的景点。Pandog每次与主人相遇之前最多只去一个景点。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=456359605&auto=0&height=66"></iframe><a id="more"></a><p>将集合点作为左点，景点作为右点，可以创建出一个二分图，而我们要求的就是它的最大匹配。那么边怎么连呢？我们枚举每个景点 $i$ 和每个集合点 $j$，如果主人从这个集合点 $j$ 到下一个集合点 $j+1$ 需要的时间，比小狗从这个集合点 $j$ 到景点 $i$ 再到下一个集合点 $j+1$ 的时间要长的话，我们就可以在集合点 $j$ 到景点 $i$ 中间连一条边，因为小狗的速度是主人的两倍，所以我们将主人的时间 $\times 2$，或者将小狗的时间 $÷2$，再作比较即可。</p><p>数组记得开大点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;a[MAXN],b[MAXN];</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>,fst[MAXN],nxt[MAXM&lt;&lt;<span class="number">1</span>],to[MAXM&lt;&lt;<span class="number">1</span>],w[MAXN&lt;&lt;<span class="number">1</span>],cur[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,dep[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">q.push(S);</span><br><span class="line">dep[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(!dep[v] &amp;&amp; w[i])</span><br><span class="line">&#123;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dep[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u==T || !flow) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> used=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span> &amp;&amp; w[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fl=Dfs(v,min(flow,w[i]));</span><br><span class="line"><span class="keyword">if</span>(fl)</span><br><span class="line">&#123;</span><br><span class="line">used+=fl;</span><br><span class="line">flow-=fl;</span><br><span class="line">w[i]-=fl;</span><br><span class="line">w[i^<span class="number">1</span>]+=fl;</span><br><span class="line"><span class="keyword">if</span>(!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(Bfs())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(cur,fst,<span class="keyword">sizeof</span>(fst));</span><br><span class="line">sum+=Dfs(S,<span class="number">2e9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Calc</span><span class="params">(Node x,Node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="keyword">double</span>)(x.x-y.x)*(x.x-y.x)+(<span class="keyword">double</span>)(x.y-y.y)*(x.y-y.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">S=<span class="number">0</span>;</span><br><span class="line">T=n+m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;b[i].x,&amp;b[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Calc(a[i],a[i<span class="number">-1</span>])&gt;(Calc(a[i<span class="number">-1</span>],b[j])+Calc(b[j],a[i]))/<span class="number">2.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i,j+n,<span class="number">1</span>);</span><br><span class="line">AddEdge(j+n,i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(S,i,<span class="number">1</span>);</span><br><span class="line">AddEdge(i,S,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i+n,T,<span class="number">1</span>);</span><br><span class="line">AddEdge(T,i+n,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=Dinic()+n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d %d "</span>,res,a[<span class="number">1</span>].x,a[<span class="number">1</span>].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=fst[i];j;j=nxt[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[j];</span><br><span class="line"><span class="keyword">if</span>(v==S || v==T || w[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d "</span>,b[v-n].x,b[v-n].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d "</span>,a[i].x,a[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 UVA1389 Hard Life</title>
      <link href="/2019/01/25/solution_uva1389/"/>
      <url>/2019/01/25/solution_uva1389/</url>
      
        <content type="html"><![CDATA[<p>最大权闭合子图 + 分数规划。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=436016474&auto=0&height=66"></iframe><a id="more"></a><p>这道题就是让求最大密度子图，使 $\frac{\sum Edge}{\sum Dot}$ 最大，那么我们可以用分数规划的思想，二分答案这个比值，建图，超级源到所有点的容量为 $m$，所有点到超级汇的容量为 $m+mid\times2-deg[i]$，其他的按原图建，跑最大流，用 $n\times m$ 减去最大流，判断是否为 $0$，最后用答案跑一遍 $Dinic$，在残流网络上跑一遍 $\text{Dfs}$，得到选择的点，一波输出即可。</p><p>注意，二分答案时 $eps$ 不能设太小，否则会出错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1e18</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXM&lt;&lt;<span class="number">1</span>],to[MAXM&lt;&lt;<span class="number">1</span>],cur[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,fr[MAXM],tx[MAXM],dep[MAXN],deg[MAXN],ans;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">double</span> w[MAXM&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">q.push(S);</span><br><span class="line">dep[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(!dep[v] &amp;&amp; w[i]&gt;eps)</span><br><span class="line">&#123;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dep[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">double</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u==T || flow==<span class="number">0</span>) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">double</span> used=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span> &amp;&amp; w[i]&gt;eps)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> fl=Dfs(v,min(flow,w[i]));</span><br><span class="line"><span class="keyword">if</span>(fl&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">used+=fl;</span><br><span class="line">flow-=fl;</span><br><span class="line">w[i]-=fl;</span><br><span class="line">w[i^<span class="number">1</span>]+=fl;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(flow)&lt;eps) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(Spfa())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(cur,fst,<span class="keyword">sizeof</span>(fst));</span><br><span class="line">sum+=Dfs(S,inf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cnt=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(fst,<span class="number">0</span>,<span class="keyword">sizeof</span>(fst));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(S,i,m);</span><br><span class="line">AddEdge(i,S,<span class="number">0</span>);</span><br><span class="line">AddEdge(i,T,m*<span class="number">1.0</span>+mid*<span class="number">2.0</span>-deg[i]*<span class="number">1.0</span>);</span><br><span class="line">AddEdge(T,i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(fr[i],tx[i],<span class="number">1</span>);</span><br><span class="line">AddEdge(tx[i],fr[i],<span class="number">0</span>);</span><br><span class="line">AddEdge(tx[i],fr[i],<span class="number">1</span>);</span><br><span class="line">AddEdge(fr[i],tx[i],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n*m-Dinic()&gt;eps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindAns</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v] &amp;&amp; w[i]&gt;eps) FindAns(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">S=<span class="number">0</span>;</span><br><span class="line">T=n+<span class="number">1</span>;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(deg,<span class="number">0</span>,<span class="keyword">sizeof</span>(deg));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">if</span>(!m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d\n\n"</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">fr[i]=x;</span><br><span class="line">tx[i]=y;</span><br><span class="line">deg[x]++;</span><br><span class="line">deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=m;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;<span class="number">1e-6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> mid=(l+r)/<span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">if</span>(Check(mid)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line">Check(l);</span><br><span class="line">FindAns(S);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(vis[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 分数规划 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3199 [HNOI2009]最小圈</title>
      <link href="/2019/01/25/solution_p3199/"/>
      <url>/2019/01/25/solution_p3199/</url>
      
        <content type="html"><![CDATA[<p>负环 + 分数规划。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=409649817&auto=0&height=66"></iframe><a id="more"></a><p>这道题的做法和 <a href="https://www.luogu.org/problemnew/show/P3199" target="_blank" rel="noopener"><code>P3288 [SCOI2014]方伯伯运椰子</code></a> 比较相似，所以做着比较快。我们依然要求最小的 $C=\frac{\sum_{i=1}^{k}a’[i]}{\sum_{i=1}^{k}b’[i]}, b[i]=1$，也就是最优比率环，可以得到一个分数规划模型，化一下可以得到 $\sum_{i=1}^{k}a’[i]-C\sum_{i=1}^{k}b’[i]=0$，因为 $b’[i]=1$，得到 $\sum_{i=1}^{k}a’[i]-C=0$，所以我们将所有边权 $-C$，最后判一下是否有负环即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-12</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXM],to[MAXM];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">double</span> dis[MAXN],w[MAXM];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Spfa</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[u]+w[i]-mid)</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]+w[i]-mid;</span><br><span class="line"><span class="keyword">if</span>(vis[v] || Spfa(v,mid)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(Spfa(i,mid)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">double</span> z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %lf"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">AddEdge(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> l=<span class="number">-1e7</span>,r=<span class="number">1e7</span>;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> mid=(l+r)/<span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">if</span>(Check(mid)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>,r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 负环 </tag>
            
            <tag> 分数规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3705 [SDOI2017]新生舞会</title>
      <link href="/2019/01/25/solution_p3705/"/>
      <url>/2019/01/25/solution_p3705/</url>
      
        <content type="html"><![CDATA[<p>二分图最佳匹配 + 分数规划。</p><p>第 $i$ 个男生和第 $j$ 跳舞的喜悦程度为 $a_{i,j}$，不协调程度为 $b_{i,j}$，令 $C=\frac{\sum a’}{\sum b’}$ 最小。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22677451&auto=0&height=66"></iframe><a id="more"></a><p>读题，发现要求最优配对，很显然，这个图是一张二分图，那么最佳匹配我们可以用 $\text{KM}$ 或者 费用流 来求出，这里不赘述如何求出最佳匹配。我们来考虑怎么计算这个 $C=\frac{\sum_{i=1}^{k}a’[i]}{\sum_{i=1}^{k}b’[i]}$。显然，这里的 $\sum_{i=1}^{k}b’[i]$ 是非常不好处理的，所以我们要引入<strong>分数规划</strong>的思想，将这个式子转化成 $\sum_{}^{}a’-C\sum_{}^{}b’=0$，然后二分答案 $C$，每次 $\text{Check}$ 都跑一遍最佳匹配，边权就设成 $a[i][j]-mid\times b[i][j]$，然后跑最大权最佳匹配（也就是最大费用最大流），判断最后得到的权和是否为 $0$ 即可。</p><p>代码选用 $\text{zkw}$ 费用流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1010580540</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">5</span>],to[MAXN&lt;&lt;<span class="number">5</span>],w[MAXN&lt;&lt;<span class="number">5</span>],cur[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,maxflow;</span><br><span class="line"><span class="keyword">double</span> dis[MAXN],a[MAXN][MAXN],b[MAXN][MAXN],cot[MAXN&lt;&lt;<span class="number">5</span>],mincost;</span><br><span class="line"><span class="keyword">bool</span> inq[MAXN],vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c,<span class="keyword">double</span> fl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">cot[cnt]=fl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=S;i&lt;=T;i++) dis[i]=inf;</span><br><span class="line"><span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="keyword">sizeof</span>(inq));</span><br><span class="line">q.push_front(T);</span><br><span class="line">dis[T]=<span class="number">0</span>;</span><br><span class="line">inq[T]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop_front();</span><br><span class="line">inq[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[u]-cot[i] &amp;&amp; w[i^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]-cot[i];</span><br><span class="line"><span class="keyword">if</span>(!inq[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!q.empty() &amp;&amp; dis[v]&lt;dis[q.front()]) q.push_front(v);</span><br><span class="line"><span class="keyword">else</span> q.push_back(v);</span><br><span class="line">inq[v]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[S]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(u==T || !flow) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> used=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dis[v]==dis[u]-cot[i] &amp;&amp; w[i] &amp;&amp; !vis[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fl=Dfs(v,min(flow,w[i]));</span><br><span class="line"><span class="keyword">if</span>(fl)</span><br><span class="line">&#123;</span><br><span class="line">used+=fl;</span><br><span class="line">flow-=fl;</span><br><span class="line">w[i]-=fl;</span><br><span class="line">w[i^<span class="number">1</span>]+=fl;</span><br><span class="line"><span class="keyword">if</span>(!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zkwMCMF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(Spfa())</span><br><span class="line">&#123;</span><br><span class="line">vis[T]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(vis[T])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memcpy</span>(cur,fst,<span class="keyword">sizeof</span>(fst));</span><br><span class="line"><span class="keyword">int</span> fl=Dfs(S,inf);</span><br><span class="line">maxflow+=fl;</span><br><span class="line">mincost+=dis[S]*fl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mincost=-mincost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">maxflow=mincost=<span class="number">0</span>;</span><br><span class="line">cnt=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(fst,<span class="number">0</span>,<span class="keyword">sizeof</span>(fst));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(S,i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">AddEdge(i,S,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i,T,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">AddEdge(T,i,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i,j+n,<span class="number">1</span>,-a[i][j]+b[i][j]*mid);</span><br><span class="line">AddEdge(j+n,i,<span class="number">0</span>,a[i][j]-b[i][j]*mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">zkwMCMF();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fabs</span>(mincost)&lt;=eps || mincost&gt;eps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">S=<span class="number">0</span>;</span><br><span class="line">T=n*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;b[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> mid=(l+r)/<span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">if</span>(Check(mid)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>,r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 分数规划 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>珂朵莉树（ODT）学习笔记</title>
      <link href="/2019/01/23/chtholly_tree_note/"/>
      <url>/2019/01/23/chtholly_tree_note/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>珂朵莉树是一种强大但是限制较多的高级数据结构，它能够解决大部分带有<strong>区间覆盖</strong>操作的题目，同时可以解决独一无二的 $\sum_{i=l}^{r}a[i]^k\%p$ 操作。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=409649820&auto=0&height=66"></iframe><a id="more"></a><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>珂朵莉树的原理是使用 $\text{set}$ 维护若干个区间，这些区间的值都相同，而我们要记录的就是这个值，同时使用一个非常神奇的东西：$\text{mutable}$ 来非常方便地修改区间的值。</p><p>同时，珂朵莉树必须要保证两个条件，一是有区间覆盖，因为这才能把多个区间合成一个区间，二是保证数据随机，否则是可以卡的，不然就和暴力没什么区别了。</p><p>至于区间的存储方式，只要存储左右位置和区间的值就行了，因为区间的值一定是相同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> l&lt;x.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而这个 $\text{mutable}$ 起到什么作用呢？因为在正常情况下，$\text{set}$ 中的元素是没法直接修改的，但是加了这个 $\text{mutable}$ 之后，就可以随时修改这个值了，就算是 $\text{set}$ 中的 $\text{Node}$ 的 $val$ 也能直接修改。</p><hr><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>珂朵莉树的核心操作只有两个，一个是 $\text{Split}$，即按照给出的位置将序列在此处断开，然后用迭代器存下断开位置的区间，如下图所示。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123135041.png" alt=""></p><p>显然，我们在区间操作时，只需要对这个区间的两端分别 $\text{Split}$ 一下，就可以操作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter set <span class="meta-string">&lt;Node&gt;::iterator</span></span></span><br><span class="line"><span class="function">iter <span class="title">Split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter it=s.lower_bound((Node)&#123;pos,pos,<span class="number">-1</span>&#125;);</span><br><span class="line"><span class="keyword">if</span>(it!=s.end() &amp;&amp; it-&gt;l==pos) <span class="keyword">return</span> it;</span><br><span class="line">it--;</span><br><span class="line">Node x=*it;</span><br><span class="line">s.erase(it);</span><br><span class="line">s.insert((Node)&#123;x.l,pos<span class="number">-1</span>,x.val&#125;);</span><br><span class="line"><span class="keyword">return</span> s.insert((Node)&#123;pos,x.r,x.val&#125;).first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一个核心操作是 $\text{Assign}$，也就是“区间推平”，说白了就是区间赋值，这也是珂朵莉树把多个区间变成一个区间的关键，做法很简单，左右 $\text{Split}$ 一下，然后再创建一个新的区间就行了。</p><p>注意：在 $\text{Split}$ 时，右侧端点要 $+1$，否则 $r$ 会被分到后面那个区间里面去，这点应该是很显而易见的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line">s.erase(L,R);</span><br><span class="line">s.insert((Node)&#123;l,r,val&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的操作就都非常暴力了，左右 $\text{Split}$ 一下，然后用迭代器从左边扫到右边，暴力处理即可。</p><hr><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>给出一道最经典的珂朵莉树例题。</p><h2 id="CF896C-Willem-Chtholly-and-Seniorious"><a href="#CF896C-Willem-Chtholly-and-Seniorious" class="headerlink" title="CF896C Willem, Chtholly and Seniorious"></a>CF896C Willem, Chtholly and Seniorious</h2><p><a href="https://www.luogu.org/problemnew/show/CF896C" target="_blank" rel="noopener">链接</a></p><p>操作涉及区间加、区间赋值、区间 $k$ 大值、区间 $x$ 次方和问题，前两个都很简单，区间加用上面给出的方法，左右 $\text{Split}$，然后大力处理即可，区间赋值直接 $\text{Assign}$。区间 $x$ 次方和这个也不难，写一个快速幂函数，依然大力处理就行。</p><p>区间加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(ll l,ll r,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line"><span class="keyword">for</span>(iter it=L;it!=R;it++) it-&gt;val+=val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间 $x$ 次方和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll l,ll r,ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(iter it=L;it!=R;it++) res=(res+<span class="number">1l</span>l*(it-&gt;r-it-&gt;l+<span class="number">1</span>)*QuickPow(it-&gt;val,x,y))%y;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间 $k$ 大值就比较烦了，我们多开一个 $\text{vector}$，左右 $\text{Split}$ 一下，然后从左往右扫，记录一下区间的长度和值，然后把它按值排个序，从头扫到尾，中途累加一下长度，当累加的长度 $≥k$ 时就可以返回当前区间的值了。</p><figure class="highlight pp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ll FindKth(ll l,ll r,ll k)</span><br><span class="line">&#123;</span><br><span class="line">vec.clear();</span><br><span class="line">iter R=Split(r+1),L=Split(l);</span><br><span class="line">for(iter it=L;it!=R;it++) vec.push_back((Segment)&#123;it-&gt;r-it-&gt;l+1,it-&gt;val&#125;);</span><br><span class="line">sort(vec.begin(),vec.end());</span><br><span class="line">ll sum=0;</span><br><span class="line">for(vit=vec.begin();vit!=vec.end();vit++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=vit-&gt;len;</span><br><span class="line">if(sum&gt;=k) return vit-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter set<span class="meta-string">&lt;Node&gt;::iterator</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ll l,r;</span><br><span class="line"><span class="keyword">mutable</span> ll val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> l&lt;x.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span> &lt;Node&gt; s;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll seed,vmax,a[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">rnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ret=seed;</span><br><span class="line">seed=(seed*<span class="number">7</span>+<span class="number">13</span>)%<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iter <span class="title">Split</span><span class="params">(ll pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter it=s.lower_bound((Node)&#123;pos,pos,<span class="number">-1</span>&#125;);</span><br><span class="line"><span class="keyword">if</span>(it!=s.end() &amp;&amp; it-&gt;l==pos) <span class="keyword">return</span> it;</span><br><span class="line">it--;</span><br><span class="line">Node x=*it;</span><br><span class="line">s.erase(it);</span><br><span class="line">s.insert((Node)&#123;x.l,pos<span class="number">-1</span>,x.val&#125;);</span><br><span class="line"><span class="keyword">return</span> s.insert((Node)&#123;pos,x.r,x.val&#125;).first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assign</span><span class="params">(ll l,ll r,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line">s.erase(L,R);</span><br><span class="line">s.insert((Node)&#123;l,r,val&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">QuickPow</span><span class="params">(ll x,ll y,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x%=p;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x%p;</span><br><span class="line">x=x*x%p;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(ll l,ll r,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line"><span class="keyword">for</span>(iter it=L;it!=R;it++) it-&gt;val+=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll l,ll r,ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(iter it=L;it!=R;it++) res=(res+<span class="number">1l</span>l*(it-&gt;r-it-&gt;l+<span class="number">1</span>)*QuickPow(it-&gt;val,x,y))%y;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ll len,val;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Segment &amp;x,<span class="keyword">const</span> Segment &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.val&lt;y.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;Segment&gt; vec;</span><br><span class="line"><span class="built_in">vector</span> &lt;Segment&gt;::iterator vit;</span><br><span class="line"><span class="function">ll <span class="title">FindKth</span><span class="params">(ll l,ll r,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vec.clear();</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line"><span class="keyword">for</span>(iter it=L;it!=R;it++) vec.push_back((Segment)&#123;it-&gt;r-it-&gt;l+<span class="number">1</span>,it-&gt;val&#125;);</span><br><span class="line">sort(vec.begin(),vec.end());</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(vit=vec.begin();vit!=vec.end();vit++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=vit-&gt;len;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;=k) <span class="keyword">return</span> vit-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %lld %lld"</span>,&amp;n,&amp;m,&amp;seed,&amp;vmax);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=rnd()%vmax+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s.insert((Node)&#123;i,i,a[i]&#125;);</span><br><span class="line">s.insert((Node)&#123;n+<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll opt=rnd()%<span class="number">4</span>+<span class="number">1</span>,l=rnd()%n+<span class="number">1</span>,r=rnd()%n+<span class="number">1</span>,x,y;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">3</span>) x=rnd()%(r-l+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> x=rnd()%vmax+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">4</span>) y=rnd()%vmax+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>) Modify(l,r,x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>) Assign(l,r,x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,FindKth(l,r,x));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Query(l,r,x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>不结了。</p><p>附一张珂朵莉的图吧。</p><p><img src="https://z4a.net/images/2019/01/23/70639314_p0.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 珂朵莉树 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零搭建 Hexo + Github 博客</title>
      <link href="/2019/01/23/build_hexo_github_blog/"/>
      <url>/2019/01/23/build_hexo_github_blog/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前有一篇用 $\text{Wordpress}$ 搭建博客的文章，这里给出一种更为方便的搭建方法，只要用 $\text{Github}$。</p><p>笔者是在 $\text{Windows}$ 的环境下搭建的，其他系统可能不适用。</p><p>本文同步发表于笔者的洛谷博客：<a href="https://www.luogu.org/blog/Venus/build-hexo-github-blog" target="_blank" rel="noopener">从零搭建 Hexo + Github 博客</a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=499299379&auto=0&height=66"></iframe><a id="more"></a><hr><p>感谢 @Happynewyear 的帮忙捉虫，以及 @Sinner 提供的部分程序地址。</p><hr><h1 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>安装简单方便，不需要自己找域名、设置 $\text{DNS}$，自带 $\text{Markdown}$，在简单的设置之后即可支持 $\LaTeX$。同时官网有诸多主题可供挑选。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>搭建在 $\text{Github}$ 的服务器上，访问速度较慢，无法自定义域名，想要对博客进行自定义更改需要使用 $\text{JavaScript}$，博客上传比较麻烦。</p><h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>在开始之前，推荐大家提前下载一下之后要用到的程序，如下：</p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">$\text{Node.js}$</a></li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">$\text{Git}$</a></li><li><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">$\text{Sublime}$</a></li></ul><h2 id="账号"><a href="#账号" class="headerlink" title="账号"></a>账号</h2><p>我们只需要一个 <a href="http://github.com" target="_blank" rel="noopener">$\text{Github}$</a> 的账号即可。</p><hr><h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><h2 id="1-配置-text-Github-的-text-SHH"><a href="#1-配置-text-Github-的-text-SHH" class="headerlink" title="1. 配置 $\text{Github}$ 的 $\text{SHH}$"></a>1. 配置 $\text{Github}$ 的 $\text{SHH}$</h2><p>首先进入 $\text{Git}$ <strong>程序</strong>的源文件夹，打开 <code>git-bash.exe</code>。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122221915.png" alt=""></p><p>输入这样一行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;Github 注册的邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>按下回车，按四次，直到出现一个奇怪的图时，则完成。图可能会不同，属于正常现象。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122222235.png" alt=""></p><p>此时就不用管了，我们进入 $\text{Github}$ ，登录自己的账号，点击右上角头像 $\rightarrow$ $\text{Settings}$，</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122222416.png" alt=""></p><p>然后点击左侧的 $\text{SSH and GPG keys}$</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122222534.png" alt=""></p><p>点击右上方的 $\text{New SSH key}$</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122222642.png" alt=""></p><p>此时会让你填两个东西，一个是 $\text{Title}$，一个是 $\text{Key}$，前者我们随便填一个，后者的话，我们进入 <code>C:\Users\你的用户名\.ssh</code>，用记事本打开一个叫做 <code>id_rsa.pub</code> 的文件，把里面的东西复制到 $\text{Key}$ 里面去即可。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122222913.png" alt=""></p><h2 id="2-本地运行-text-Hexo"><a href="#2-本地运行-text-Hexo" class="headerlink" title="2. 本地运行 $\text{Hexo}$"></a>2. 本地运行 $\text{Hexo}$</h2><p>首先进入 $\text{Hexo}$ 的<a href="http://hexo.io" target="_blank" rel="noopener">官网</a>，此时我们会在正中间看见一行代码，这个就是 $\text{Hexo}$ 的安装代码了。</p><p>在安装之前，我们要准备一个东西：存储本地博客的文件夹，这个大家按自己的习惯和情况创建一个文件夹就行，比如我创建的文件夹是 <code>E:/blog</code>，这个 <code>blog</code> 文件夹就是存储所有博客要用的文件夹了。</p><p>为避免出现不必要的 $\text{Bug}$，推荐使用英文的文件夹名字。</p><p>在安装时，各位应该按照自己的路径来设置，千万不要完全照搬这里给出的做法。</p><p>我们打开 <code>cmd</code>（<code>win+R</code> 键打开运行，输入 <code>cmd</code>），先输入盘，比如我这里是 <code>E:</code>，然后输入 <code>cd blog</code>，然后打入给出的那行命令：<code>npm install hexo-cli -g</code>，等到进度条满，你能够再次输入命令时就完成了。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123073219.png" alt=""></p><p>先别急着关 <code>cmd</code>，之后我们还会用到。</p><p>此时我们就要开始创建本地博客了。在 $\text{Hexo}$ 官网首页的下方，有一行代码，<code>hexo init blog</code>，这行代码就是我们创建博客的关键了。此时，如果你没有关掉 <code>cmd</code>，那么它应该是保持着 <code>cd</code> 到你创建的文件夹的状态，如果关掉的话，要重新 <code>E:</code> <code>cd blog</code> 一下。输入官网上的这行代码：<code>hexo init 你的博客名</code>，这个博客名随便起，因为它不会影响你网站上的任何因素，只是会影响之后创建的文件夹的名字。</p><p>输入代码，开始创建博客，又需要一些时间。当然，有一些写着 <code>WARN</code> 的指令行出现，也不用紧张，是正常现象。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123074106.png" alt=""></p><p>等待安装完成，需要一些时间。</p><p>安装好之后，我们就可以看见之前的 <code>blog</code> 文件夹中，出现了一个名字为你刚刚输入的名字文件夹。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123074240.png" alt=""></p><p>我们 <code>cd</code> 到这个文件夹下，对我来说就是 <code>cd vocaloid</code>，然后就可以安装依赖了，输入 <code>npm install</code>，开始安装。</p><p>这个很快就可以完成。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123074443.png" alt=""></p><p>接着我们就可以本地运行了，我们接着在 <code>cmd</code> 中输入 <code>hexo s -p 端口</code>，这个端口不知道有什么限制，推荐输入 <code>5555</code> 或者 <code>4000</code>，很快就可以完成。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123074634.png" alt=""></p><p>此时我们就可以进入 <code>localhost:端口</code>，就可以看到你的 $\text{Hexo}$ 博客啦。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123074743.png" alt=""></p><p>此时如果你在 <code>cmd</code> 中按下 <code>Ctrl+C</code>，再确认终止批处理操作，就可以停止使用这个端口了。</p><h2 id="3-发布至-text-Github"><a href="#3-发布至-text-Github" class="headerlink" title="3. 发布至 $\text{Github}$"></a>3. 发布至 $\text{Github}$</h2><p>在上传之前，我们需要做一些配置。首先用 $\text{Sublime}$ 打开文件夹：</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123075503.png" alt=""></p><p>打开 <code>_config.yml</code>，准备修改。</p><p>进入 $\text{Github}$，先新建一个项目，点击右上角的 $+$ 号，选择 <code>New repository</code>，描述自己填，<strong>名字使用 <code>你的 Github 用户名.github.io</code></strong>。</p><p>（因为我这里是一个号重复建，所以我就不用我的用户名演示了。）</p><p><strong>为了防止接下来的教程出现一些问题，各位最好把“是否有 README” 这一个选项选上，不然就会和我这里给出的情况不同。</strong></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123075856.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123080036.png" alt=""></p><p>此时就进入了项目的页面，我们点击右侧绿色的 <code>Clone or download</code> 按钮，将它给出的链接复制下来。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123081119.png" alt=""></p><p>回到 $\text{Sublime}$，拉到最下面，在 <code>type</code> 后面输入 <code>git</code>（<strong>所有冒号后面都有空格，不能不加</strong>，切记）。</p><p>在 <code>type</code> 这一行下面，加入 <code>repo:</code> ，然后后面填上刚刚复制的地址，往上拉，找到 <code>url:</code>，在 <code>url:</code> 后面输入：<code>http://你的 Github 用户名.github.io</code></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123081136.png" alt=""></p><p>上方有一个 <code>author</code>，这个可以改一下，改成你自己即可。</p><p>此时基础配置就差不多完成了，我们回到 <code>cmd</code>，先退出刚才的本地端口，然后安装一个 $\text{Git}$ 插件。</p><p>输入 <code>npm install hexo-deployer-git --save</code> ，即可等待其安装了。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123081617.png" alt=""></p><p>此时回到 $\text{Sublime}$，在刚刚的 <code>repo</code> 下面再加一行：<code>branch: master</code>，保存。</p><p>完成后，我们就可以尝试运行这个博客了。我们在 <code>cmd</code> 中分别输入两行代码，一行是 <code>hexo g</code>，代表本地文件生成，另一行是 <code>hexo d</code>，代表上传。</p><p>等待一些时间，即可完成。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123081851.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123081934.png" alt=""></p><p>此时会让你配置你的 $\text{Github}$ 账号，需要分别输入两行代码（因为我之前配置过了，所以不用再次配置），如下（这两行代码在 <code>cmd</code> 中都有给出）：</p><p><code>git config --global user.email &quot;你的邮箱&quot;</code></p><p><code>git config --global user.name &quot;你的用户名&quot;</code></p><p>引号不要省略掉。配置好后，再次输入 <code>hexo d</code>，此时会弹出一个窗口，让你登录你的 $\text{Github}$，大概长这样：</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123082548.png" alt=""></p><p>登录就行了。等到上传完成，即可直接访问你的博客了，地址就是你刚才在 $\text{Sublime}$ 中，<code>url:</code> 后面的那个地址。</p><p>此时就完成了博客的搭建，但是我们的博客是不支持 $\LaTeX$ 的，所以我们还需要配置。</p><h2 id="4-404-的解决方案"><a href="#4-404-的解决方案" class="headerlink" title="4. $404$ 的解决方案"></a>4. $404$ 的解决方案</h2><p>我们可能会遇到这样的情况：</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123155325.png" alt=""></p><p>这种情况必然是非常令人恼火的，但解决方法非常简单，我们进入刚才创建的项目的页面，点击 $Settings$，往下拉，找到一个 <code>Custom domain</code>，输入我们之前在 <code>url:</code> 后面输入的那个域名，即 <code>&lt;用户名&gt;.github.io</code>，然后点击 $\text{Save}$，应该就可以访问了。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123155509.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123155641.png" alt=""></p><h2 id="5-主题"><a href="#5-主题" class="headerlink" title="5. 主题"></a>5. 主题</h2><p>不同的主题可以在 $\text{Hexo}$ 的 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a> 中安装，只需要在 <code>cmd</code> 中 <code>cd</code> 到你的博客文件夹（对我来说是 <code>E:\blog\vocaloid</code>），然后在主题的 $\text{Github}$ 中找到安装的代码，如果没有大家可以自行修改别的代码，将地址和文件夹改一下就行了。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123083633.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123083827.png" alt=""></p><p>之后我们可以打开 <code>_config.yml</code>，将下面的 <code>theme:</code> 后面的名字改成安装的文件夹的名字，比如 <code>theme: next</code>。</p><h2 id="6-博客的标题"><a href="#6-博客的标题" class="headerlink" title="6. 博客的标题"></a>6. 博客的标题</h2><p>打开 <code>_config.yml</code>，可以看到上方有一个 <code>title:</code>，把后面的修改掉就行了。</p><hr><h1 id="LaTeX-设置"><a href="#LaTeX-设置" class="headerlink" title="$\LaTeX$ 设置"></a>$\LaTeX$ 设置</h1><p>我们此时搭建的博客只能使用 $\text{Markdown}$，同时因为一些语句的冲突无法使用 $\LaTeX$ ，所以我们需要解决这些冲突，同时安装一个能够使用及渲染 $\LaTeX$ 的语言包。</p><p><strong>下面的操作都默认 <code>cd</code> 到了博客文件夹。</strong></p><h2 id="1-修改引擎"><a href="#1-修改引擎" class="headerlink" title="1. 修改引擎"></a>1. 修改引擎</h2><p>首先我们要将原本的渲染引擎替换成能够支持 $\LaTeX$ 的渲染引擎。原版的引擎是 $\text{Marked}$，我们将它卸载 ，然后安装一个 $\text{Kramed}$ 引擎。</p><p>先 <code>cd</code> 到博客文件夹后，输入以下代码：</p><p><code>npm uninstall hexo-renderer-marked --save</code></p><p><code>npm install hexo-renderer-kramed --save</code></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123084356.png" alt=""></p><h2 id="2-更改配置"><a href="#2-更改配置" class="headerlink" title="2. 更改配置"></a>2. 更改配置</h2><p>用 $\text{Sublime}$ 打开 <code>/node_modules/hexo-renderer-kramed/lib/renderer.js</code> 。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123084514.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">将</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    // Fit kramed&apos;s rule: $$ + \1 + $$</span><br><span class="line">    return text.replace(/`\$(.*?)\$`/g, &apos;$$$$$1$$$$&apos;);</span><br><span class="line">&#125;</span><br><span class="line">改为</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    return text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://z4a.net/images/2019/01/23/TIM20190123084715.png" alt=""></p><h2 id="3-修改数学包"><a href="#3-修改数学包" class="headerlink" title="3. 修改数学包"></a>3. 修改数学包</h2><p>我们要将原来的数学包修改成 $\text{Kramed}$ 适用的数学包，分别输入</p><p><code>npm uninstall hexo-math --save</code></p><p><code>npm install hexo-renderer-mathjax --save</code></p><p>等待其卸载、安装即可。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123085045.png" alt=""></p><h2 id="4-更新配置文件"><a href="#4-更新配置文件" class="headerlink" title="4. 更新配置文件"></a>4. 更新配置文件</h2><p>打开 <code>/node_modules/hexo-renderer-mathjax/mathjax.html</code>，将最下面的代码注释掉（即在开始的 <code>&lt;</code> 后面加上 <code>!--</code>，然后在上面加上一行：<code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;</code> 即可。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123085351.png" alt=""></p><h2 id="5-更改规则"><a href="#5-更改规则" class="headerlink" title="5. 更改规则"></a>5. 更改规则</h2><p>为了解决冲突，我们还需要更改转义规则。首先打开 <code>\node_modules\kramed\lib\rules\inline.js</code>，将 <code>escape</code> 和 <code>em</code> 这两行注释掉，分别修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([`*\[\]()# +\-.!_&gt;])/,</span><br><span class="line"></span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure><p><img src="https://z4a.net/images/2019/01/23/TIM20190123085601.png" alt=""></p><p>至此，我们完成了 $\LaTeX$ 的前置准备，最后只需要启用即可。</p><h2 id="6-启用"><a href="#6-启用" class="headerlink" title="6. 启用"></a>6. 启用</h2><p>进入进入 <code>博客\_config.yml</code>，加上一行 <code>mathjax: true</code> 即可。如果不行的话，就在每篇博客最前面的信息处加上一行 <code>mathjax: true</code> 即可。</p><hr><h1 id="如何上传博客"><a href="#如何上传博客" class="headerlink" title="如何上传博客"></a>如何上传博客</h1><p>我们进入 <code>博客名\source\_posts</code>，这里就是放博客的地方。如果要写博客，最好使用一些 $\text{Markdown}$ + $\LaTeX$ 编辑器，比如 $\text{Typora}$，在本地写好后，在放博客的地方新建一个文档，文档的名字就决定了你的标识符，也就是这个东西：</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123090126.png" alt=""></p><p>文档的后缀名应该是 <code>.md</code>，我们可以创建一个 <code>.txt</code> 文件，然后改后缀就行。用 $\text{Sublime}$ 或者别的编辑器打开后，我们在最上面加上这样一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 你的文章的标题</span><br><span class="line">date: 发布时间</span><br><span class="line">tag: 标签</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>然后再下面直接把博客复制上去就行。</p><p>此时我们就写好了一篇博客，但是我们还需要上传，我们打开 <code>cmd</code>，<code>cd</code> 到你的博客的位置，然后分别输入三行代码：</p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo d</code></p><p>等待一段时间后再回到博客，就可以成功了。</p><p>效果见：<a href="https://venusnero.github.io/2019/01/23/solution_p3644/">Here</a></p><h3 id="文章过长？"><a href="#文章过长？" class="headerlink" title="文章过长？"></a>文章过长？</h3><p>我们会发现，上传博客后往往会在首页将整篇文章的内容都显示出来，这显然是非常占用空间的，此时我们可以在博客的文档中加入一行代码：<code>&lt;!--more--&gt;</code>，然后重新上传，此时在这行代码后面的内容都不会显示出来了，而是改为了一个“$\text{Read More}$”按键，非常方便。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123091628.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123091649.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123091704.png" alt=""></p><hr><h1 id="博客背景"><a href="#博客背景" class="headerlink" title="博客背景"></a>博客背景</h1><p>进入 <code>\themes\landscape\source\css\images</code>，有一张叫做 <code>banner.jpg/png</code> 的图（不同主题的位置及名字都可能不同），我们将它替换，文件名和后缀名最好都一样，然后按照上面传博客的方法，<code>hexo clean</code>，<code>hexo g</code>，<code>hexo d</code>，等一会儿就上传完成了。</p><hr><p>注意：基本上所有修改完成后都要打一遍 <code>hexo clean</code>，<code>hexo g</code>，<code>hexo d</code>，忘记打就会导致修改在网站上无法生效。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这里只是给出了一些最基础的内容，各位想要更深的研究可以在网上找一些教程，也可以套用现有的主题，难度应该不会很大（当然，如果涉及 $\text{JS}$ 那也不简单了【笑】）。</p><p>参考资料：<a href="https://www.bilibili.com/video/av24897960/" target="_blank" rel="noopener">1</a>  <a href="https://www.jianshu.com/p/68e6f82d88b7" target="_blank" rel="noopener">2</a> <a href="https://blog.csdn.net/dajian790626/article/details/78595684?locationNum=10&amp;fps=1" target="_blank" rel="noopener">3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3644 [APIO2015]八邻旁之桥</title>
      <link href="/2019/01/23/solution_p3644/"/>
      <url>/2019/01/23/solution_p3644/</url>
      
        <content type="html"><![CDATA[<p>$\text{FHQ Treap}$。一开始写的不知道为什么写炸了，还以为不能用，不过后来找了一个 <a href="https://www.cnblogs.com/ppprseter/p/9385979.html" target="_blank" rel="noopener">$\text{dalao}$的博客</a> 重构了一下代码，总算还是过掉了。</p><a id="more"></a><p>如第一篇题解所说，$k=1$ 就直接算，$k=2$ 就枚举一个分割线，左右分别算，不过其实不用建两棵树，而是可以先预处理一下，然后就可以重复使用同一棵树（要清空），数据结构要支持区间插入、中值查询、区间和，线段树似乎不错，但我不知道怎么查中值【流下菜鸡的泪水】，所以还是写了<del>一生所爱</del> $\text{FHQ Treap}$，维护下传一个 $sum$ 标记即可。</p><p>写时为了防止读入字符出错使用了关闭流同步的 <code>cin</code>，同时使用 <code>cout</code> 输出，各位有需要可以自行修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FHQTreap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">2</span>],key,siz;</span><br><span class="line">ll val,sum;</span><br><span class="line">&#125;t[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,mid;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x,<span class="keyword">const</span> Node &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.mid&lt;y.mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="keyword">int</span> k,n,siz,root,tot;</span><br><span class="line">ll ans[MAXN],Ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[x].siz=t[t[x].son[<span class="number">0</span>]].siz+t[t[x].son[<span class="number">1</span>]].siz+<span class="number">1</span>;</span><br><span class="line">t[x].sum=t[t[x].son[<span class="number">0</span>]].sum+t[t[x].son[<span class="number">1</span>]].sum+t[x].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NewNode</span><span class="params">(ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[++siz].siz=<span class="number">1</span>;</span><br><span class="line">t[siz].val=val;</span><br><span class="line">t[siz].key=rand();</span><br><span class="line">t[siz].sum=val;</span><br><span class="line"><span class="keyword">return</span> siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x+y;</span><br><span class="line"><span class="keyword">if</span>(t[x].key&lt;t[y].key)</span><br><span class="line">&#123;</span><br><span class="line">t[x].son[<span class="number">1</span>]=Merge(t[x].son[<span class="number">1</span>],y);</span><br><span class="line">Update(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">t[y].son[<span class="number">0</span>]=Merge(x,t[y].son[<span class="number">0</span>]);</span><br><span class="line">Update(y);</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> pos,<span class="keyword">int</span> &amp;l,<span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!rt) l=r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(t[rt].val&lt;=pos)</span><br><span class="line">&#123;</span><br><span class="line">l=rt;</span><br><span class="line">Split(t[rt].son[<span class="number">1</span>],pos,t[rt].son[<span class="number">1</span>],r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r=rt;</span><br><span class="line">Split(t[rt].son[<span class="number">0</span>],pos,l,t[rt].son[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">Update(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=t[t[rt].son[<span class="number">0</span>]].siz) rt=t[rt].son[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pos==t[t[rt].son[<span class="number">0</span>]].siz+<span class="number">1</span>) <span class="keyword">return</span> t[rt].val;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pos-=t[t[rt].son[<span class="number">0</span>]].siz+<span class="number">1</span>;</span><br><span class="line">rt=t[rt].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">Split(root,val,x,y);</span><br><span class="line">root=Merge(Merge(x,NewNode(val)),y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">ll sum=t[root].siz/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line">Split(root,val<span class="number">-1</span>,x,y);</span><br><span class="line">res=t[x].sum*<span class="number">2</span>+val*(sum-t[x].siz)*<span class="number">2</span>;</span><br><span class="line">root=Merge(x,y);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">CalcMid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll rk=FindKth(root,t[root].siz/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> t[root].sum-Query(rk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">char</span> opt1,opt2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;opt1&gt;&gt;x&gt;&gt;opt2&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(x&gt;y) swap(x,y);</span><br><span class="line"><span class="keyword">if</span>(opt1==opt2) Ans+=y-x;</span><br><span class="line"><span class="keyword">else</span> a[++tot]=((Node)&#123;x,y,x+y&#125;);</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+tot+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">&#123;</span><br><span class="line">Insert(a[i].l);</span><br><span class="line">Insert(a[i].r);</span><br><span class="line">ans[i]=CalcMid();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;ans[tot]+Ans+tot&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">ll cnt=ans[tot];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=siz;i++) t[i].son[<span class="number">0</span>]=t[i].son[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">root=siz=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=tot;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">Insert(a[i].l);</span><br><span class="line">Insert(a[i].r);</span><br><span class="line">cnt=min(cnt,ans[i<span class="number">-1</span>]+CalcMid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;cnt+Ans+tot&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> FHQTreap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分瞎入门</title>
      <link href="/2019/01/22/Tree_Split_Train/"/>
      <url>/2019/01/22/Tree_Split_Train/</url>
      
        <content type="html"><![CDATA[<p><del>本文旨在让读者背代码</del></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在做题时，我们可能会遇到这样一类问题：</p><blockquote><p>给定一棵 $n$ 个结点的树和 $m$ 次操作，操作有两种，一种是给定两个结点，让连接两个结点的路径上的所有点权值加上一个值，另一种是查询路径上所有点的权值和。$n\le 1e5$，$m\le 2e5$。</p></blockquote><p>如果是最后统一输出结点权值，用树上差分+$\text{DFS}$ 就能轻松水过，而对于在线查询，如果数据范围小的话暴力即可 $\text{AC}$，时间复杂度 $\text{O}(nm)$，但是很明显，这个数据范围肯定不能这么写了。此时，就需要树链剖分出场了。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=496869422&auto=0&height=66"></iframe><a id="more"></a><h1 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>树链剖分是根据轻重儿子，将一棵树剖成多条链，然后就可以用数据结构来维护这些链了，听着似乎还是有点像暴力，不过因为一条链有多个结点，所以可以优化时间复杂度。</p><p>至于轻重儿子的定义，请见下一块。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>既然要把树剖成一堆链，那么我们就要有一种标准来剖这棵树，树链剖分的标准是什么呢？我们定义：一个结点的所有子树中，<strong>结点数最多的子树的根节点</strong>是这个结点的“重儿子”，比如下面这张图中，红点就是蓝点的重儿子。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fz0h5yjtv0j30e50c3746.jpg" alt=""></p><p>递归进行这个过程，我们可以得到一堆的“重儿子”，将这些重儿子连起来，我们就会得到一根“重链”，最后对整棵树完成这个过程后，我们就将一棵树剖成了若干个“重链”。</p><p>剖完之后，还有一些点，它们则称为“轻儿子”，一些轻边连成的链则称为轻链。（然而这个并没有什么卵用）</p><p>此时我们已经剖完了树，我们就要考虑怎么维护这些链了。在说怎么维护之前，我们先把怎么剖用代码的方式表示出来。</p><p>对于树链剖分，我们需要维护以下的数组：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">$siz[u]$</td><td style="text-align:center">以 $u$ 为根的子树的结点个数</td></tr><tr><td style="text-align:center">$son[u]$</td><td style="text-align:center">$u$ 的重儿子的编号</td></tr><tr><td style="text-align:center">$top[u]$</td><td style="text-align:center">$u$ 所在链的深度最小的结点编号</td></tr><tr><td style="text-align:center">$dep[u]$</td><td style="text-align:center">$u$ 的深度</td></tr><tr><td style="text-align:center">$faz[u]$</td><td style="text-align:center">$u$ 的父亲的编号</td></tr><tr><td style="text-align:center">$dfn[u]$</td><td style="text-align:center">$u$ 的 $\text{DFS}$ 序</td></tr><tr><td style="text-align:center">$rk[u]$</td><td style="text-align:center">$u$ 树中的编号</td></tr></tbody></table></div><p>注：每个轻儿子的 $top$ 就是它本身。</p><p>首先，因为我们在 $\text{DFS}$ 时应该先往重儿子搜索，所以一个 $\text{DFS}$ 肯定是不能完成任务，所以我们需要两个 $\text{DFS}$ 函数。</p><p>这两个 $\text{DFS}$ 函数分别完成什么呢？</p><p>$\text{Dfs1}$：预处理 $siz$，$son$，$dep$，$faz$ 数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">Dfs1(v);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[v]&gt;siz[son[u]]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\text{Dfs2}$：预处理 $dfn$，$top$，$rk$ 数组。其中 $rk$ 数组有的时候用不到，在部分题目中可以省略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u]=++Index;</span><br><span class="line">rk[Index]=u;</span><br><span class="line">top[u]=rt;</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：$\text{Dfs1}$ 没有什么好注意的，$\text{Dfs2}$ 的时候记得先往重儿子搜，至于为什么？</p><h2 id="维护链"><a href="#维护链" class="headerlink" title="维护链"></a>维护链</h2><h3 id="text-DFS-序"><a href="#text-DFS-序" class="headerlink" title="$\text{DFS}$ 序"></a>$\text{DFS}$ 序</h3><p>首先讲一下，为什么要先搜重儿子。因为我们要维护的是重链，而一条链的要求必须是连续的，而我们维护时使用数据结构，必然是要将它转换到数列上来做的，如何转换呢？最好的方法就是按照 $\text{DFS}$ 序，此时如果不先搜重儿子的话，重链上的 $\text{DFS}$ 序就可能会断掉，如下图（橙、绿线是 $\text{DFS}$ 搜索顺序）：</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fz0hrjunzpj30el0cogll.jpg" alt=""></p><p>这条链的 $\text{DFS}$ 序就断开了，此时就无法用数据结构去维护了。</p><h3 id="如何维护"><a href="#如何维护" class="headerlink" title="如何维护"></a>如何维护</h3><p>这一节很简单，没什么好讲的，因为要维护的是链，而且我们现在已经保证链上的 $\text{DFS}$ 序连续了，所以我们直接取结点的 $top$ 到它自己这一段进行修改或查询（即使用 $\text{DFS}$ 序修改），然后再将当前结点跳到它 $top$ 的 $faz$ 即可。为了防止一个结点无限往上跳，我们先选 $top$ 比较深的那个结点进行修改/查询，再往上跳，就可以防止无限跳的情况了。而如果选的是浅的，而它又往上跳，则深度越来越浅，必然会无限跳，最终死循环。</p><p>最后，这两个结点一定会到一条链上，而且必然有一个点会是 $\text{LCA}$，我们最后进行一次操作即可。</p><p>至于为什么是跳到 $top$ 的 $faz$，因为 $top$ 已经被修改/查询过了，跳到上一个结点防止重复操作。</p><p>修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u],val);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[v],val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询（根据求和、求最小值、求最大值修改，仅给出求和）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res+=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">res+=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[v]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于其中的 $\text{Modify}$ 和 $\text{Query}$ 函数，根据不同的需求和使用的数据结构的不同，应自行修改。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="P3384-【模板】树链剖分"><a href="#P3384-【模板】树链剖分" class="headerlink" title="P3384 【模板】树链剖分"></a>P3384 【模板】树链剖分</h2><p><a href="https://www.luogu.org/problemnew/show/P3384" target="_blank" rel="noopener">链接</a></p><p>操作涉及区间加、区间和、子树加、子树和，区间的两种操作直接用线段树配合上面的模板可以轻松过去，而子树加和子树和这两个新操作呢？其实更简单。我们知道，一个子树的 $\text{DFS}$ 序必然是连续的，所以我们直接对 $dfn[x]$ 到 $dfn[x]+siz[x]-1$ 这个序列进行区间加、区间和的操作即可，使用线段树即可无脑水过。</p><p>代码因为年代久远，码风太丑，不贴了。</p><p><strong>重要注意点：</strong>子树操作在 $\text{PushDown}$ 传 $tag$ 的时候，对 $sum$ 的加需要乘上区间长度的一半，切记。</p><h2 id="P2590-ZJOI2008-树的统计"><a href="#P2590-ZJOI2008-树的统计" class="headerlink" title="P2590 [ZJOI2008]树的统计"></a>P2590 [ZJOI2008]树的统计</h2><p><a href="https://www.luogu.org/problemnew/show/P2590" target="_blank" rel="noopener">链接</a></p><p>操作涉及单点修改、区间最大值、区间和，无脑水过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 2147400000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN],to[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,Q,a[MAXN&gt;&gt;<span class="number">1</span>],Index,sum[MAXN&lt;&lt;<span class="number">2</span>],maxn[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> siz[MAXN],son[MAXN],faz[MAXN],dep[MAXN],top[MAXN],rk[MAXN],id[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">Dfs1(v,u);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[v]&gt;siz[son[u]]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">id[u]=++Index;</span><br><span class="line">rk[Index]=u;</span><br><span class="line">top[u]=rt;</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">maxn[rt]=max(maxn[rt&lt;&lt;<span class="number">1</span>],maxn[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">sum[rt]=maxn[rt]=a[rk[l]];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">sum[rt]=maxn[rt]=val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid) Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,pos,val);</span><br><span class="line"><span class="keyword">else</span> Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuerySum</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> sum[rt];</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res+=QuerySum(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res+=QuerySum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line">PushUp(rt);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMaxn</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> maxn[rt];</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=-inf;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res=max(res,QueryMaxn(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res=max(res,QueryMaxn(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line">PushUp(rt);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuerySumOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res+=QuerySum(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v]) swap(u,v);</span><br><span class="line">res+=QuerySum(<span class="number">1</span>,<span class="number">1</span>,n,id[v],id[u]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMaxOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=-inf;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res=max(res,QueryMaxn(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u]));</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v]) swap(u,v);</span><br><span class="line">res=max(res,QueryMaxn(<span class="number">1</span>,<span class="number">1</span>,n,id[v],id[u]));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">AddEdge(x,y);</span><br><span class="line">AddEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">dep[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">faz[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">Dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Q);</span><br><span class="line"><span class="keyword">while</span>(Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">string</span> opt;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;opt&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="string">"CHANGE"</span>) Modify(<span class="number">1</span>,<span class="number">1</span>,n,id[x],y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="string">"QMAX"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QueryMaxOnTree(x,y));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="string">"QSUM"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QuerySumOnTree(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P3178-HAOI2015-树上操作"><a href="#P3178-HAOI2015-树上操作" class="headerlink" title="P3178 [HAOI2015]树上操作"></a>P3178 [HAOI2015]树上操作</h2><p><a href="https://www.luogu.org/problemnew/show/P3178" target="_blank" rel="noopener">链接</a></p><p>操作涉及单点加、子树加、区间和，依然无脑水过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,Q;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN],Index,top[MAXN],faz[MAXN],dep[MAXN],siz[MAXN],son[MAXN];</span><br><span class="line">ll t[MAXN&lt;&lt;<span class="number">2</span>],tag[MAXN&lt;&lt;<span class="number">2</span>],rk[MAXN],a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">Dfs1(v);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u]=++Index;</span><br><span class="line">rk[Index]=a[u];</span><br><span class="line">top[u]=rt;</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[rt]=t[rt&lt;&lt;<span class="number">1</span>]+t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt,ll len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag[rt])</span><br><span class="line">&#123;</span><br><span class="line">tag[rt&lt;&lt;<span class="number">1</span>]+=tag[rt];</span><br><span class="line">tag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=tag[rt];</span><br><span class="line">t[rt&lt;&lt;<span class="number">1</span>]+=tag[rt]*(len-(len&gt;&gt;<span class="number">1</span>));</span><br><span class="line">t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=tag[rt]*(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">tag[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt]=rk[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr)</span><br><span class="line">&#123;</span><br><span class="line">tag[rt]+=val;</span><br><span class="line">t[rt]+=<span class="number">1l</span>l*val*(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PushDown(rt,r-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr,val);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr,val);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line">PushDown(rt,r-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res+=Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res+=Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">QueryOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res+=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">res+=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[v]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;Q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">AddEdge(x,y);</span><br><span class="line">AddEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">Dfs1(<span class="number">1</span>);</span><br><span class="line">Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;opt);</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,QueryOnTree(<span class="number">1</span>,x));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4315-月下“毛景树”"><a href="#P4315-月下“毛景树”" class="headerlink" title="P4315 月下“毛景树”"></a>P4315 月下“毛景树”</h2><p><a href="https://www.luogu.org/problemnew/show/P4315" target="_blank" rel="noopener">链接</a></p><p>操作涉及单点覆盖、区间覆盖、区间加、区间最大值，本来应该是无脑水过，但是因为要将边权转成点权，然后忽略掉 $\text{LCA}$，还是有点难度，具体解析见：<a href="https://www.luogu.org/blog/Venus/solution-p4315" target="_blank" rel="noopener">题解 P4315 【月下“毛景树”】</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>],w[MAXN&lt;&lt;<span class="number">1</span>],fr[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,a[MAXN],t[MAXN&lt;&lt;<span class="number">2</span>],tag[MAXN&lt;&lt;<span class="number">2</span>],cov[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> siz[MAXN],son[MAXN],dfn[MAXN],Index,top[MAXN],rk[MAXN],dep[MAXN],faz[MAXN];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++cnt]=v;</span><br><span class="line">    nxt[cnt]=fst[u];</span><br><span class="line">    fst[u]=cnt;</span><br><span class="line">    w[cnt]=c;</span><br><span class="line">    fr[cnt]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    son[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">        faz[v]=u;</span><br><span class="line">        dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">        rk[v]=w[i];</span><br><span class="line">        Dfs1(v);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=++Index;</span><br><span class="line">    top[u]=rt;</span><br><span class="line">    a[Index]=rk[u];</span><br><span class="line">    <span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        Dfs2(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[rt]=max(t[rt&lt;&lt;<span class="number">1</span>],t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(~cov[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        cov[rt&lt;&lt;<span class="number">1</span>]=cov[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=cov[rt];</span><br><span class="line">        t[rt&lt;&lt;<span class="number">1</span>]=t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=cov[rt];</span><br><span class="line">        tag[rt&lt;&lt;<span class="number">1</span>]=tag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        cov[rt]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tag[rt&lt;&lt;<span class="number">1</span>]+=tag[rt];</span><br><span class="line">    tag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=tag[rt];</span><br><span class="line">    t[rt&lt;&lt;<span class="number">1</span>]+=tag[rt];</span><br><span class="line">    t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=tag[rt];</span><br><span class="line">    tag[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cov[rt]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt]=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyCover</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt]=cov[rt]=val;</span><br><span class="line">        tag[rt]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=mid) ModifyCover(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr,val);</span><br><span class="line">    <span class="keyword">if</span>(tr&gt;mid) ModifyCover(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr,val);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyAdd</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt]+=val;</span><br><span class="line">        tag[rt]+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=mid) ModifyAdd(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr,val);</span><br><span class="line">    <span class="keyword">if</span>(tr&gt;mid) ModifyAdd(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr,val);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line">    PushDown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=mid) res=max(res,Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line">    <span class="keyword">if</span>(tr&gt;mid) res=max(res,Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyCoverOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">        ModifyCover(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u],val);</span><br><span class="line">        u=faz[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">    ModifyCover(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v],val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyAddOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">        ModifyAdd(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u],val);</span><br><span class="line">        u=faz[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">    ModifyAdd(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v],val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMaxnOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">        res=max(res,Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]));</span><br><span class="line">        u=faz[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">    res=max(res,Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        AddEdge(x,y,z);</span><br><span class="line">        AddEdge(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    Dfs1(<span class="number">1</span>);</span><br><span class="line">    Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">"Stop"</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="string">"Change"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> u=fr[x],v=to[x];</span><br><span class="line">                <span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">                ModifyCoverOnTree(u,v,y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"Cover"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;z);</span><br><span class="line">                ModifyCoverOnTree(x,y,z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"Add"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;z);</span><br><span class="line">                ModifyAddOnTree(x,y,z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"Max"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QueryMaxnOnTree(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4114-Qtree1"><a href="#P4114-Qtree1" class="headerlink" title="P4114 Qtree1"></a>P4114 Qtree1</h2><p><a href="https://www.luogu.org/problemnew/show/P4114" target="_blank" rel="noopener">链接</a></p><p>和上一题一样，边权转点权，无脑操作即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>],w[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,a[MAXN],t[MAXN&lt;&lt;<span class="number">2</span>],fr[MAXN],tx[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN],Index,faz[MAXN],siz[MAXN],son[MAXN],dep[MAXN],top[MAXN],rk[MAXN];</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++cnt]=v;</span><br><span class="line">    nxt[cnt]=fst[u];</span><br><span class="line">    fst[u]=cnt;</span><br><span class="line">    w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    son[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">        faz[v]=u;</span><br><span class="line">        a[v]=w[i];</span><br><span class="line">        Dfs1(v);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]]) son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=++Index;</span><br><span class="line">    rk[Index]=u;</span><br><span class="line">    top[u]=rt;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        Dfs2(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[rt]=max(t[rt&lt;&lt;<span class="number">1</span>],t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt]=a[rk[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt]=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid) Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,pos,val);</span><br><span class="line">    <span class="keyword">else</span> Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=mid) res=max(res,Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line">    <span class="keyword">if</span>(tr&gt;mid) res=max(res,Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">        res=max(res,Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]));</span><br><span class="line">        u=faz[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">    res=max(res,Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">int</span> z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %intd"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        fr[i]=x;</span><br><span class="line">        tx[i]=y;</span><br><span class="line">        AddEdge(x,y,z);</span><br><span class="line">        AddEdge(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    Dfs1(<span class="number">1</span>);</span><br><span class="line">    Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">1</span>]==<span class="string">'D'</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span>(ch[<span class="number">1</span>]==<span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QueryOnTree(x,y));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t=dep[fr[x]]&gt;dep[tx[x]]?fr[x]:tx[x];</span><br><span class="line">                Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[t],y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1505-国家集训队-旅游"><a href="#P1505-国家集训队-旅游" class="headerlink" title="P1505 [国家集训队]旅游"></a>P1505 [国家集训队]旅游</h2><p><a href="https://www.luogu.org/problemnew/show/P1505" target="_blank" rel="noopener">链接</a></p><p>最后一道，来道毒瘤的，操作涉及单点修改，区间取相反数，区间和，区间最大值，区间最小值，其他的都简单，就是区间取相反数较难，我们在取相反时，将最大值和最小值<strong>交换</strong>，然后将和、最大值、最小值全部乘上 $-1$ 就行，码量较大，耐心码耐心调还是可以比较轻松的 $\text{A}$ 掉的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>],w[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,Q,a[MAXN],t[MAXN&lt;&lt;<span class="number">2</span>],tag[MAXN&lt;&lt;<span class="number">2</span>],maxn[MAXN&lt;&lt;<span class="number">2</span>],minx[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> siz[MAXN],son[MAXN],top[MAXN],dep[MAXN],faz[MAXN],dfn[MAXN],Index,rk[MAXN];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">rk[v]=w[i];</span><br><span class="line">Dfs1(v);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">top[u]=rt;</span><br><span class="line">dfn[u]=++Index;</span><br><span class="line">a[Index]=rk[u];</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[rt]=t[rt&lt;&lt;<span class="number">1</span>]+t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">maxn[rt]=max(maxn[rt&lt;&lt;<span class="number">1</span>],maxn[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">minx[rt]=min(minx[rt&lt;&lt;<span class="number">1</span>],minx[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag[rt])</span><br><span class="line">&#123;</span><br><span class="line">t[rt&lt;&lt;<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">tag[rt&lt;&lt;<span class="number">1</span>]^=<span class="number">1</span>;</span><br><span class="line">tag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]^=<span class="number">1</span>;</span><br><span class="line">swap(maxn[rt&lt;&lt;<span class="number">1</span>],minx[rt&lt;&lt;<span class="number">1</span>]);</span><br><span class="line">swap(maxn[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],minx[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">maxn[rt&lt;&lt;<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">minx[rt&lt;&lt;<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">maxn[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">minx[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">tag[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt]=maxn[rt]=minx[rt]=a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyPoint</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt]=maxn[rt]=minx[rt]=val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PushDown(rt);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid) ModifyPoint(rt&lt;&lt;<span class="number">1</span>,l,mid,pos,val);</span><br><span class="line"><span class="keyword">else</span> ModifyPoint(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyNega</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr)</span><br><span class="line">&#123;</span><br><span class="line">t[rt]*=<span class="number">-1</span>;</span><br><span class="line">tag[rt]^=<span class="number">1</span>;</span><br><span class="line">swap(maxn[rt],minx[rt]);</span><br><span class="line">maxn[rt]*=<span class="number">-1</span>;</span><br><span class="line">minx[rt]*=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PushDown(rt);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) ModifyNega(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) ModifyNega(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuerySum</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line">PushDown(rt);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res+=QuerySum(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res+=QuerySum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMaxn</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> maxn[rt];</span><br><span class="line">PushDown(rt);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">-2e9</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res=max(res,QueryMaxn(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res=max(res,QueryMaxn(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMinx</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> minx[rt];</span><br><span class="line">PushDown(rt);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res=min(res,QueryMinx(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res=min(res,QueryMinx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyToNegative</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">ModifyNega(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">ModifyNega(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuerySumOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res+=QuerySum(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">res+=QuerySum(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMaxnOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">-2e9</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res=max(res,QueryMaxn(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]));</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">res=max(res,QueryMaxn(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMinxOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res=min(res,QueryMinx(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]));</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">res=min(res,QueryMinx(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">AddEdge(x+<span class="number">1</span>,y+<span class="number">1</span>,z);</span><br><span class="line">AddEdge(y+<span class="number">1</span>,x+<span class="number">1</span>,z);</span><br><span class="line">&#125;</span><br><span class="line">Dfs1(<span class="number">1</span>);</span><br><span class="line">Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Q);</span><br><span class="line"><span class="keyword">while</span>(Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">"C"</span>) ModifyPoint(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x+<span class="number">1</span>],y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"N"</span>) ModifyToNegative(x+<span class="number">1</span>,y+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"SUM"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QuerySumOnTree(x+<span class="number">1</span>,y+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"MAX"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QueryMaxnOnTree(x+<span class="number">1</span>,y+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"MIN"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QueryMinxOnTree(x+<span class="number">1</span>,y+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P3613-睡觉困难综合征"><a href="#P3613-睡觉困难综合征" class="headerlink" title="P3613 睡觉困难综合征"></a>P3613 睡觉困难综合征</h2><p><a href="https://www.luogu.org/problemnew/show/P3613" target="_blank" rel="noopener">链接</a></p><p>这道题是真的难了，首先观察原版 <a href="https://www.luogu.org/problemnew/show/P2114" target="_blank" rel="noopener"><code>P2114 [NOI2014]起床困难综合症</code></a> 的做法，用一个每一个二进制位都是 $0$ 数（即 $0$）和一个每一个二进制位都是 $1$ 的数（即 $2^{31}-1$）跑一遍，然后从高位贪心选，这道题的核心思想也是这样的，线段树记录的是每一段路径上，$0$ 和 $1$ 分别从左往右跑和从右往左跑最终的结果。显然，我们每一个二进制位都要维护一个值，这样的时间复杂度显然是 $\text{O}(nklog^2n)$，即树链剖分的时间复杂度乘上每次计算二进制位的结果的时间复杂度，虽然看着不大，但是因为有一个 $log^2n$，以及时限只有 $0.5s$，而且出题人又是那个谁谁谁，这个复杂度就算是卡常也过不去，此时我们就要想办法优化了。</p><p>观察时间复杂度，$nlog^2n$ 是树剖的基础时间复杂度，怎么优化都是优化不掉的，我们考虑优化掉那个 $k$，我们现在算结果是一位一位算的，所以是 $\text{O}(k)$，那么有没有方法在 $\text{O}(1)$ 的时间复杂度内就把结果算出来呢？其实是有的<del>，只是我不会证，看不懂</del>。</p><p>总而言之就是：</p><p>$now.T0=((L.T0 and R.T1) or ((not L.T0) and R.T0))$</p><p>$now.T1=((L.T1 and R.T1) or ((not L.T1) and R.T0))$</p><p>其中 $now$ 是当前结点，$L$ 是左儿子，$R$ 是右儿子，$T$ 是类型，即从左往右或从右往左，当然，在计算从右往左的时候要把 <strong>所有 $L$ 和 $R$ 反过来</strong>，毕竟是反的嘛。</p><p>按照这个式子，我们可以写出一个计算的函数，然后就可以建线段树了。当然，事情还没有完，因为在树上查询的时候，我们原来是两边交替往上跳，但是因为这道题，方向不同结果也不同，比如 $u-v$ 这条路径，一般走法应该是 $u-lca$，$lca-v$，但是在平时树剖的过程中，就可能是 $u-lca$，$v-lca$，一般是没有影响的，但是这题涉及了位运算，操作乱序结果显然会不同，所以我们要分别跳，对于不同的情况存在两个不同的序列里，然后最后把其中一个序列的从左往右从右往左交换一下，最后再做位运算跑贪心。</p><p>记得开 $\text{unsigned long long}$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> ull MAXULL=<span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ull l0,l1,r0,r1;</span><br><span class="line">&#125;t[MAXN&lt;&lt;<span class="number">2</span>],ans1[MAXN],ans2[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,Q,K,opt[MAXN],tot1,tot2;</span><br><span class="line"><span class="keyword">int</span> siz[MAXN],son[MAXN],dfn[MAXN],Index,dep[MAXN],faz[MAXN],top[MAXN],rk[MAXN];</span><br><span class="line">ull a[MAXN];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">Dfs1(v);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u]=++Index;</span><br><span class="line">rk[Index]=u;</span><br><span class="line">top[u]=rt;</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">Calc</span><span class="params">(ull x,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> opt[rt]==<span class="number">1</span>?x&amp;a[rt]:(opt[rt]==<span class="number">2</span>?x|a[rt]:x^a[rt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">CalcNode</span><span class="params">(Node x,Node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node res;</span><br><span class="line">res.l0=((x.l0&amp;y.l1)|(((~x.l0)&amp;y.l0)));</span><br><span class="line">res.l1=((x.l1&amp;y.l1)|(((~x.l1)&amp;y.l0)));</span><br><span class="line">res.r0=((y.r0&amp;x.r1)|(((~y.r0)&amp;x.r0)));</span><br><span class="line">res.r1=((y.r1&amp;x.r1)|(((~y.r1)&amp;x.r0)));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt].l0=t[rt].r0=Calc(<span class="number">0</span>,rk[l]);</span><br><span class="line">t[rt].l1=t[rt].r1=Calc(MAXULL,rk[l]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">t[rt]=CalcNode(t[rt&lt;&lt;<span class="number">1</span>],t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt].l0=t[rt].r0=Calc(<span class="number">0</span>,rk[l]);</span><br><span class="line">t[rt].l1=t[rt].r1=Calc(MAXULL,rk[l]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=pos) Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,pos);</span><br><span class="line"><span class="keyword">else</span> Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">t[rt]=CalcNode(t[rt&lt;&lt;<span class="number">1</span>],t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">Node res;</span><br><span class="line"><span class="keyword">if</span>(tr&lt;=mid) res=Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tl&gt;mid) res=Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line"><span class="keyword">else</span> res=CalcNode(Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr),Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">QueryOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node res;</span><br><span class="line">tot1=tot2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&gt;=dep[top[v]])</span><br><span class="line">&#123;</span><br><span class="line">ans1[++tot1]=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans2[++tot2]=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[v]],dfn[v]);</span><br><span class="line">v=faz[top[v]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) ans1[++tot1]=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[v],dfn[u]);</span><br><span class="line"><span class="keyword">else</span> ans2[++tot2]=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[v]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot1;i++)</span><br><span class="line">&#123;</span><br><span class="line">swap(ans1[i].l0,ans1[i].r0);</span><br><span class="line">swap(ans1[i].l1,ans1[i].r1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tot1)</span><br><span class="line">&#123;</span><br><span class="line">res=ans1[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot1;i++) res=CalcNode(res,ans1[i]);</span><br><span class="line"><span class="keyword">if</span>(tot2) res=CalcNode(res,ans2[tot2]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> res=ans2[tot2];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=tot2<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) res=CalcNode(res,ans2[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Read(n);</span><br><span class="line">Read(Q);</span><br><span class="line">Read(K);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Read(opt[i]);</span><br><span class="line">Read(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">AddEdge(x,y);</span><br><span class="line">AddEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">Dfs1(<span class="number">1</span>);</span><br><span class="line">Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> Opt;</span><br><span class="line">ull x,y,z;</span><br><span class="line">Read(Opt);</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">Read(z);</span><br><span class="line"><span class="keyword">if</span>(Opt==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Node res=QueryOnTree(x,y);</span><br><span class="line">ull ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">63</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">ull l=(res.l0&gt;&gt;i)&amp;<span class="number">1u</span>ll,r=(res.l1&gt;&gt;i)&amp;<span class="number">1u</span>ll;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r || (<span class="number">1u</span>ll&lt;&lt;i)&gt;z)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l) ans|=(<span class="number">1u</span>ll&lt;&lt;i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(r) ans|=(<span class="number">1u</span>ll&lt;&lt;i);</span><br><span class="line">z-=(<span class="number">1u</span>ll&lt;&lt;i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%llu\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Opt==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">opt[x]=y;</span><br><span class="line">a[x]=z;</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><del>无。</del></p><p>树链剖分是树上操作强大的工具，配合着数据结构对大部分操作有奇效，需要认真学习巩固。</p><p>$\text{FIN.}$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX 测试</title>
      <link href="/2019/01/22/test_of_latex/"/>
      <url>/2019/01/22/test_of_latex/</url>
      
        <content type="html"><![CDATA[<script type="math/tex; mode=display">\max{(S)}=\sum_{T\subseteq S}^{}(-1)^{|T|-1}\min{(T)}</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello the Cruel World</title>
      <link href="/2019/01/22/hello-world/"/>
      <url>/2019/01/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这里是我的新博客，平时随缘更新，望关注【笑</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
