<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>题解 P2526 【[SHOI2001]小狗散步】</title>
      <link href="/2019/01/27/solution_p2526/"/>
      <url>/2019/01/27/solution_p2526/</url>
      
        <content type="html"><![CDATA[<p>网络流。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=456359605&auto=1&height=66"></iframe><a id="more"></a><p>将集合点作为左点，景点作为右点，可以创建出一个二分图，而我们要求的就是它的最大匹配。那么边怎么连呢？我们枚举每个景点 $i$ 和每个集合点 $j$，如果主人从这个集合点 $j$ 到下一个集合点 $j+1$ 需要的时间，比小狗从这个集合点 $j$ 到景点 $i$ 再到下一个集合点 $j+1$ 的时间要长的话，我们就可以在集合点 $j$ 到景点 $i$ 中间连一条边，因为小狗的速度是主人的两倍，所以我们将主人的时间 $\times 2$，或者将小狗的时间 $÷2$，再作比较即可。</p><p>数组记得开大点。</p><p>本文同步发表于笔者的博客：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;a[MAXN],b[MAXN];</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>,fst[MAXN],nxt[MAXM&lt;&lt;<span class="number">1</span>],to[MAXM&lt;&lt;<span class="number">1</span>],w[MAXN&lt;&lt;<span class="number">1</span>],cur[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,dep[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">q.push(S);</span><br><span class="line">dep[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(!dep[v] &amp;&amp; w[i])</span><br><span class="line">&#123;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dep[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u==T || !flow) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> used=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span> &amp;&amp; w[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fl=Dfs(v,min(flow,w[i]));</span><br><span class="line"><span class="keyword">if</span>(fl)</span><br><span class="line">&#123;</span><br><span class="line">used+=fl;</span><br><span class="line">flow-=fl;</span><br><span class="line">w[i]-=fl;</span><br><span class="line">w[i^<span class="number">1</span>]+=fl;</span><br><span class="line"><span class="keyword">if</span>(!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(Bfs())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(cur,fst,<span class="keyword">sizeof</span>(fst));</span><br><span class="line">sum+=Dfs(S,<span class="number">2e9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Calc</span><span class="params">(Node x,Node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="keyword">double</span>)(x.x-y.x)*(x.x-y.x)+(<span class="keyword">double</span>)(x.y-y.y)*(x.y-y.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">S=<span class="number">0</span>;</span><br><span class="line">T=n+m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;b[i].x,&amp;b[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Calc(a[i],a[i<span class="number">-1</span>])&gt;(Calc(a[i<span class="number">-1</span>],b[j])+Calc(b[j],a[i]))/<span class="number">2.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i,j+n,<span class="number">1</span>);</span><br><span class="line">AddEdge(j+n,i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(S,i,<span class="number">1</span>);</span><br><span class="line">AddEdge(i,S,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i+n,T,<span class="number">1</span>);</span><br><span class="line">AddEdge(T,i+n,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=Dinic()+n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d %d "</span>,res,a[<span class="number">1</span>].x,a[<span class="number">1</span>].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=fst[i];j;j=nxt[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[j];</span><br><span class="line"><span class="keyword">if</span>(v==S || v==T || w[j]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d "</span>,b[v-n].x,b[v-n].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d "</span>,a[i].x,a[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 UVA1389 Hard Life</title>
      <link href="/2019/01/25/solution_uva1389/"/>
      <url>/2019/01/25/solution_uva1389/</url>
      
        <content type="html"><![CDATA[<p>最大权闭合子图 + 分数规划。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=436016474&auto=1&height=66"></iframe><a id="more"></a><p>这道题就是让求最大密度子图，使 $\frac{\sum Edge}{\sum Dot}$ 最大，那么我们可以用分数规划的思想，二分答案这个比值，建图，超级源到所有点的容量为 $m$，所有点到超级汇的容量为 $m+mid\times2-deg[i]$，其他的按原图建，跑最大流，用 $n\times m$ 减去最大流，判断是否为 $0$，最后用答案跑一遍 $Dinic$，在残流网络上跑一遍 $\text{Dfs}$，得到选择的点，一波输出即可。</p><p>注意，二分答案时 $eps$ 不能设太小，否则会出错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1e18</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXM&lt;&lt;<span class="number">1</span>],to[MAXM&lt;&lt;<span class="number">1</span>],cur[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,fr[MAXM],tx[MAXM],dep[MAXN],deg[MAXN],ans;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">double</span> w[MAXM&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">q.push(S);</span><br><span class="line">dep[S]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(!dep[v] &amp;&amp; w[i]&gt;eps)</span><br><span class="line">&#123;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dep[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">double</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u==T || flow==<span class="number">0</span>) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">double</span> used=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span> &amp;&amp; w[i]&gt;eps)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> fl=Dfs(v,min(flow,w[i]));</span><br><span class="line"><span class="keyword">if</span>(fl&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">used+=fl;</span><br><span class="line">flow-=fl;</span><br><span class="line">w[i]-=fl;</span><br><span class="line">w[i^<span class="number">1</span>]+=fl;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(flow)&lt;eps) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(Spfa())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(cur,fst,<span class="keyword">sizeof</span>(fst));</span><br><span class="line">sum+=Dfs(S,inf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cnt=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(fst,<span class="number">0</span>,<span class="keyword">sizeof</span>(fst));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(S,i,m);</span><br><span class="line">AddEdge(i,S,<span class="number">0</span>);</span><br><span class="line">AddEdge(i,T,m*<span class="number">1.0</span>+mid*<span class="number">2.0</span>-deg[i]*<span class="number">1.0</span>);</span><br><span class="line">AddEdge(T,i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(fr[i],tx[i],<span class="number">1</span>);</span><br><span class="line">AddEdge(tx[i],fr[i],<span class="number">0</span>);</span><br><span class="line">AddEdge(tx[i],fr[i],<span class="number">1</span>);</span><br><span class="line">AddEdge(fr[i],tx[i],<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n*m-Dinic()&gt;eps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindAns</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v] &amp;&amp; w[i]&gt;eps) FindAns(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">S=<span class="number">0</span>;</span><br><span class="line">T=n+<span class="number">1</span>;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(deg,<span class="number">0</span>,<span class="keyword">sizeof</span>(deg));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">if</span>(!m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d\n\n"</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">fr[i]=x;</span><br><span class="line">tx[i]=y;</span><br><span class="line">deg[x]++;</span><br><span class="line">deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=m;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;<span class="number">1e-6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> mid=(l+r)/<span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">if</span>(Check(mid)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line">Check(l);</span><br><span class="line">FindAns(S);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(vis[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 分数规划 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3199 [HNOI2009]最小圈</title>
      <link href="/2019/01/25/solution_p3199/"/>
      <url>/2019/01/25/solution_p3199/</url>
      
        <content type="html"><![CDATA[<p>负环 + 分数规划。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=409649817&auto=1&height=66"></iframe><a id="more"></a><p>这道题的做法和 <a href="https://www.luogu.org/problemnew/show/P3199" target="_blank" rel="noopener"><code>P3288 [SCOI2014]方伯伯运椰子</code></a> 比较相似，所以做着比较快。我们依然要求最小的 $C=\frac{\sum_{i=1}^{k}a’[i]}{\sum_{i=1}^{k}b’[i]}, b[i]=1$，也就是最优比率环，可以得到一个分数规划模型，化一下可以得到 $\sum_{i=1}^{k}a’[i]-C\sum_{i=1}^{k}b’[i]=0$，因为 $b’[i]=1$，得到 $\sum_{i=1}^{k}a’[i]-C=0$，所以我们将所有边权 $-C$，最后判一下是否有负环即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-12</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXM],to[MAXM];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">double</span> dis[MAXN],w[MAXM];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Spfa</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[u]+w[i]-mid)</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]+w[i]-mid;</span><br><span class="line"><span class="keyword">if</span>(vis[v] || Spfa(v,mid)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(Spfa(i,mid)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">double</span> z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %lf"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">AddEdge(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> l=<span class="number">-1e7</span>,r=<span class="number">1e7</span>;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> mid=(l+r)/<span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">if</span>(Check(mid)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>,r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 分数规划 </tag>
            
            <tag> 负环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3705 [SDOI2017]新生舞会</title>
      <link href="/2019/01/25/solution_p3705/"/>
      <url>/2019/01/25/solution_p3705/</url>
      
        <content type="html"><![CDATA[<p>二分图最佳匹配 + 分数规划。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=22677451&auto=1&height=66"></iframe><a id="more"></a><p>读题，发现要求最优配对，很显然，这个图是一张二分图，那么最佳匹配我们可以用 $\text{KM}$ 或者 费用流 来求出，这里不赘述如何求出最佳匹配。我们来考虑怎么计算这个 $C=\frac{\sum_{i=1}^{k}a’[i]}{\sum_{i=1}^{k}b’[i]}$。显然，这里的 $\sum_{i=1}^{k}b’[i]$ 是非常不好处理的，所以我们要引入<strong>分数规划</strong>的思想，将这个式子转化成 $\sum_{}^{}a’-C\sum_{}^{}b’=0$，然后二分答案 $C$，每次 $\text{Check}$ 都跑一遍最佳匹配，边权就设成 $a[i][j]-mid\times b[i][j]$，然后跑最大权最佳匹配（也就是最大费用最大流），判断最后得到的权和是否为 $0$ 即可。</p><p>代码选用 $\text{zkw}$ 费用流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1010580540</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">5</span>],to[MAXN&lt;&lt;<span class="number">5</span>],w[MAXN&lt;&lt;<span class="number">5</span>],cur[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,maxflow;</span><br><span class="line"><span class="keyword">double</span> dis[MAXN],a[MAXN][MAXN],b[MAXN][MAXN],cot[MAXN&lt;&lt;<span class="number">5</span>],mincost;</span><br><span class="line"><span class="keyword">bool</span> inq[MAXN],vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c,<span class="keyword">double</span> fl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">cot[cnt]=fl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=S;i&lt;=T;i++) dis[i]=inf;</span><br><span class="line"><span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="keyword">sizeof</span>(inq));</span><br><span class="line">q.push_front(T);</span><br><span class="line">dis[T]=<span class="number">0</span>;</span><br><span class="line">inq[T]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop_front();</span><br><span class="line">inq[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[u]-cot[i] &amp;&amp; w[i^<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]-cot[i];</span><br><span class="line"><span class="keyword">if</span>(!inq[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!q.empty() &amp;&amp; dis[v]&lt;dis[q.front()]) q.push_front(v);</span><br><span class="line"><span class="keyword">else</span> q.push_back(v);</span><br><span class="line">inq[v]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dis[S]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(u==T || !flow) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> used=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(dis[v]==dis[u]-cot[i] &amp;&amp; w[i] &amp;&amp; !vis[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fl=Dfs(v,min(flow,w[i]));</span><br><span class="line"><span class="keyword">if</span>(fl)</span><br><span class="line">&#123;</span><br><span class="line">used+=fl;</span><br><span class="line">flow-=fl;</span><br><span class="line">w[i]-=fl;</span><br><span class="line">w[i^<span class="number">1</span>]+=fl;</span><br><span class="line"><span class="keyword">if</span>(!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zkwMCMF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(Spfa())</span><br><span class="line">&#123;</span><br><span class="line">vis[T]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(vis[T])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memcpy</span>(cur,fst,<span class="keyword">sizeof</span>(fst));</span><br><span class="line"><span class="keyword">int</span> fl=Dfs(S,inf);</span><br><span class="line">maxflow+=fl;</span><br><span class="line">mincost+=dis[S]*fl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mincost=-mincost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">double</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">maxflow=mincost=<span class="number">0</span>;</span><br><span class="line">cnt=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(fst,<span class="number">0</span>,<span class="keyword">sizeof</span>(fst));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(S,i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">AddEdge(i,S,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i,T,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">AddEdge(T,i,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">AddEdge(i,j+n,<span class="number">1</span>,-a[i][j]+b[i][j]*mid);</span><br><span class="line">AddEdge(j+n,i,<span class="number">0</span>,a[i][j]-b[i][j]*mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">zkwMCMF();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fabs</span>(mincost)&lt;=eps || mincost&gt;eps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">S=<span class="number">0</span>;</span><br><span class="line">T=n*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;b[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> l=<span class="number">0</span>,r=<span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> mid=(l+r)/<span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">if</span>(Check(mid)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>,r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 费用流 </tag>
            
            <tag> 分数规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>珂朵莉树（ODT）学习笔记</title>
      <link href="/2019/01/23/chtholly_tree_note/"/>
      <url>/2019/01/23/chtholly_tree_note/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>珂朵莉树是一种强大但是限制较多的高级数据结构，它能够解决大部分带有<strong>区间覆盖</strong>操作的题目，同时可以解决独一无二的 $\sum_{i=l}^{r}a[i]^k\%p$ 操作。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=409649820&auto=1&height=66"></iframe><a id="more"></a><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>珂朵莉树的原理是使用 $\text{set}$ 维护若干个区间，这些区间的值都相同，而我们要记录的就是这个值，同时使用一个非常神奇的东西：$\text{mutable}$ 来非常方便地修改区间的值。</p><p>同时，珂朵莉树必须要保证两个条件，一是有区间覆盖，因为这才能把多个区间合成一个区间，二是保证数据随机，否则是可以卡的，不然就和暴力没什么区别了。</p><p>至于区间的存储方式，只要存储左右位置和区间的值就行了，因为区间的值一定是相同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> l&lt;x.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而这个 $\text{mutable}$ 起到什么作用呢？因为在正常情况下，$\text{set}$ 中的元素是没法直接修改的，但是加了这个 $\text{mutable}$ 之后，就可以随时修改这个值了，就算是 $\text{set}$ 中的 $\text{Node}$ 的 $val$ 也能直接修改。</p><hr><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>珂朵莉树的核心操作只有两个，一个是 $\text{Split}$，即按照给出的位置将序列在此处断开，然后用迭代器存下断开位置的区间，如下图所示。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123135041.png" alt=""></p><p>显然，我们在区间操作时，只需要对这个区间的两端分别 $\text{Split}$ 一下，就可以操作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter set <span class="meta-string">&lt;Node&gt;::iterator</span></span></span><br><span class="line"><span class="function">iter <span class="title">Split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter it=s.lower_bound((Node)&#123;pos,pos,<span class="number">-1</span>&#125;);</span><br><span class="line"><span class="keyword">if</span>(it!=s.end() &amp;&amp; it-&gt;l==pos) <span class="keyword">return</span> it;</span><br><span class="line">it--;</span><br><span class="line">Node x=*it;</span><br><span class="line">s.erase(it);</span><br><span class="line">s.insert((Node)&#123;x.l,pos<span class="number">-1</span>,x.val&#125;);</span><br><span class="line"><span class="keyword">return</span> s.insert((Node)&#123;pos,x.r,x.val&#125;).first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一个核心操作是 $\text{Assign}$，也就是“区间推平”，说白了就是区间赋值，这也是珂朵莉树把多个区间变成一个区间的关键，做法很简单，左右 $\text{Split}$ 一下，然后再创建一个新的区间就行了。</p><p>注意：在 $\text{Split}$ 时，右侧端点要 $+1$，否则 $r$ 会被分到后面那个区间里面去，这点应该是很显而易见的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line">s.erase(L,R);</span><br><span class="line">s.insert((Node)&#123;l,r,val&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的操作就都非常暴力了，左右 $\text{Split}$ 一下，然后用迭代器从左边扫到右边，暴力处理即可。</p><hr><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>给出一道最经典的珂朵莉树例题。</p><h2 id="CF896C-Willem-Chtholly-and-Seniorious"><a href="#CF896C-Willem-Chtholly-and-Seniorious" class="headerlink" title="CF896C Willem, Chtholly and Seniorious"></a>CF896C Willem, Chtholly and Seniorious</h2><p><a href="https://www.luogu.org/problemnew/show/CF896C" target="_blank" rel="noopener">链接</a></p><p>操作涉及区间加、区间赋值、区间 $k$ 大值、区间 $x$ 次方和问题，前两个都很简单，区间加用上面给出的方法，左右 $\text{Split}$，然后大力处理即可，区间赋值直接 $\text{Assign}$。区间 $x$ 次方和这个也不难，写一个快速幂函数，依然大力处理就行。</p><p>区间加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(ll l,ll r,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line"><span class="keyword">for</span>(iter it=L;it!=R;it++) it-&gt;val+=val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间 $x$ 次方和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll l,ll r,ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(iter it=L;it!=R;it++) res=(res+<span class="number">1l</span>l*(it-&gt;r-it-&gt;l+<span class="number">1</span>)*QuickPow(it-&gt;val,x,y))%y;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间 $k$ 大值就比较烦了，我们多开一个 $\text{vector}$，左右 $\text{Split}$ 一下，然后从左往右扫，记录一下区间的长度和值，然后把它按值排个序，从头扫到尾，中途累加一下长度，当累加的长度 $≥k$ 时就可以返回当前区间的值了。</p><figure class="highlight pp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ll FindKth(ll l,ll r,ll k)</span><br><span class="line">&#123;</span><br><span class="line">vec.clear();</span><br><span class="line">iter R=Split(r+1),L=Split(l);</span><br><span class="line">for(iter it=L;it!=R;it++) vec.push_back((Segment)&#123;it-&gt;r-it-&gt;l+1,it-&gt;val&#125;);</span><br><span class="line">sort(vec.begin(),vec.end());</span><br><span class="line">ll sum=0;</span><br><span class="line">for(vit=vec.begin();vit!=vec.end();vit++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=vit-&gt;len;</span><br><span class="line">if(sum&gt;=k) return vit-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iter set<span class="meta-string">&lt;Node&gt;::iterator</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ll l,r;</span><br><span class="line"><span class="keyword">mutable</span> ll val;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> l&lt;x.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span> &lt;Node&gt; s;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll seed,vmax,a[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">rnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ret=seed;</span><br><span class="line">seed=(seed*<span class="number">7</span>+<span class="number">13</span>)%<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iter <span class="title">Split</span><span class="params">(ll pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter it=s.lower_bound((Node)&#123;pos,pos,<span class="number">-1</span>&#125;);</span><br><span class="line"><span class="keyword">if</span>(it!=s.end() &amp;&amp; it-&gt;l==pos) <span class="keyword">return</span> it;</span><br><span class="line">it--;</span><br><span class="line">Node x=*it;</span><br><span class="line">s.erase(it);</span><br><span class="line">s.insert((Node)&#123;x.l,pos<span class="number">-1</span>,x.val&#125;);</span><br><span class="line"><span class="keyword">return</span> s.insert((Node)&#123;pos,x.r,x.val&#125;).first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assign</span><span class="params">(ll l,ll r,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line">s.erase(L,R);</span><br><span class="line">s.insert((Node)&#123;l,r,val&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">QuickPow</span><span class="params">(ll x,ll y,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x%=p;</span><br><span class="line">ll res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>) res=res*x%p;</span><br><span class="line">x=x*x%p;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(ll l,ll r,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line"><span class="keyword">for</span>(iter it=L;it!=R;it++) it-&gt;val+=val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll l,ll r,ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(iter it=L;it!=R;it++) res=(res+<span class="number">1l</span>l*(it-&gt;r-it-&gt;l+<span class="number">1</span>)*QuickPow(it-&gt;val,x,y))%y;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ll len,val;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Segment &amp;x,<span class="keyword">const</span> Segment &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.val&lt;y.val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;Segment&gt; vec;</span><br><span class="line"><span class="built_in">vector</span> &lt;Segment&gt;::iterator vit;</span><br><span class="line"><span class="function">ll <span class="title">FindKth</span><span class="params">(ll l,ll r,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vec.clear();</span><br><span class="line">iter R=Split(r+<span class="number">1</span>),L=Split(l);</span><br><span class="line"><span class="keyword">for</span>(iter it=L;it!=R;it++) vec.push_back((Segment)&#123;it-&gt;r-it-&gt;l+<span class="number">1</span>,it-&gt;val&#125;);</span><br><span class="line">sort(vec.begin(),vec.end());</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(vit=vec.begin();vit!=vec.end();vit++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=vit-&gt;len;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;=k) <span class="keyword">return</span> vit-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %lld %lld"</span>,&amp;n,&amp;m,&amp;seed,&amp;vmax);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=rnd()%vmax+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s.insert((Node)&#123;i,i,a[i]&#125;);</span><br><span class="line">s.insert((Node)&#123;n+<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll opt=rnd()%<span class="number">4</span>+<span class="number">1</span>,l=rnd()%n+<span class="number">1</span>,r=rnd()%n+<span class="number">1</span>,x,y;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">3</span>) x=rnd()%(r-l+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> x=rnd()%vmax+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">4</span>) y=rnd()%vmax+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>) Modify(l,r,x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>) Assign(l,r,x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,FindKth(l,r,x));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Query(l,r,x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>不结了。</p><p>附一张珂朵莉的图吧。</p><p><img src="https://z4a.net/images/2019/01/23/70639314_p0.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> 珂朵莉树 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零搭建 Hexo + Github 博客</title>
      <link href="/2019/01/23/build_hexo_github_blog/"/>
      <url>/2019/01/23/build_hexo_github_blog/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前有一篇用 $\text{Wordpress}$ 搭建博客的文章，这里给出一种更为方便的搭建方法，只要用 $\text{Github}$。</p><p>笔者是在 $\text{Windows}$ 的环境下搭建的，其他系统可能不适用。</p><p>本文同步发表于笔者的洛谷博客：<a href="https://www.luogu.org/blog/Venus/build-hexo-github-blog" target="_blank" rel="noopener">从零搭建 Hexo + Github 博客</a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=499299379&auto=1&height=66"></iframe><a id="more"></a><hr><p>感谢 @Happynewyear 的帮忙捉虫，以及 @Sinner 提供的部分程序地址。</p><hr><h1 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>安装简单方便，不需要自己找域名、设置 $\text{DNS}$，自带 $\text{Markdown}$，在简单的设置之后即可支持 $\LaTeX$。同时官网有诸多主题可供挑选。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>搭建在 $\text{Github}$ 的服务器上，访问速度较慢，无法自定义域名，想要对博客进行自定义更改需要使用 $\text{JavaScript}$，博客上传比较麻烦。</p><h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>在开始之前，推荐大家提前下载一下之后要用到的程序，如下：</p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">$\text{Node.js}$</a></li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">$\text{Git}$</a></li><li><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">$\text{Sublime}$</a></li></ul><h2 id="账号"><a href="#账号" class="headerlink" title="账号"></a>账号</h2><p>我们只需要一个 <a href="http://github.com" target="_blank" rel="noopener">$\text{Github}$</a> 的账号即可。</p><hr><h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><h2 id="1-配置-text-Github-的-text-SHH"><a href="#1-配置-text-Github-的-text-SHH" class="headerlink" title="1. 配置 $\text{Github}$ 的 $\text{SHH}$"></a>1. 配置 $\text{Github}$ 的 $\text{SHH}$</h2><p>首先进入 $\text{Git}$ <strong>程序</strong>的源文件夹，打开 <code>git-bash.exe</code>。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122221915.png" alt=""></p><p>输入这样一行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;Github 注册的邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>按下回车，按四次，直到出现一个奇怪的图时，则完成。图可能会不同，属于正常现象。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122222235.png" alt=""></p><p>此时就不用管了，我们进入 $\text{Github}$ ，登录自己的账号，点击右上角头像 $\rightarrow$ $\text{Settings}$，</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122222416.png" alt=""></p><p>然后点击左侧的 $\text{SSH and GPG keys}$</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122222534.png" alt=""></p><p>点击右上方的 $\text{New SSH key}$</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122222642.png" alt=""></p><p>此时会让你填两个东西，一个是 $\text{Title}$，一个是 $\text{Key}$，前者我们随便填一个，后者的话，我们进入 <code>C:\Users\你的用户名\.ssh</code>，用记事本打开一个叫做 <code>id_rsa.pub</code> 的文件，把里面的东西复制到 $\text{Key}$ 里面去即可。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190122222913.png" alt=""></p><h2 id="2-本地运行-text-Hexo"><a href="#2-本地运行-text-Hexo" class="headerlink" title="2. 本地运行 $\text{Hexo}$"></a>2. 本地运行 $\text{Hexo}$</h2><p>首先进入 $\text{Hexo}$ 的<a href="http://hexo.io" target="_blank" rel="noopener">官网</a>，此时我们会在正中间看见一行代码，这个就是 $\text{Hexo}$ 的安装代码了。</p><p>在安装之前，我们要准备一个东西：存储本地博客的文件夹，这个大家按自己的习惯和情况创建一个文件夹就行，比如我创建的文件夹是 <code>E:/blog</code>，这个 <code>blog</code> 文件夹就是存储所有博客要用的文件夹了。</p><p>为避免出现不必要的 $\text{Bug}$，推荐使用英文的文件夹名字。</p><p>在安装时，各位应该按照自己的路径来设置，千万不要完全照搬这里给出的做法。</p><p>我们打开 <code>cmd</code>（<code>win+R</code> 键打开运行，输入 <code>cmd</code>），先输入盘，比如我这里是 <code>E:</code>，然后输入 <code>cd blog</code>，然后打入给出的那行命令：<code>npm install hexo-cli -g</code>，等到进度条满，你能够再次输入命令时就完成了。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123073219.png" alt=""></p><p>先别急着关 <code>cmd</code>，之后我们还会用到。</p><p>此时我们就要开始创建本地博客了。在 $\text{Hexo}$ 官网首页的下方，有一行代码，<code>hexo init blog</code>，这行代码就是我们创建博客的关键了。此时，如果你没有关掉 <code>cmd</code>，那么它应该是保持着 <code>cd</code> 到你创建的文件夹的状态，如果关掉的话，要重新 <code>E:</code> <code>cd blog</code> 一下。输入官网上的这行代码：<code>hexo init 你的博客名</code>，这个博客名随便起，因为它不会影响你网站上的任何因素，只是会影响之后创建的文件夹的名字。</p><p>输入代码，开始创建博客，又需要一些时间。当然，有一些写着 <code>WARN</code> 的指令行出现，也不用紧张，是正常现象。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123074106.png" alt=""></p><p>等待安装完成，需要一些时间。</p><p>安装好之后，我们就可以看见之前的 <code>blog</code> 文件夹中，出现了一个名字为你刚刚输入的名字文件夹。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123074240.png" alt=""></p><p>我们 <code>cd</code> 到这个文件夹下，对我来说就是 <code>cd vocaloid</code>，然后就可以安装依赖了，输入 <code>npm install</code>，开始安装。</p><p>这个很快就可以完成。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123074443.png" alt=""></p><p>接着我们就可以本地运行了，我们接着在 <code>cmd</code> 中输入 <code>hexo s -p 端口</code>，这个端口不知道有什么限制，推荐输入 <code>5555</code> 或者 <code>4000</code>，很快就可以完成。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123074634.png" alt=""></p><p>此时我们就可以进入 <code>localhost:端口</code>，就可以看到你的 $\text{Hexo}$ 博客啦。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123074743.png" alt=""></p><p>此时如果你在 <code>cmd</code> 中按下 <code>Ctrl+C</code>，再确认终止批处理操作，就可以停止使用这个端口了。</p><h2 id="3-发布至-text-Github"><a href="#3-发布至-text-Github" class="headerlink" title="3. 发布至 $\text{Github}$"></a>3. 发布至 $\text{Github}$</h2><p>在上传之前，我们需要做一些配置。首先用 $\text{Sublime}$ 打开文件夹：</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123075503.png" alt=""></p><p>打开 <code>_config.yml</code>，准备修改。</p><p>进入 $\text{Github}$，先新建一个项目，点击右上角的 $+$ 号，选择 <code>New repository</code>，描述自己填，<strong>名字使用 <code>你的 Github 用户名.github.io</code></strong>。</p><p>（因为我这里是一个号重复建，所以我就不用我的用户名演示了。）</p><p><strong>为了防止接下来的教程出现一些问题，各位最好把“是否有 README” 这一个选项选上，不然就会和我这里给出的情况不同。</strong></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123075856.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123080036.png" alt=""></p><p>此时就进入了项目的页面，我们点击右侧绿色的 <code>Clone or download</code> 按钮，将它给出的链接复制下来。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123081119.png" alt=""></p><p>回到 $\text{Sublime}$，拉到最下面，在 <code>type</code> 后面输入 <code>git</code>（<strong>所有冒号后面都有空格，不能不加</strong>，切记）。</p><p>在 <code>type</code> 这一行下面，加入 <code>repo:</code> ，然后后面填上刚刚复制的地址，往上拉，找到 <code>url:</code>，在 <code>url:</code> 后面输入：<code>http://你的 Github 用户名.github.io</code></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123081136.png" alt=""></p><p>上方有一个 <code>author</code>，这个可以改一下，改成你自己即可。</p><p>此时基础配置就差不多完成了，我们回到 <code>cmd</code>，先退出刚才的本地端口，然后安装一个 $\text{Git}$ 插件。</p><p>输入 <code>npm install hexo-deployer-git --save</code> ，即可等待其安装了。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123081617.png" alt=""></p><p>此时回到 $\text{Sublime}$，在刚刚的 <code>repo</code> 下面再加一行：<code>branch: master</code>，保存。</p><p>完成后，我们就可以尝试运行这个博客了。我们在 <code>cmd</code> 中分别输入两行代码，一行是 <code>hexo g</code>，代表本地文件生成，另一行是 <code>hexo d</code>，代表上传。</p><p>等待一些时间，即可完成。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123081851.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123081934.png" alt=""></p><p>此时会让你配置你的 $\text{Github}$ 账号，需要分别输入两行代码（因为我之前配置过了，所以不用再次配置），如下（这两行代码在 <code>cmd</code> 中都有给出）：</p><p><code>git config --global user.email &quot;你的邮箱&quot;</code></p><p><code>git config --global user.name &quot;你的用户名&quot;</code></p><p>引号不要省略掉。配置好后，再次输入 <code>hexo d</code>，此时会弹出一个窗口，让你登录你的 $\text{Github}$，大概长这样：</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123082548.png" alt=""></p><p>登录就行了。等到上传完成，即可直接访问你的博客了，地址就是你刚才在 $\text{Sublime}$ 中，<code>url:</code> 后面的那个地址。</p><p>此时就完成了博客的搭建，但是我们的博客是不支持 $\LaTeX$ 的，所以我们还需要配置。</p><h2 id="4-404-的解决方案"><a href="#4-404-的解决方案" class="headerlink" title="4. $404$ 的解决方案"></a>4. $404$ 的解决方案</h2><p>我们可能会遇到这样的情况：</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123155325.png" alt=""></p><p>这种情况必然是非常令人恼火的，但解决方法非常简单，我们进入刚才创建的项目的页面，点击 $Settings$，往下拉，找到一个 <code>Custom domain</code>，输入我们之前在 <code>url:</code> 后面输入的那个域名，即 <code>&lt;用户名&gt;.github.io</code>，然后点击 $\text{Save}$，应该就可以访问了。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123155509.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123155641.png" alt=""></p><h2 id="5-主题"><a href="#5-主题" class="headerlink" title="5. 主题"></a>5. 主题</h2><p>不同的主题可以在 $\text{Hexo}$ 的 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a> 中安装，只需要在 <code>cmd</code> 中 <code>cd</code> 到你的博客文件夹（对我来说是 <code>E:\blog\vocaloid</code>），然后在主题的 $\text{Github}$ 中找到安装的代码，如果没有大家可以自行修改别的代码，将地址和文件夹改一下就行了。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123083633.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123083827.png" alt=""></p><p>之后我们可以打开 <code>_config.yml</code>，将下面的 <code>theme:</code> 后面的名字改成安装的文件夹的名字，比如 <code>theme: next</code>。</p><h2 id="6-博客的标题"><a href="#6-博客的标题" class="headerlink" title="6. 博客的标题"></a>6. 博客的标题</h2><p>打开 <code>_config.yml</code>，可以看到上方有一个 <code>title:</code>，把后面的修改掉就行了。</p><hr><h1 id="LaTeX-设置"><a href="#LaTeX-设置" class="headerlink" title="$\LaTeX$ 设置"></a>$\LaTeX$ 设置</h1><p>我们此时搭建的博客只能使用 $\text{Markdown}$，同时因为一些语句的冲突无法使用 $\LaTeX$ ，所以我们需要解决这些冲突，同时安装一个能够使用及渲染 $\LaTeX$ 的语言包。</p><p><strong>下面的操作都默认 <code>cd</code> 到了博客文件夹。</strong></p><h2 id="1-修改引擎"><a href="#1-修改引擎" class="headerlink" title="1. 修改引擎"></a>1. 修改引擎</h2><p>首先我们要将原本的渲染引擎替换成能够支持 $\LaTeX$ 的渲染引擎。原版的引擎是 $\text{Marked}$，我们将它卸载 ，然后安装一个 $\text{Kramed}$ 引擎。</p><p>先 <code>cd</code> 到博客文件夹后，输入以下代码：</p><p><code>npm uninstall hexo-renderer-marked --save</code></p><p><code>npm install hexo-renderer-kramed --save</code></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123084356.png" alt=""></p><h2 id="2-更改配置"><a href="#2-更改配置" class="headerlink" title="2. 更改配置"></a>2. 更改配置</h2><p>用 $\text{Sublime}$ 打开 <code>/node_modules/hexo-renderer-kramed/lib/renderer.js</code> 。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123084514.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">将</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    // Fit kramed&apos;s rule: $$ + \1 + $$</span><br><span class="line">    return text.replace(/`\$(.*?)\$`/g, &apos;$$$$$1$$$$&apos;);</span><br><span class="line">&#125;</span><br><span class="line">改为</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    return text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://z4a.net/images/2019/01/23/TIM20190123084715.png" alt=""></p><h2 id="3-修改数学包"><a href="#3-修改数学包" class="headerlink" title="3. 修改数学包"></a>3. 修改数学包</h2><p>我们要将原来的数学包修改成 $\text{Kramed}$ 适用的数学包，分别输入</p><p><code>npm uninstall hexo-math --save</code></p><p><code>npm install hexo-renderer-mathjax --save</code></p><p>等待其卸载、安装即可。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123085045.png" alt=""></p><h2 id="4-更新配置文件"><a href="#4-更新配置文件" class="headerlink" title="4. 更新配置文件"></a>4. 更新配置文件</h2><p>打开 <code>/node_modules/hexo-renderer-mathjax/mathjax.html</code>，将最下面的代码注释掉（即在开始的 <code>&lt;</code> 后面加上 <code>!--</code>，然后在上面加上一行：<code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;</code> 即可。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123085351.png" alt=""></p><h2 id="5-更改规则"><a href="#5-更改规则" class="headerlink" title="5. 更改规则"></a>5. 更改规则</h2><p>为了解决冲突，我们还需要更改转义规则。首先打开 <code>\node_modules\kramed\lib\rules\inline.js</code>，将 <code>escape</code> 和 <code>em</code> 这两行注释掉，分别修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([`*\[\]()# +\-.!_&gt;])/,</span><br><span class="line"></span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure><p><img src="https://z4a.net/images/2019/01/23/TIM20190123085601.png" alt=""></p><p>至此，我们完成了 $\LaTeX$ 的前置准备，最后只需要启用即可。</p><h2 id="6-启用"><a href="#6-启用" class="headerlink" title="6. 启用"></a>6. 启用</h2><p>进入进入 <code>博客\_config.yml</code>，加上一行 <code>mathjax: true</code> 即可。如果不行的话，就在每篇博客最前面的信息处加上一行 <code>mathjax: true</code> 即可。</p><hr><h1 id="如何上传博客"><a href="#如何上传博客" class="headerlink" title="如何上传博客"></a>如何上传博客</h1><p>我们进入 <code>博客名\source\_posts</code>，这里就是放博客的地方。如果要写博客，最好使用一些 $\text{Markdown}$ + $\LaTeX$ 编辑器，比如 $\text{Typora}$，在本地写好后，在放博客的地方新建一个文档，文档的名字就决定了你的标识符，也就是这个东西：</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123090126.png" alt=""></p><p>文档的后缀名应该是 <code>.md</code>，我们可以创建一个 <code>.txt</code> 文件，然后改后缀就行。用 $\text{Sublime}$ 或者别的编辑器打开后，我们在最上面加上这样一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 你的文章的标题</span><br><span class="line">date: 发布时间</span><br><span class="line">tag: 标签</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>然后再下面直接把博客复制上去就行。</p><p>此时我们就写好了一篇博客，但是我们还需要上传，我们打开 <code>cmd</code>，<code>cd</code> 到你的博客的位置，然后分别输入三行代码：</p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo d</code></p><p>等待一段时间后再回到博客，就可以成功了。</p><p>效果见：<a href="https://venusnero.github.io/2019/01/23/solution_p3644/">Here</a></p><h3 id="文章过长？"><a href="#文章过长？" class="headerlink" title="文章过长？"></a>文章过长？</h3><p>我们会发现，上传博客后往往会在首页将整篇文章的内容都显示出来，这显然是非常占用空间的，此时我们可以在博客的文档中加入一行代码：<code>&lt;!--more--&gt;</code>，然后重新上传，此时在这行代码后面的内容都不会显示出来了，而是改为了一个“$\text{Read More}$”按键，非常方便。</p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123091628.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123091649.png" alt=""></p><p><img src="https://z4a.net/images/2019/01/23/TIM20190123091704.png" alt=""></p><hr><h1 id="博客背景"><a href="#博客背景" class="headerlink" title="博客背景"></a>博客背景</h1><p>进入 <code>\themes\landscape\source\css\images</code>，有一张叫做 <code>banner.jpg/png</code> 的图（不同主题的位置及名字都可能不同），我们将它替换，文件名和后缀名最好都一样，然后按照上面传博客的方法，<code>hexo clean</code>，<code>hexo g</code>，<code>hexo d</code>，等一会儿就上传完成了。</p><hr><p>注意：基本上所有修改完成后都要打一遍 <code>hexo clean</code>，<code>hexo g</code>，<code>hexo d</code>，忘记打就会导致修改在网站上无法生效。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这里只是给出了一些最基础的内容，各位想要更深的研究可以在网上找一些教程，也可以套用现有的主题，难度应该不会很大（当然，如果涉及 $\text{JS}$ 那也不简单了【笑】）。</p><p>参考资料：<a href="https://www.bilibili.com/video/av24897960/" target="_blank" rel="noopener">1</a>  <a href="https://www.jianshu.com/p/68e6f82d88b7" target="_blank" rel="noopener">2</a> <a href="https://blog.csdn.net/dajian790626/article/details/78595684?locationNum=10&amp;fps=1" target="_blank" rel="noopener">3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3644 [APIO2015]八邻旁之桥</title>
      <link href="/2019/01/23/solution_p3644/"/>
      <url>/2019/01/23/solution_p3644/</url>
      
        <content type="html"><![CDATA[<p>$\text{FHQ Treap}$。一开始写的不知道为什么写炸了，还以为不能用，不过后来找了一个 <a href="https://www.cnblogs.com/ppprseter/p/9385979.html" target="_blank" rel="noopener">$\text{dalao}$的博客</a> 重构了一下代码，总算还是过掉了。</p><a id="more"></a><p>如第一篇题解所说，$k=1$ 就直接算，$k=2$ 就枚举一个分割线，左右分别算，不过其实不用建两棵树，而是可以先预处理一下，然后就可以重复使用同一棵树（要清空），数据结构要支持区间插入、中值查询、区间和，线段树似乎不错，但我不知道怎么查中值【流下菜鸡的泪水】，所以还是写了<del>一生所爱</del> $\text{FHQ Treap}$，维护下传一个 $sum$ 标记即可。</p><p>写时为了防止读入字符出错使用了关闭流同步的 <code>cin</code>，同时使用 <code>cout</code> 输出，各位有需要可以自行修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FHQTreap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> son[<span class="number">2</span>],key,siz;</span><br><span class="line">ll val,sum;</span><br><span class="line">&#125;t[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,mid;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;x,<span class="keyword">const</span> Node &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.mid&lt;y.mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="keyword">int</span> k,n,siz,root,tot;</span><br><span class="line">ll ans[MAXN],Ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[x].siz=t[t[x].son[<span class="number">0</span>]].siz+t[t[x].son[<span class="number">1</span>]].siz+<span class="number">1</span>;</span><br><span class="line">t[x].sum=t[t[x].son[<span class="number">0</span>]].sum+t[t[x].son[<span class="number">1</span>]].sum+t[x].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NewNode</span><span class="params">(ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[++siz].siz=<span class="number">1</span>;</span><br><span class="line">t[siz].val=val;</span><br><span class="line">t[siz].key=rand();</span><br><span class="line">t[siz].sum=val;</span><br><span class="line"><span class="keyword">return</span> siz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x+y;</span><br><span class="line"><span class="keyword">if</span>(t[x].key&lt;t[y].key)</span><br><span class="line">&#123;</span><br><span class="line">t[x].son[<span class="number">1</span>]=Merge(t[x].son[<span class="number">1</span>],y);</span><br><span class="line">Update(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">t[y].son[<span class="number">0</span>]=Merge(x,t[y].son[<span class="number">0</span>]);</span><br><span class="line">Update(y);</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> pos,<span class="keyword">int</span> &amp;l,<span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!rt) l=r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(t[rt].val&lt;=pos)</span><br><span class="line">&#123;</span><br><span class="line">l=rt;</span><br><span class="line">Split(t[rt].son[<span class="number">1</span>],pos,t[rt].son[<span class="number">1</span>],r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r=rt;</span><br><span class="line">Split(t[rt].son[<span class="number">0</span>],pos,l,t[rt].son[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">Update(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=t[t[rt].son[<span class="number">0</span>]].siz) rt=t[rt].son[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pos==t[t[rt].son[<span class="number">0</span>]].siz+<span class="number">1</span>) <span class="keyword">return</span> t[rt].val;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pos-=t[t[rt].son[<span class="number">0</span>]].siz+<span class="number">1</span>;</span><br><span class="line">rt=t[rt].son[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">Split(root,val,x,y);</span><br><span class="line">root=Merge(Merge(x,NewNode(val)),y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">ll sum=t[root].siz/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line">Split(root,val<span class="number">-1</span>,x,y);</span><br><span class="line">res=t[x].sum*<span class="number">2</span>+val*(sum-t[x].siz)*<span class="number">2</span>;</span><br><span class="line">root=Merge(x,y);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">CalcMid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll rk=FindKth(root,t[root].siz/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> t[root].sum-Query(rk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;k&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">char</span> opt1,opt2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;opt1&gt;&gt;x&gt;&gt;opt2&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(x&gt;y) swap(x,y);</span><br><span class="line"><span class="keyword">if</span>(opt1==opt2) Ans+=y-x;</span><br><span class="line"><span class="keyword">else</span> a[++tot]=((Node)&#123;x,y,x+y&#125;);</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+tot+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">&#123;</span><br><span class="line">Insert(a[i].l);</span><br><span class="line">Insert(a[i].r);</span><br><span class="line">ans[i]=CalcMid();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;ans[tot]+Ans+tot&lt;&lt;<span class="built_in">endl</span>,<span class="number">0</span>;</span><br><span class="line">ll cnt=ans[tot];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=siz;i++) t[i].son[<span class="number">0</span>]=t[i].son[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">root=siz=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=tot;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">Insert(a[i].l);</span><br><span class="line">Insert(a[i].r);</span><br><span class="line">cnt=min(cnt,ans[i<span class="number">-1</span>]+CalcMid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;cnt+Ans+tot&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> FHQTreap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分瞎入门</title>
      <link href="/2019/01/22/Tree_Split_Train/"/>
      <url>/2019/01/22/Tree_Split_Train/</url>
      
        <content type="html"><![CDATA[<p><del>本文旨在让读者背代码</del></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在做题时，我们可能会遇到这样一类问题：</p><blockquote><p>给定一棵 $n$ 个结点的树和 $m$ 次操作，操作有两种，一种是给定两个结点，让连接两个结点的路径上的所有点权值加上一个值，另一种是查询路径上所有点的权值和。$n\le 1e5$，$m\le 2e5$。</p></blockquote><p>如果是最后统一输出结点权值，用树上差分+$\text{DFS}$ 就能轻松水过，而对于在线查询，如果数据范围小的话暴力即可 $\text{AC}$，时间复杂度 $\text{O}(nm)$，但是很明显，这个数据范围肯定不能这么写了。此时，就需要树链剖分出场了。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=496869422&auto=1&height=66"></iframe><a id="more"></a><h1 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>树链剖分是根据轻重儿子，将一棵树剖成多条链，然后就可以用数据结构来维护这些链了，听着似乎还是有点像暴力，不过因为一条链有多个结点，所以可以优化时间复杂度。</p><p>至于轻重儿子的定义，请见下一块。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>既然要把树剖成一堆链，那么我们就要有一种标准来剖这棵树，树链剖分的标准是什么呢？我们定义：一个结点的所有子树中，<strong>结点数最多的子树的根节点</strong>是这个结点的“重儿子”，比如下面这张图中，红点就是蓝点的重儿子。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fz0h5yjtv0j30e50c3746.jpg" alt=""></p><p>递归进行这个过程，我们可以得到一堆的“重儿子”，将这些重儿子连起来，我们就会得到一根“重链”，最后对整棵树完成这个过程后，我们就将一棵树剖成了若干个“重链”。</p><p>剖完之后，还有一些点，它们则称为“轻儿子”，一些轻边连成的链则称为轻链。（然而这个并没有什么卵用）</p><p>此时我们已经剖完了树，我们就要考虑怎么维护这些链了。在说怎么维护之前，我们先把怎么剖用代码的方式表示出来。</p><p>对于树链剖分，我们需要维护以下的数组：</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">$siz[u]$</td><td style="text-align:center">以 $u$ 为根的子树的结点个数</td></tr><tr><td style="text-align:center">$son[u]$</td><td style="text-align:center">$u$ 的重儿子的编号</td></tr><tr><td style="text-align:center">$top[u]$</td><td style="text-align:center">$u$ 所在链的深度最小的结点编号</td></tr><tr><td style="text-align:center">$dep[u]$</td><td style="text-align:center">$u$ 的深度</td></tr><tr><td style="text-align:center">$faz[u]$</td><td style="text-align:center">$u$ 的父亲的编号</td></tr><tr><td style="text-align:center">$dfn[u]$</td><td style="text-align:center">$u$ 的 $\text{DFS}$ 序</td></tr><tr><td style="text-align:center">$rk[u]$</td><td style="text-align:center">$u$ 树中的编号</td></tr></tbody></table></div><p>注：每个轻儿子的 $top$ 就是它本身。</p><p>首先，因为我们在 $\text{DFS}$ 时应该先往重儿子搜索，所以一个 $\text{DFS}$ 肯定是不能完成任务，所以我们需要两个 $\text{DFS}$ 函数。</p><p>这两个 $\text{DFS}$ 函数分别完成什么呢？</p><p>$\text{Dfs1}$：预处理 $siz$，$son$，$dep$，$faz$ 数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">Dfs1(v);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[v]&gt;siz[son[u]]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\text{Dfs2}$：预处理 $dfn$，$top$，$rk$ 数组。其中 $rk$ 数组有的时候用不到，在部分题目中可以省略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u]=++Index;</span><br><span class="line">rk[Index]=u;</span><br><span class="line">top[u]=rt;</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：$\text{Dfs1}$ 没有什么好注意的，$\text{Dfs2}$ 的时候记得先往重儿子搜，至于为什么？</p><h2 id="维护链"><a href="#维护链" class="headerlink" title="维护链"></a>维护链</h2><h3 id="text-DFS-序"><a href="#text-DFS-序" class="headerlink" title="$\text{DFS}$ 序"></a>$\text{DFS}$ 序</h3><p>首先讲一下，为什么要先搜重儿子。因为我们要维护的是重链，而一条链的要求必须是连续的，而我们维护时使用数据结构，必然是要将它转换到数列上来做的，如何转换呢？最好的方法就是按照 $\text{DFS}$ 序，此时如果不先搜重儿子的话，重链上的 $\text{DFS}$ 序就可能会断掉，如下图（橙、绿线是 $\text{DFS}$ 搜索顺序）：</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fz0hrjunzpj30el0cogll.jpg" alt=""></p><p>这条链的 $\text{DFS}$ 序就断开了，此时就无法用数据结构去维护了。</p><h3 id="如何维护"><a href="#如何维护" class="headerlink" title="如何维护"></a>如何维护</h3><p>这一节很简单，没什么好讲的，因为要维护的是链，而且我们现在已经保证链上的 $\text{DFS}$ 序连续了，所以我们直接取结点的 $top$ 到它自己这一段进行修改或查询（即使用 $\text{DFS}$ 序修改），然后再将当前结点跳到它 $top$ 的 $faz$ 即可。为了防止一个结点无限往上跳，我们先选 $top$ 比较深的那个结点进行修改/查询，再往上跳，就可以防止无限跳的情况了。而如果选的是浅的，而它又往上跳，则深度越来越浅，必然会无限跳，最终死循环。</p><p>最后，这两个结点一定会到一条链上，而且必然有一个点会是 $\text{LCA}$，我们最后进行一次操作即可。</p><p>至于为什么是跳到 $top$ 的 $faz$，因为 $top$ 已经被修改/查询过了，跳到上一个结点防止重复操作。</p><p>修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u],val);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[v],val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询（根据求和、求最小值、求最大值修改，仅给出求和）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res+=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">res+=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[v]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于其中的 $\text{Modify}$ 和 $\text{Query}$ 函数，根据不同的需求和使用的数据结构的不同，应自行修改。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="P3384-【模板】树链剖分"><a href="#P3384-【模板】树链剖分" class="headerlink" title="P3384 【模板】树链剖分"></a>P3384 【模板】树链剖分</h2><p><a href="https://www.luogu.org/problemnew/show/P3384" target="_blank" rel="noopener">链接</a></p><p>操作涉及区间加、区间和、子树加、子树和，区间的两种操作直接用线段树配合上面的模板可以轻松过去，而子树加和子树和这两个新操作呢？其实更简单。我们知道，一个子树的 $\text{DFS}$ 序必然是连续的，所以我们直接对 $dfn[x]$ 到 $dfn[x]+siz[x]-1$ 这个序列进行区间加、区间和的操作即可，使用线段树即可无脑水过。</p><p>代码因为年代久远，码风太丑，不贴了。</p><p><strong>重要注意点：</strong>子树操作在 $\text{PushDown}$ 传 $tag$ 的时候，对 $sum$ 的加需要乘上区间长度的一半，切记。</p><h2 id="P2590-ZJOI2008-树的统计"><a href="#P2590-ZJOI2008-树的统计" class="headerlink" title="P2590 [ZJOI2008]树的统计"></a>P2590 [ZJOI2008]树的统计</h2><p><a href="https://www.luogu.org/problemnew/show/P2590" target="_blank" rel="noopener">链接</a></p><p>操作涉及单点修改、区间最大值、区间和，无脑水过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 2147400000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN],to[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,Q,a[MAXN&gt;&gt;<span class="number">1</span>],Index,sum[MAXN&lt;&lt;<span class="number">2</span>],maxn[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> siz[MAXN],son[MAXN],faz[MAXN],dep[MAXN],top[MAXN],rk[MAXN],id[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">Dfs1(v,u);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[v]&gt;siz[son[u]]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">id[u]=++Index;</span><br><span class="line">rk[Index]=u;</span><br><span class="line">top[u]=rt;</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[rt]=sum[rt&lt;&lt;<span class="number">1</span>]+sum[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">maxn[rt]=max(maxn[rt&lt;&lt;<span class="number">1</span>],maxn[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">sum[rt]=maxn[rt]=a[rk[l]];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">sum[rt]=maxn[rt]=val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid) Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,pos,val);</span><br><span class="line"><span class="keyword">else</span> Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuerySum</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> sum[rt];</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res+=QuerySum(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res+=QuerySum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line">PushUp(rt);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMaxn</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> maxn[rt];</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=-inf;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res=max(res,QueryMaxn(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res=max(res,QueryMaxn(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line">PushUp(rt);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuerySumOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res+=QuerySum(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v]) swap(u,v);</span><br><span class="line">res+=QuerySum(<span class="number">1</span>,<span class="number">1</span>,n,id[v],id[u]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMaxOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=-inf;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res=max(res,QueryMaxn(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u]));</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v]) swap(u,v);</span><br><span class="line">res=max(res,QueryMaxn(<span class="number">1</span>,<span class="number">1</span>,n,id[v],id[u]));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">AddEdge(x,y);</span><br><span class="line">AddEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">dep[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">faz[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">Dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Q);</span><br><span class="line"><span class="keyword">while</span>(Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">string</span> opt;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;opt&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="string">"CHANGE"</span>) Modify(<span class="number">1</span>,<span class="number">1</span>,n,id[x],y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="string">"QMAX"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QueryMaxOnTree(x,y));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="string">"QSUM"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QuerySumOnTree(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P3178-HAOI2015-树上操作"><a href="#P3178-HAOI2015-树上操作" class="headerlink" title="P3178 [HAOI2015]树上操作"></a>P3178 [HAOI2015]树上操作</h2><p><a href="https://www.luogu.org/problemnew/show/P3178" target="_blank" rel="noopener">链接</a></p><p>操作涉及单点加、子树加、区间和，依然无脑水过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,Q;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN],Index,top[MAXN],faz[MAXN],dep[MAXN],siz[MAXN],son[MAXN];</span><br><span class="line">ll t[MAXN&lt;&lt;<span class="number">2</span>],tag[MAXN&lt;&lt;<span class="number">2</span>],rk[MAXN],a[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">Dfs1(v);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u]=++Index;</span><br><span class="line">rk[Index]=a[u];</span><br><span class="line">top[u]=rt;</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[rt]=t[rt&lt;&lt;<span class="number">1</span>]+t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt,ll len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag[rt])</span><br><span class="line">&#123;</span><br><span class="line">tag[rt&lt;&lt;<span class="number">1</span>]+=tag[rt];</span><br><span class="line">tag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=tag[rt];</span><br><span class="line">t[rt&lt;&lt;<span class="number">1</span>]+=tag[rt]*(len-(len&gt;&gt;<span class="number">1</span>));</span><br><span class="line">t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=tag[rt]*(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">tag[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt]=rk[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr,ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr)</span><br><span class="line">&#123;</span><br><span class="line">tag[rt]+=val;</span><br><span class="line">t[rt]+=<span class="number">1l</span>l*val*(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PushDown(rt,r-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr,val);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr,val);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line">PushDown(rt,r-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res+=Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res+=Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">QueryOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res+=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">res+=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[v]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;Q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">AddEdge(x,y);</span><br><span class="line">AddEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">Dfs1(<span class="number">1</span>);</span><br><span class="line">Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> opt;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;opt);</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,QueryOnTree(<span class="number">1</span>,x));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4315-月下“毛景树”"><a href="#P4315-月下“毛景树”" class="headerlink" title="P4315 月下“毛景树”"></a>P4315 月下“毛景树”</h2><p><a href="https://www.luogu.org/problemnew/show/P4315" target="_blank" rel="noopener">链接</a></p><p>操作涉及单点覆盖、区间覆盖、区间加、区间最大值，本来应该是无脑水过，但是因为要将边权转成点权，然后忽略掉 $\text{LCA}$，还是有点难度，具体解析见：<a href="https://www.luogu.org/blog/Venus/solution-p4315" target="_blank" rel="noopener">题解 P4315 【月下“毛景树”】</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>],w[MAXN&lt;&lt;<span class="number">1</span>],fr[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,a[MAXN],t[MAXN&lt;&lt;<span class="number">2</span>],tag[MAXN&lt;&lt;<span class="number">2</span>],cov[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> siz[MAXN],son[MAXN],dfn[MAXN],Index,top[MAXN],rk[MAXN],dep[MAXN],faz[MAXN];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++cnt]=v;</span><br><span class="line">    nxt[cnt]=fst[u];</span><br><span class="line">    fst[u]=cnt;</span><br><span class="line">    w[cnt]=c;</span><br><span class="line">    fr[cnt]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    son[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">        faz[v]=u;</span><br><span class="line">        dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">        rk[v]=w[i];</span><br><span class="line">        Dfs1(v);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=++Index;</span><br><span class="line">    top[u]=rt;</span><br><span class="line">    a[Index]=rk[u];</span><br><span class="line">    <span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        Dfs2(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[rt]=max(t[rt&lt;&lt;<span class="number">1</span>],t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(~cov[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        cov[rt&lt;&lt;<span class="number">1</span>]=cov[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=cov[rt];</span><br><span class="line">        t[rt&lt;&lt;<span class="number">1</span>]=t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=cov[rt];</span><br><span class="line">        tag[rt&lt;&lt;<span class="number">1</span>]=tag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        cov[rt]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tag[rt&lt;&lt;<span class="number">1</span>]+=tag[rt];</span><br><span class="line">    tag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=tag[rt];</span><br><span class="line">    t[rt&lt;&lt;<span class="number">1</span>]+=tag[rt];</span><br><span class="line">    t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=tag[rt];</span><br><span class="line">    tag[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cov[rt]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt]=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyCover</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt]=cov[rt]=val;</span><br><span class="line">        tag[rt]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=mid) ModifyCover(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr,val);</span><br><span class="line">    <span class="keyword">if</span>(tr&gt;mid) ModifyCover(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr,val);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyAdd</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt]+=val;</span><br><span class="line">        tag[rt]+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=mid) ModifyAdd(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr,val);</span><br><span class="line">    <span class="keyword">if</span>(tr&gt;mid) ModifyAdd(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr,val);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line">    PushDown(rt);</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=mid) res=max(res,Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line">    <span class="keyword">if</span>(tr&gt;mid) res=max(res,Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyCoverOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">        ModifyCover(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u],val);</span><br><span class="line">        u=faz[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">    ModifyCover(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v],val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyAddOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">        ModifyAdd(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u],val);</span><br><span class="line">        u=faz[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">    ModifyAdd(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v],val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMaxnOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">        res=max(res,Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]));</span><br><span class="line">        u=faz[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">    res=max(res,Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        AddEdge(x,y,z);</span><br><span class="line">        AddEdge(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    Dfs1(<span class="number">1</span>);</span><br><span class="line">    Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">"Stop"</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="string">"Change"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> u=fr[x],v=to[x];</span><br><span class="line">                <span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">                ModifyCoverOnTree(u,v,y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"Cover"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;z);</span><br><span class="line">                ModifyCoverOnTree(x,y,z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"Add"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;z);</span><br><span class="line">                ModifyAddOnTree(x,y,z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"Max"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QueryMaxnOnTree(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4114-Qtree1"><a href="#P4114-Qtree1" class="headerlink" title="P4114 Qtree1"></a>P4114 Qtree1</h2><p><a href="https://www.luogu.org/problemnew/show/P4114" target="_blank" rel="noopener">链接</a></p><p>和上一题一样，边权转点权，无脑操作即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>],w[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,a[MAXN],t[MAXN&lt;&lt;<span class="number">2</span>],fr[MAXN],tx[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN],Index,faz[MAXN],siz[MAXN],son[MAXN],dep[MAXN],top[MAXN],rk[MAXN];</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++cnt]=v;</span><br><span class="line">    nxt[cnt]=fst[u];</span><br><span class="line">    fst[u]=cnt;</span><br><span class="line">    w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    son[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">        faz[v]=u;</span><br><span class="line">        a[v]=w[i];</span><br><span class="line">        Dfs1(v);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]]) son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=++Index;</span><br><span class="line">    rk[Index]=u;</span><br><span class="line">    top[u]=rt;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        Dfs2(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[rt]=max(t[rt&lt;&lt;<span class="number">1</span>],t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt]=a[rk[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[rt]=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=mid) Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,pos,val);</span><br><span class="line">    <span class="keyword">else</span> Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">    PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tl&lt;=mid) res=max(res,Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line">    <span class="keyword">if</span>(tr&gt;mid) res=max(res,Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">        res=max(res,Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]));</span><br><span class="line">        u=faz[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">    res=max(res,Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">int</span> z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %intd"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        fr[i]=x;</span><br><span class="line">        tx[i]=y;</span><br><span class="line">        AddEdge(x,y,z);</span><br><span class="line">        AddEdge(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    Dfs1(<span class="number">1</span>);</span><br><span class="line">    Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ch[<span class="number">1</span>]==<span class="string">'D'</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span>(ch[<span class="number">1</span>]==<span class="string">'Q'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QueryOnTree(x,y));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t=dep[fr[x]]&gt;dep[tx[x]]?fr[x]:tx[x];</span><br><span class="line">                Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[t],y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1505-国家集训队-旅游"><a href="#P1505-国家集训队-旅游" class="headerlink" title="P1505 [国家集训队]旅游"></a>P1505 [国家集训队]旅游</h2><p><a href="https://www.luogu.org/problemnew/show/P1505" target="_blank" rel="noopener">链接</a></p><p>最后一道，来道毒瘤的，操作涉及单点修改，区间取相反数，区间和，区间最大值，区间最小值，其他的都简单，就是区间取相反数较难，我们在取相反时，将最大值和最小值<strong>交换</strong>，然后将和、最大值、最小值全部乘上 $-1$ 就行，码量较大，耐心码耐心调还是可以比较轻松的 $\text{A}$ 掉的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>],w[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,Q,a[MAXN],t[MAXN&lt;&lt;<span class="number">2</span>],tag[MAXN&lt;&lt;<span class="number">2</span>],maxn[MAXN&lt;&lt;<span class="number">2</span>],minx[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> siz[MAXN],son[MAXN],top[MAXN],dep[MAXN],faz[MAXN],dfn[MAXN],Index,rk[MAXN];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">w[cnt]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">rk[v]=w[i];</span><br><span class="line">Dfs1(v);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">top[u]=rt;</span><br><span class="line">dfn[u]=++Index;</span><br><span class="line">a[Index]=rk[u];</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[rt]=t[rt&lt;&lt;<span class="number">1</span>]+t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">maxn[rt]=max(maxn[rt&lt;&lt;<span class="number">1</span>],maxn[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">minx[rt]=min(minx[rt&lt;&lt;<span class="number">1</span>],minx[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag[rt])</span><br><span class="line">&#123;</span><br><span class="line">t[rt&lt;&lt;<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">tag[rt&lt;&lt;<span class="number">1</span>]^=<span class="number">1</span>;</span><br><span class="line">tag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]^=<span class="number">1</span>;</span><br><span class="line">swap(maxn[rt&lt;&lt;<span class="number">1</span>],minx[rt&lt;&lt;<span class="number">1</span>]);</span><br><span class="line">swap(maxn[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],minx[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">maxn[rt&lt;&lt;<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">minx[rt&lt;&lt;<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">maxn[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">minx[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]*=<span class="number">-1</span>;</span><br><span class="line">tag[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt]=maxn[rt]=minx[rt]=a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyPoint</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt]=maxn[rt]=minx[rt]=val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PushDown(rt);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid) ModifyPoint(rt&lt;&lt;<span class="number">1</span>,l,mid,pos,val);</span><br><span class="line"><span class="keyword">else</span> ModifyPoint(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,val);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyNega</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr)</span><br><span class="line">&#123;</span><br><span class="line">t[rt]*=<span class="number">-1</span>;</span><br><span class="line">tag[rt]^=<span class="number">1</span>;</span><br><span class="line">swap(maxn[rt],minx[rt]);</span><br><span class="line">maxn[rt]*=<span class="number">-1</span>;</span><br><span class="line">minx[rt]*=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PushDown(rt);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) ModifyNega(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) ModifyNega(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line">PushUp(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuerySum</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line">PushDown(rt);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res+=QuerySum(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res+=QuerySum(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMaxn</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> maxn[rt];</span><br><span class="line">PushDown(rt);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">-2e9</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res=max(res,QueryMaxn(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res=max(res,QueryMaxn(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMinx</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> minx[rt];</span><br><span class="line">PushDown(rt);</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=mid) res=min(res,QueryMinx(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr));</span><br><span class="line"><span class="keyword">if</span>(tr&gt;mid) res=min(res,QueryMinx(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyToNegative</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">ModifyNega(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">ModifyNega(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuerySumOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res+=QuerySum(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">res+=QuerySum(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMaxnOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">-2e9</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res=max(res,QueryMaxn(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]));</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">res=max(res,QueryMaxn(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueryMinxOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) swap(u,v);</span><br><span class="line">res=min(res,QueryMinx(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]));</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">res=min(res,QueryMinx(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">AddEdge(x+<span class="number">1</span>,y+<span class="number">1</span>,z);</span><br><span class="line">AddEdge(y+<span class="number">1</span>,x+<span class="number">1</span>,z);</span><br><span class="line">&#125;</span><br><span class="line">Dfs1(<span class="number">1</span>);</span><br><span class="line">Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Q);</span><br><span class="line"><span class="keyword">while</span>(Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">"C"</span>) ModifyPoint(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x+<span class="number">1</span>],y);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"N"</span>) ModifyToNegative(x+<span class="number">1</span>,y+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"SUM"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QuerySumOnTree(x+<span class="number">1</span>,y+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"MAX"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QueryMaxnOnTree(x+<span class="number">1</span>,y+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"MIN"</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,QueryMinxOnTree(x+<span class="number">1</span>,y+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P3613-睡觉困难综合征"><a href="#P3613-睡觉困难综合征" class="headerlink" title="P3613 睡觉困难综合征"></a>P3613 睡觉困难综合征</h2><p><a href="https://www.luogu.org/problemnew/show/P3613" target="_blank" rel="noopener">链接</a></p><p>这道题是真的难了，首先观察原版 <a href="https://www.luogu.org/problemnew/show/P2114" target="_blank" rel="noopener"><code>P2114 [NOI2014]起床困难综合症</code></a> 的做法，用一个每一个二进制位都是 $0$ 数（即 $0$）和一个每一个二进制位都是 $1$ 的数（即 $2^{31}-1$）跑一遍，然后从高位贪心选，这道题的核心思想也是这样的，线段树记录的是每一段路径上，$0$ 和 $1$ 分别从左往右跑和从右往左跑最终的结果。显然，我们每一个二进制位都要维护一个值，这样的时间复杂度显然是 $\text{O}(nklog^2n)$，即树链剖分的时间复杂度乘上每次计算二进制位的结果的时间复杂度，虽然看着不大，但是因为有一个 $log^2n$，以及时限只有 $0.5s$，而且出题人又是那个谁谁谁，这个复杂度就算是卡常也过不去，此时我们就要想办法优化了。</p><p>观察时间复杂度，$nlog^2n$ 是树剖的基础时间复杂度，怎么优化都是优化不掉的，我们考虑优化掉那个 $k$，我们现在算结果是一位一位算的，所以是 $\text{O}(k)$，那么有没有方法在 $\text{O}(1)$ 的时间复杂度内就把结果算出来呢？其实是有的<del>，只是我不会证，看不懂</del>。</p><p>总而言之就是：</p><p>$now.T0=((L.T0 and R.T1) or ((not L.T0) and R.T0))$</p><p>$now.T1=((L.T1 and R.T1) or ((not L.T1) and R.T0))$</p><p>其中 $now$ 是当前结点，$L$ 是左儿子，$R$ 是右儿子，$T$ 是类型，即从左往右或从右往左，当然，在计算从右往左的时候要把 <strong>所有 $L$ 和 $R$ 反过来</strong>，毕竟是反的嘛。</p><p>按照这个式子，我们可以写出一个计算的函数，然后就可以建线段树了。当然，事情还没有完，因为在树上查询的时候，我们原来是两边交替往上跳，但是因为这道题，方向不同结果也不同，比如 $u-v$ 这条路径，一般走法应该是 $u-lca$，$lca-v$，但是在平时树剖的过程中，就可能是 $u-lca$，$v-lca$，一般是没有影响的，但是这题涉及了位运算，操作乱序结果显然会不同，所以我们要分别跳，对于不同的情况存在两个不同的序列里，然后最后把其中一个序列的从左往右从右往左交换一下，最后再做位运算跑贪心。</p><p>记得开 $\text{unsigned long long}$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> ull MAXULL=<span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ull l0,l1,r0,r1;</span><br><span class="line">&#125;t[MAXN&lt;&lt;<span class="number">2</span>],ans1[MAXN],ans2[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt,fst[MAXN],nxt[MAXN&lt;&lt;<span class="number">1</span>],to[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,Q,K,opt[MAXN],tot1,tot2;</span><br><span class="line"><span class="keyword">int</span> siz[MAXN],son[MAXN],dfn[MAXN],Index,dep[MAXN],faz[MAXN],top[MAXN],rk[MAXN];</span><br><span class="line">ull a[MAXN];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fu=<span class="number">1</span>;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);ch=getchar()) <span class="keyword">if</span>(ch==<span class="string">'-'</span>) fu=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);ch=getchar()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch<span class="number">-48</span>);</span><br><span class="line">x*=fu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">to[++cnt]=v;</span><br><span class="line">nxt[cnt]=fst[u];</span><br><span class="line">fst[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[u]=<span class="number">1</span>;</span><br><span class="line">son[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u]) <span class="keyword">continue</span>;</span><br><span class="line">faz[v]=u;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">Dfs1(v);</span><br><span class="line">siz[u]+=siz[v];</span><br><span class="line"><span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u]=++Index;</span><br><span class="line">rk[Index]=u;</span><br><span class="line">top[u]=rt;</span><br><span class="line"><span class="keyword">if</span>(son[u]) Dfs2(son[u],rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=fst[u];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(v==faz[u] || v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">Dfs2(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">Calc</span><span class="params">(ull x,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> opt[rt]==<span class="number">1</span>?x&amp;a[rt]:(opt[rt]==<span class="number">2</span>?x|a[rt]:x^a[rt]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">CalcNode</span><span class="params">(Node x,Node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node res;</span><br><span class="line">res.l0=((x.l0&amp;y.l1)|(((~x.l0)&amp;y.l0)));</span><br><span class="line">res.l1=((x.l1&amp;y.l1)|(((~x.l1)&amp;y.l0)));</span><br><span class="line">res.r0=((y.r0&amp;x.r1)|(((~y.r0)&amp;x.r0)));</span><br><span class="line">res.r1=((y.r1&amp;x.r1)|(((~y.r1)&amp;x.r0)));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildSegmentTree</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt].l0=t[rt].r0=Calc(<span class="number">0</span>,rk[l]);</span><br><span class="line">t[rt].l1=t[rt].r1=Calc(MAXULL,rk[l]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">BuildSegmentTree(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">t[rt]=CalcNode(t[rt&lt;&lt;<span class="number">1</span>],t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[rt].l0=t[rt].r0=Calc(<span class="number">0</span>,rk[l]);</span><br><span class="line">t[rt].l1=t[rt].r1=Calc(MAXULL,rk[l]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&gt;=pos) Modify(rt&lt;&lt;<span class="number">1</span>,l,mid,pos);</span><br><span class="line"><span class="keyword">else</span> Modify(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos);</span><br><span class="line">t[rt]=CalcNode(t[rt&lt;&lt;<span class="number">1</span>],t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">Query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tl&lt;=l &amp;&amp; r&lt;=tr) <span class="keyword">return</span> t[rt];</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">Node res;</span><br><span class="line"><span class="keyword">if</span>(tr&lt;=mid) res=Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tl&gt;mid) res=Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr);</span><br><span class="line"><span class="keyword">else</span> res=CalcNode(Query(rt&lt;&lt;<span class="number">1</span>,l,mid,tl,tr),Query(rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,tl,tr));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">QueryOnTree</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node res;</span><br><span class="line">tot1=tot2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&gt;=dep[top[v]])</span><br><span class="line">&#123;</span><br><span class="line">ans1[++tot1]=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[u]],dfn[u]);</span><br><span class="line">u=faz[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans2[++tot2]=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[top[v]],dfn[v]);</span><br><span class="line">v=faz[top[v]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) ans1[++tot1]=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[v],dfn[u]);</span><br><span class="line"><span class="keyword">else</span> ans2[++tot2]=Query(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[v]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot1;i++)</span><br><span class="line">&#123;</span><br><span class="line">swap(ans1[i].l0,ans1[i].r0);</span><br><span class="line">swap(ans1[i].l1,ans1[i].r1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tot1)</span><br><span class="line">&#123;</span><br><span class="line">res=ans1[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=tot1;i++) res=CalcNode(res,ans1[i]);</span><br><span class="line"><span class="keyword">if</span>(tot2) res=CalcNode(res,ans2[tot2]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> res=ans2[tot2];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=tot2<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) res=CalcNode(res,ans2[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Read(n);</span><br><span class="line">Read(Q);</span><br><span class="line">Read(K);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Read(opt[i]);</span><br><span class="line">Read(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">AddEdge(x,y);</span><br><span class="line">AddEdge(y,x);</span><br><span class="line">&#125;</span><br><span class="line">Dfs1(<span class="number">1</span>);</span><br><span class="line">Dfs2(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">BuildSegmentTree(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(Q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> Opt;</span><br><span class="line">ull x,y,z;</span><br><span class="line">Read(Opt);</span><br><span class="line">Read(x);</span><br><span class="line">Read(y);</span><br><span class="line">Read(z);</span><br><span class="line"><span class="keyword">if</span>(Opt==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Node res=QueryOnTree(x,y);</span><br><span class="line">ull ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">63</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">ull l=(res.l0&gt;&gt;i)&amp;<span class="number">1u</span>ll,r=(res.l1&gt;&gt;i)&amp;<span class="number">1u</span>ll;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r || (<span class="number">1u</span>ll&lt;&lt;i)&gt;z)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l) ans|=(<span class="number">1u</span>ll&lt;&lt;i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(r) ans|=(<span class="number">1u</span>ll&lt;&lt;i);</span><br><span class="line">z-=(<span class="number">1u</span>ll&lt;&lt;i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%llu\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Opt==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">opt[x]=y;</span><br><span class="line">a[x]=z;</span><br><span class="line">Modify(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><del>无。</del></p><p>树链剖分是树上操作强大的工具，配合着数据结构对大部分操作有奇效，需要认真学习巩固。</p><p>$\text{FIN.}$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX 测试</title>
      <link href="/2019/01/22/text_of_latex/"/>
      <url>/2019/01/22/text_of_latex/</url>
      
        <content type="html"><![CDATA[<script type="math/tex; mode=display">\max{(S)}=\sum_{T\subseteq S}^{}(-1)^{|T|-1}\min{(T)}</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello the Cruel World</title>
      <link href="/2019/01/22/hello-world/"/>
      <url>/2019/01/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这里是我的新博客，平时随缘更新，望关注【笑</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
