{"meta":{"title":"Venus' Blog","subtitle":null,"description":null,"author":"Venus","url":"http://VenusNero.github.io"},"pages":[],"posts":[{"title":"珂朵莉树（ODT）学习笔记","slug":"chtholly_tree_note","date":"2019-01-23T06:07:41.695Z","updated":"2019-01-23T08:28:10.652Z","comments":true,"path":"2019/01/23/chtholly_tree_note/","link":"","permalink":"http://VenusNero.github.io/2019/01/23/chtholly_tree_note/","excerpt":"前言珂朵莉树是一种强大但是限制较多的高级数据结构，它能够解决大部分带有区间覆盖操作的题目，同时可以解决独一无二的 $\\sum_{i=l}^{r}a[i]^k\\%p$ 操作。","text":"前言珂朵莉树是一种强大但是限制较多的高级数据结构，它能够解决大部分带有区间覆盖操作的题目，同时可以解决独一无二的 $\\sum_{i=l}^{r}a[i]^k\\%p$ 操作。 原理珂朵莉树的原理是使用 $\\text{set}$ 维护若干个区间，这些区间的值都相同，而我们要记录的就是这个值，同时使用一个非常神奇的东西：$\\text{mutable}$ 来非常方便地修改区间的值。 同时，珂朵莉树必须要保证两个条件，一是有区间覆盖，因为这才能把多个区间合成一个区间，二是保证数据随机，否则是可以卡的，不然就和暴力没什么区别了。 至于区间的存储方式，只要存储左右位置和区间的值就行了，因为区间的值一定是相同的。 123456789struct Node&#123; int l,r; mutable int val; bool operator &lt; (const Node &amp;x) const &#123; return l&lt;x.l; &#125;&#125;; 而这个 $\\text{mutable}$ 起到什么作用呢？因为在正常情况下，$\\text{set}$ 中的元素是没法直接修改的，但是加了这个 $\\text{mutable}$ 之后，就可以随时修改这个值了，就算是 $\\text{set}$ 中的 $\\text{Node}$ 的 $val$ 也能直接修改。 操作珂朵莉树的核心操作只有两个，一个是 $\\text{Split}$，即按照给出的位置将序列在此处断开，然后用迭代器存下断开位置的区间，如下图所示。 显然，我们在区间操作时，只需要对这个区间的两端分别 $\\text{Split}$ 一下，就可以操作了。 1234567891011#define iter set &lt;Node&gt;::iteratoriter Split(int pos)&#123; iter it=s.lower_bound((Node)&#123;pos,pos,-1&#125;); if(it!=s.end() &amp;&amp; it-&gt;l==pos) return it; it--; Node x=*it; s.erase(it); s.insert((Node)&#123;x.l,pos-1,x.val&#125;); return s.insert((Node)&#123;pos,x.r,x.val&#125;).first;&#125; 下一个核心操作是 $\\text{Assign}$，也就是“区间推平”，说白了就是区间赋值，这也是珂朵莉树把多个区间变成一个区间的关键，做法很简单，左右 $\\text{Split}$ 一下，然后再创建一个新的区间就行了。 注意：在 $\\text{Split}$ 时，右侧端点要 $+1$，否则 $r$ 会被分到后面那个区间里面去，这点应该是很显而易见的。 123456void Assign(int l,int r,int val)&#123; iter R=Split(r+1),L=Split(l); s.erase(L,R); s.insert((Node)&#123;l,r,val&#125;);&#125; 其他的操作就都非常暴力了，左右 $\\text{Split}$ 一下，然后用迭代器从左边扫到右边，暴力处理即可。 例题给出一道最经典的珂朵莉树例题。 CF896C Willem, Chtholly and Seniorious链接 操作涉及区间加、区间赋值、区间 $k$ 大值、区间 $x$ 次方和问题，前两个都很简单，区间加用上面给出的方法，左右 $\\text{Split}$，然后大力处理即可，区间赋值直接 $\\text{Assign}$。区间 $x$ 次方和这个也不难，写一个快速幂函数，依然大力处理就行。 区间加： 12345void Modify(ll l,ll r,ll val)&#123; iter R=Split(r+1),L=Split(l); for(iter it=L;it!=R;it++) it-&gt;val+=val;&#125; 区间 $x$ 次方和： 1234567ll Query(ll l,ll r,ll x,ll y)&#123; iter R=Split(r+1),L=Split(l); ll res=0; for(iter it=L;it!=R;it++) res=(res+1ll*(it-&gt;r-it-&gt;l+1)*QuickPow(it-&gt;val,x,y))%y; return res;&#125; 区间 $k$ 大值就比较烦了，我们多开一个 $\\text{vector}$，左右 $\\text{Split}$ 一下，然后从左往右扫，记录一下区间的长度和值，然后把它按值排个序，从头扫到尾，中途累加一下长度，当累加的长度 $≥k$ 时就可以返回当前区间的值了。 1234567891011121314ll FindKth(ll l,ll r,ll k)&#123; vec.clear(); iter R=Split(r+1),L=Split(l); for(iter it=L;it!=R;it++) vec.push_back((Segment)&#123;it-&gt;r-it-&gt;l+1,it-&gt;val&#125;); sort(vec.begin(),vec.end()); ll sum=0; for(vit=vec.begin();vit!=vec.end();vit++) &#123; sum+=vit-&gt;len; if(sum&gt;=k) return vit-&gt;val; &#125; return -1;&#125; 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;#define MAXN 100005#define ll long long#define iter set&lt;Node&gt;::iteratorusing namespace std;struct Node&#123; ll l,r; mutable ll val; bool operator &lt; (const Node &amp;x) const &#123; return l&lt;x.l; &#125;&#125;;set &lt;Node&gt; s;int n,m;ll seed,vmax,a[MAXN];ll rnd()&#123; ll ret=seed; seed=(seed*7+13)%1000000007; return ret;&#125;iter Split(ll pos)&#123; iter it=s.lower_bound((Node)&#123;pos,pos,-1&#125;); if(it!=s.end() &amp;&amp; it-&gt;l==pos) return it; it--; Node x=*it; s.erase(it); s.insert((Node)&#123;x.l,pos-1,x.val&#125;); return s.insert((Node)&#123;pos,x.r,x.val&#125;).first;&#125;void Assign(ll l,ll r,ll val)&#123; iter R=Split(r+1),L=Split(l); s.erase(L,R); s.insert((Node)&#123;l,r,val&#125;);&#125;ll QuickPow(ll x,ll y,ll p)&#123; x%=p; ll res=1; while(y) &#123; if(y&amp;1) res=res*x%p; x=x*x%p; y&gt;&gt;=1; &#125; return res;&#125;void Modify(ll l,ll r,ll val)&#123; iter R=Split(r+1),L=Split(l); for(iter it=L;it!=R;it++) it-&gt;val+=val;&#125;ll Query(ll l,ll r,ll x,ll y)&#123; iter R=Split(r+1),L=Split(l); ll res=0; for(iter it=L;it!=R;it++) res=(res+1ll*(it-&gt;r-it-&gt;l+1)*QuickPow(it-&gt;val,x,y))%y; return res;&#125;struct Segment&#123; ll len,val; friend bool operator &lt; (const Segment &amp;x,const Segment &amp;y) &#123; return x.val&lt;y.val; &#125;&#125;;vector &lt;Segment&gt; vec;vector &lt;Segment&gt;::iterator vit;ll FindKth(ll l,ll r,ll k)&#123; vec.clear(); iter R=Split(r+1),L=Split(l); for(iter it=L;it!=R;it++) vec.push_back((Segment)&#123;it-&gt;r-it-&gt;l+1,it-&gt;val&#125;); sort(vec.begin(),vec.end()); ll sum=0; for(vit=vec.begin();vit!=vec.end();vit++) &#123; sum+=vit-&gt;len; if(sum&gt;=k) return vit-&gt;val; &#125; return -1;&#125;int main()&#123; scanf(\"%d %d %lld %lld\",&amp;n,&amp;m,&amp;seed,&amp;vmax); for(int i=1;i&lt;=n;i++) a[i]=rnd()%vmax+1; for(int i=1;i&lt;=n;i++) s.insert((Node)&#123;i,i,a[i]&#125;); s.insert((Node)&#123;n+1,n+1,0&#125;); for(int i=1;i&lt;=m;i++) &#123; ll opt=rnd()%4+1,l=rnd()%n+1,r=rnd()%n+1,x,y; if(l&gt;r) swap(l,r); if(opt==3) x=rnd()%(r-l+1)+1; else x=rnd()%vmax+1; if(opt==4) y=rnd()%vmax+1; if(opt==1) Modify(l,r,x); else if(opt==2) Assign(l,r,x); else if(opt==3) printf(\"%lld\\n\",FindKth(l,r,x)); else if(opt==4) printf(\"%lld\\n\",Query(l,r,x,y)); &#125; return 0;&#125; 小结不结了。 附一张珂朵莉的图吧。","categories":[],"tags":[{"name":"珂朵莉树","slug":"珂朵莉树","permalink":"http://VenusNero.github.io/tags/珂朵莉树/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://VenusNero.github.io/tags/学习笔记/"}]},{"title":"从零搭建 Hexo + Github 博客","slug":"build_hexo_github_blog","date":"2019-01-23T02:06:45.190Z","updated":"2019-01-23T14:22:49.911Z","comments":true,"path":"2019/01/23/build_hexo_github_blog/","link":"","permalink":"http://VenusNero.github.io/2019/01/23/build_hexo_github_blog/","excerpt":"前言之前有一篇用 $\\text{Wordpress}$ 搭建博客的文章，这里给出一种更为方便的搭建方法，只要用 $\\text{Github}$。 笔者是在 $\\text{Windows}$ 的环境下搭建的，其他系统可能不适用。 本文同步发表于笔者的洛谷博客：从零搭建 Hexo + Github 博客","text":"前言之前有一篇用 $\\text{Wordpress}$ 搭建博客的文章，这里给出一种更为方便的搭建方法，只要用 $\\text{Github}$。 笔者是在 $\\text{Windows}$ 的环境下搭建的，其他系统可能不适用。 本文同步发表于笔者的洛谷博客：从零搭建 Hexo + Github 博客 感谢 @Happynewyear 的帮忙捉虫，以及 @Sinner 提供的部分程序地址。 优缺点分析优点安装简单方便，不需要自己找域名、设置 $\\text{DNS}$，自带 $\\text{Markdown}$，在简单的设置之后即可支持 $\\LaTeX$。同时官网有诸多主题可供挑选。 缺点搭建在 $\\text{Github}$ 的服务器上，访问速度较慢，无法自定义域名，想要对博客进行自定义更改需要使用 $\\text{JavaScript}$，博客上传比较麻烦。 前置条件程序在开始之前，推荐大家提前下载一下之后要用到的程序，如下： $\\text{Node.js}$ $\\text{Git}$ $\\text{Sublime}$ 账号我们只需要一个 $\\text{Github}$ 的账号即可。 开始搭建1. 配置 $\\text{Github}$ 的 $\\text{SHH}$首先进入 $\\text{Git}$ 程序的源文件夹，打开 git-bash.exe。 输入这样一行命令： 1ssh-keygen -t rsa -C &quot;Github 注册的邮箱地址&quot; 按下回车，按四次，直到出现一个奇怪的图时，则完成。图可能会不同，属于正常现象。 此时就不用管了，我们进入 $\\text{Github}$ ，登录自己的账号，点击右上角头像 $\\rightarrow$ $\\text{Settings}$， 然后点击左侧的 $\\text{SSH and GPG keys}$ 点击右上方的 $\\text{New SSH key}$ 此时会让你填两个东西，一个是 $\\text{Title}$，一个是 $\\text{Key}$，前者我们随便填一个，后者的话，我们进入 C:\\Users\\你的用户名\\.ssh，用记事本打开一个叫做 id_rsa.pub 的文件，把里面的东西复制到 $\\text{Key}$ 里面去即可。 2. 本地运行 $\\text{Hexo}$首先进入 $\\text{Hexo}$ 的官网，此时我们会在正中间看见一行代码，这个就是 $\\text{Hexo}$ 的安装代码了。 在安装之前，我们要准备一个东西：存储本地博客的文件夹，这个大家按自己的习惯和情况创建一个文件夹就行，比如我创建的文件夹是 E:/blog，这个 blog 文件夹就是存储所有博客要用的文件夹了。 为避免出现不必要的 $\\text{Bug}$，推荐使用英文的文件夹名字。 在安装时，各位应该按照自己的路径来设置，千万不要完全照搬这里给出的做法。 我们打开 cmd（win+R 键打开运行，输入 cmd），先输入盘，比如我这里是 E:，然后输入 cd blog，然后打入给出的那行命令：npm install hexo-cli -g，等到进度条满，你能够再次输入命令时就完成了。 先别急着关 cmd，之后我们还会用到。 此时我们就要开始创建本地博客了。在 $\\text{Hexo}$ 官网首页的下方，有一行代码，hexo init blog，这行代码就是我们创建博客的关键了。此时，如果你没有关掉 cmd，那么它应该是保持着 cd 到你创建的文件夹的状态，如果关掉的话，要重新 E: cd blog 一下。输入官网上的这行代码：hexo init 你的博客名，这个博客名随便起，因为它不会影响你网站上的任何因素，只是会影响之后创建的文件夹的名字。 输入代码，开始创建博客，又需要一些时间。当然，有一些写着 WARN 的指令行出现，也不用紧张，是正常现象。 等待安装完成，需要一些时间。 安装好之后，我们就可以看见之前的 blog 文件夹中，出现了一个名字为你刚刚输入的名字文件夹。 我们 cd 到这个文件夹下，对我来说就是 cd vocaloid，然后就可以安装依赖了，输入 npm install，开始安装。 这个很快就可以完成。 接着我们就可以本地运行了，我们接着在 cmd 中输入 hexo s -p 端口，这个端口不知道有什么限制，推荐输入 5555 或者 4000，很快就可以完成。 此时我们就可以进入 localhost:端口，就可以看到你的 $\\text{Hexo}$ 博客啦。 此时如果你在 cmd 中按下 Ctrl+C，再确认终止批处理操作，就可以停止使用这个端口了。 3. 发布至 $\\text{Github}$在上传之前，我们需要做一些配置。首先用 $\\text{Sublime}$ 打开文件夹： 打开 _config.yml，准备修改。 进入 $\\text{Github}$，先新建一个项目，点击右上角的 $+$ 号，选择 New repository，描述自己填，名字使用 你的 Github 用户名.github.io。 （因为我这里是一个号重复建，所以我就不用我的用户名演示了。） 为了防止接下来的教程出现一些问题，各位最好把“是否有 README” 这一个选项选上，不然就会和我这里给出的情况不同。 此时就进入了项目的页面，我们点击右侧绿色的 Clone or download 按钮，将它给出的链接复制下来。 回到 $\\text{Sublime}$，拉到最下面，在 type 后面输入 git（所有冒号后面都有空格，不能不加，切记）。 在 type 这一行下面，加入 repo: ，然后后面填上刚刚复制的地址，往上拉，找到 url:，在 url: 后面输入：http://你的 Github 用户名.github.io 上方有一个 author，这个可以改一下，改成你自己即可。 此时基础配置就差不多完成了，我们回到 cmd，先退出刚才的本地端口，然后安装一个 $\\text{Git}$ 插件。 输入 npm install hexo-deployer-git --save ，即可等待其安装了。 此时回到 $\\text{Sublime}$，在刚刚的 repo 下面再加一行：branch: master，保存。 完成后，我们就可以尝试运行这个博客了。我们在 cmd 中分别输入两行代码，一行是 hexo g，代表本地文件生成，另一行是 hexo d，代表上传。 等待一些时间，即可完成。 此时会让你配置你的 $\\text{Github}$ 账号，需要分别输入两行代码（因为我之前配置过了，所以不用再次配置），如下（这两行代码在 cmd 中都有给出）： git config --global user.email &quot;你的邮箱&quot; git config --global user.name &quot;你的用户名&quot; 引号不要省略掉。配置好后，再次输入 hexo d，此时会弹出一个窗口，让你登录你的 $\\text{Github}$，大概长这样： 登录就行了。等到上传完成，即可直接访问你的博客了，地址就是你刚才在 $\\text{Sublime}$ 中，url: 后面的那个地址。 此时就完成了博客的搭建，但是我们的博客是不支持 $\\LaTeX$ 的，所以我们还需要配置。 4. $404$ 的解决方案我们可能会遇到这样的情况： 这种情况必然是非常令人恼火的，但解决方法非常简单，我们进入刚才创建的项目的页面，点击 $Settings$，往下拉，找到一个 Custom domain，输入我们之前在 url: 后面输入的那个域名，即 &lt;用户名&gt;.github.io，然后点击 $\\text{Save}$，应该就可以访问了。 5. 主题不同的主题可以在 $\\text{Hexo}$ 的 主题 中安装，只需要在 cmd 中 cd 到你的博客文件夹（对我来说是 E:\\blog\\vocaloid），然后在主题的 $\\text{Github}$ 中找到安装的代码，如果没有大家可以自行修改别的代码，将地址和文件夹改一下就行了。 之后我们可以打开 _config.yml，将下面的 theme: 后面的名字改成安装的文件夹的名字，比如 theme: next。 6. 博客的标题打开 _config.yml，可以看到上方有一个 title:，把后面的修改掉就行了。 $\\LaTeX$ 设置我们此时搭建的博客只能使用 $\\text{Markdown}$，同时因为一些语句的冲突无法使用 $\\LaTeX$ ，所以我们需要解决这些冲突，同时安装一个能够使用及渲染 $\\LaTeX$ 的语言包。 下面的操作都默认 cd 到了博客文件夹。 1. 修改引擎首先我们要将原本的渲染引擎替换成能够支持 $\\LaTeX$ 的渲染引擎。原版的引擎是 $\\text{Marked}$，我们将它卸载 ，然后安装一个 $\\text{Kramed}$ 引擎。 先 cd 到博客文件夹后，输入以下代码： npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save 2. 更改配置用 $\\text{Sublime}$ 打开 /node_modules/hexo-renderer-kramed/lib/renderer.js 。 123456789将function formatText(text) &#123; // Fit kramed&apos;s rule: $$ + \\1 + $$ return text.replace(/`\\$(.*?)\\$`/g, &apos;$$$$$1$$$$&apos;);&#125;改为function formatText(text) &#123; return text;&#125; 3. 修改数学包我们要将原来的数学包修改成 $\\text{Kramed}$ 适用的数学包，分别输入 npm uninstall hexo-math --save npm install hexo-renderer-mathjax --save 等待其卸载、安装即可。 4. 更新配置文件打开 /node_modules/hexo-renderer-mathjax/mathjax.html，将最下面的代码注释掉（即在开始的 &lt; 后面加上 !--，然后在上面加上一行：&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 即可。 5. 更改规则为了解决冲突，我们还需要更改转义规则。首先打开 \\node_modules\\kramed\\lib\\rules\\inline.js，将 escape 和 em 这两行注释掉，分别修改为： 123escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/,em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 至此，我们完成了 $\\LaTeX$ 的前置准备，最后只需要启用即可。 6. 启用进入进入 博客\\_config.yml，加上一行 mathjax: true 即可。如果不行的话，就在每篇博客最前面的信息处加上一行 mathjax: true 即可。 如何上传博客我们进入 博客名\\source\\_posts，这里就是放博客的地方。如果要写博客，最好使用一些 $\\text{Markdown}$ + $\\LaTeX$ 编辑器，比如 $\\text{Typora}$，在本地写好后，在放博客的地方新建一个文档，文档的名字就决定了你的标识符，也就是这个东西： 文档的后缀名应该是 .md，我们可以创建一个 .txt 文件，然后改后缀就行。用 $\\text{Sublime}$ 或者别的编辑器打开后，我们在最上面加上这样一段： 12345---title: 你的文章的标题date: 发布时间tag: 标签--- 然后再下面直接把博客复制上去就行。 此时我们就写好了一篇博客，但是我们还需要上传，我们打开 cmd，cd 到你的博客的位置，然后分别输入三行代码： hexo clean hexo g hexo d 等待一段时间后再回到博客，就可以成功了。 效果见：Here 文章过长？我们会发现，上传博客后往往会在首页将整篇文章的内容都显示出来，这显然是非常占用空间的，此时我们可以在博客的文档中加入一行代码：&lt;!--more--&gt;，然后重新上传，此时在这行代码后面的内容都不会显示出来了，而是改为了一个“$\\text{Read More}$”按键，非常方便。 博客背景进入 \\themes\\landscape\\source\\css\\images，有一张叫做 banner.jpg/png 的图（不同主题的位置及名字都可能不同），我们将它替换，文件名和后缀名最好都一样，然后按照上面传博客的方法，hexo clean，hexo g，hexo d，等一会儿就上传完成了。 注意：基本上所有修改完成后都要打一遍 hexo clean，hexo g，hexo d，忘记打就会导致修改在网站上无法生效。 小结这里只是给出了一些最基础的内容，各位想要更深的研究可以在网上找一些教程，也可以套用现有的主题，难度应该不会很大（当然，如果涉及 $\\text{JS}$ 那也不简单了【笑】）。 参考资料：1 2 3","categories":[],"tags":[{"name":"IT","slug":"IT","permalink":"http://VenusNero.github.io/tags/IT/"}]},{"title":"题解 P3644 [APIO2015]八邻旁之桥","slug":"solution_p3644","date":"2019-01-23T01:10:52.090Z","updated":"2019-01-23T08:28:30.171Z","comments":true,"path":"2019/01/23/solution_p3644/","link":"","permalink":"http://VenusNero.github.io/2019/01/23/solution_p3644/","excerpt":"$\\text{FHQ Treap}$。一开始写的不知道为什么写炸了，还以为不能用，不过后来找了一个 $\\text{dalao}$的博客 重构了一下代码，总算还是过掉了。","text":"$\\text{FHQ Treap}$。一开始写的不知道为什么写炸了，还以为不能用，不过后来找了一个 $\\text{dalao}$的博客 重构了一下代码，总算还是过掉了。 如第一篇题解所说，$k=1$ 就直接算，$k=2$ 就枚举一个分割线，左右分别算，不过其实不用建两棵树，而是可以先预处理一下，然后就可以重复使用同一棵树（要清空），数据结构要支持区间插入、中值查询、区间和，线段树似乎不错，但我不知道怎么查中值【流下菜鸡的泪水】，所以还是写了一生所爱 $\\text{FHQ Treap}$，维护下传一个 $sum$ 标记即可。 写时为了防止读入字符出错使用了关闭流同步的 cin，同时使用 cout 输出，各位有需要可以自行修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;#define MAXN 100005#define ll long longusing namespace std;struct FHQTreap&#123; int son[2],key,siz; ll val,sum;&#125;t[MAXN&lt;&lt;1];struct Node&#123; int l,r,mid; friend bool operator &lt; (const Node &amp;x,const Node &amp;y) &#123; return x.mid&lt;y.mid; &#125;&#125;a[MAXN];int k,n,siz,root,tot;ll ans[MAXN],Ans;void Update(int x)&#123; t[x].siz=t[t[x].son[0]].siz+t[t[x].son[1]].siz+1; t[x].sum=t[t[x].son[0]].sum+t[t[x].son[1]].sum+t[x].val;&#125;int NewNode(ll val)&#123; t[++siz].siz=1; t[siz].val=val; t[siz].key=rand(); t[siz].sum=val; return siz;&#125;int Merge(int x,int y)&#123; if(!x || !y) return x+y; if(t[x].key&lt;t[y].key) &#123; t[x].son[1]=Merge(t[x].son[1],y); Update(x); return x; &#125; else &#123; t[y].son[0]=Merge(x,t[y].son[0]); Update(y); return y; &#125;&#125;void Split(int rt,int pos,int &amp;l,int &amp;r)&#123; if(!rt) l=r=0; else &#123; if(t[rt].val&lt;=pos) &#123; l=rt; Split(t[rt].son[1],pos,t[rt].son[1],r); &#125; else &#123; r=rt; Split(t[rt].son[0],pos,l,t[rt].son[0]); &#125; Update(rt); &#125;&#125;ll FindKth(int rt,int pos)&#123; while(1) &#123; if(pos&lt;=t[t[rt].son[0]].siz) rt=t[rt].son[0]; else if(pos==t[t[rt].son[0]].siz+1) return t[rt].val; else &#123; pos-=t[t[rt].son[0]].siz+1; rt=t[rt].son[1]; &#125; &#125;&#125;void Insert(ll val)&#123; int x,y; Split(root,val,x,y); root=Merge(Merge(x,NewNode(val)),y);&#125;ll Query(ll val)&#123; int x,y; ll sum=t[root].siz/2,res=0; Split(root,val-1,x,y); res=t[x].sum*2+val*(sum-t[x].siz)*2; root=Merge(x,y); return res;&#125;ll CalcMid()&#123; ll rk=FindKth(root,t[root].siz/2); return t[root].sum-Query(rk);&#125;int main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;k&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; int x,y; char opt1,opt2; cin&gt;&gt;opt1&gt;&gt;x&gt;&gt;opt2&gt;&gt;y; if(x&gt;y) swap(x,y); if(opt1==opt2) Ans+=y-x; else a[++tot]=((Node)&#123;x,y,x+y&#125;); &#125; sort(a+1,a+tot+1); for(int i=1;i&lt;=tot;i++) &#123; Insert(a[i].l); Insert(a[i].r); ans[i]=CalcMid(); &#125; if(k==1) return cout&lt;&lt;ans[tot]+Ans+tot&lt;&lt;endl,0; ll cnt=ans[tot]; for(int i=0;i&lt;=siz;i++) t[i].son[0]=t[i].son[1]=0; root=siz=0; for(int i=tot;i&gt;=1;i--) &#123; Insert(a[i].l); Insert(a[i].r); cnt=min(cnt,ans[i-1]+CalcMid()); &#125; cout&lt;&lt;cnt+Ans+tot&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://VenusNero.github.io/tags/题解/"},{"name":"FHQTreap","slug":"FHQTreap","permalink":"http://VenusNero.github.io/tags/FHQTreap/"}]},{"title":"树链剖分瞎入门","slug":"Tree_Split_Train","date":"2019-01-22T13:00:22.630Z","updated":"2019-01-23T08:28:47.546Z","comments":true,"path":"2019/01/22/Tree_Split_Train/","link":"","permalink":"http://VenusNero.github.io/2019/01/22/Tree_Split_Train/","excerpt":"本文旨在让读者背代码 前言在做题时，我们可能会遇到这样一类问题： 给定一棵 $n$ 个结点的树和 $m$ 次操作，操作有两种，一种是给定两个结点，让连接两个结点的路径上的所有点权值加上一个值，另一种是查询路径上所有点的权值和。$n\\le 1e5$，$m\\le 2e5$。 如果是最后统一输出结点权值，用树上差分+$\\text{DFS}$ 就能轻松水过，而对于在线查询，如果数据范围小的话暴力即可 $\\text{AC}$，时间复杂度 $\\text{O}(nm)$，但是很明显，这个数据范围肯定不能这么写了。此时，就需要树链剖分出场了。","text":"本文旨在让读者背代码 前言在做题时，我们可能会遇到这样一类问题： 给定一棵 $n$ 个结点的树和 $m$ 次操作，操作有两种，一种是给定两个结点，让连接两个结点的路径上的所有点权值加上一个值，另一种是查询路径上所有点的权值和。$n\\le 1e5$，$m\\le 2e5$。 如果是最后统一输出结点权值，用树上差分+$\\text{DFS}$ 就能轻松水过，而对于在线查询，如果数据范围小的话暴力即可 $\\text{AC}$，时间复杂度 $\\text{O}(nm)$，但是很明显，这个数据范围肯定不能这么写了。此时，就需要树链剖分出场了。 树链剖分原理树链剖分是根据轻重儿子，将一棵树剖成多条链，然后就可以用数据结构来维护这些链了，听着似乎还是有点像暴力，不过因为一条链有多个结点，所以可以优化时间复杂度。 至于轻重儿子的定义，请见下一块。 实现既然要把树剖成一堆链，那么我们就要有一种标准来剖这棵树，树链剖分的标准是什么呢？我们定义：一个结点的所有子树中，结点数最多的子树的根节点是这个结点的“重儿子”，比如下面这张图中，红点就是蓝点的重儿子。 递归进行这个过程，我们可以得到一堆的“重儿子”，将这些重儿子连起来，我们就会得到一根“重链”，最后对整棵树完成这个过程后，我们就将一棵树剖成了若干个“重链”。 剖完之后，还有一些点，它们则称为“轻儿子”，一些轻边连成的链则称为轻链。（然而这个并没有什么卵用） 此时我们已经剖完了树，我们就要考虑怎么维护这些链了。在说怎么维护之前，我们先把怎么剖用代码的方式表示出来。 对于树链剖分，我们需要维护以下的数组： 名称 含义 $siz[u]$ 以 $u$ 为根的子树的结点个数 $son[u]$ $u$ 的重儿子的编号 $top[u]$ $u$ 所在链的深度最小的结点编号 $dep[u]$ $u$ 的深度 $faz[u]$ $u$ 的父亲的编号 $dfn[u]$ $u$ 的 $\\text{DFS}$ 序 $rk[u]$ $u$ 树中的编号 注：每个轻儿子的 $top$ 就是它本身。 首先，因为我们在 $\\text{DFS}$ 时应该先往重儿子搜索，所以一个 $\\text{DFS}$ 肯定是不能完成任务，所以我们需要两个 $\\text{DFS}$ 函数。 这两个 $\\text{DFS}$ 函数分别完成什么呢？ $\\text{Dfs1}$：预处理 $siz$，$son$，$dep$，$faz$ 数组。 123456789101112131415void Dfs1(int u)&#123; siz[u]=1; son[u]=0; for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u]) continue; dep[v]=dep[u]+1; faz[v]=u; Dfs1(v); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]]) son[u]=v; &#125;&#125; $\\text{Dfs2}$：预处理 $dfn$，$top$，$rk$ 数组。其中 $rk$ 数组有的时候用不到，在部分题目中可以省略。 12345678910111213void Dfs2(int u,int rt)&#123; dfn[u]=++Index; rk[Index]=u; top[u]=rt; if(son[u]) Dfs2(son[u],rt); for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u] || v==son[u]) continue; Dfs2(v,v); &#125;&#125; 注意点：$\\text{Dfs1}$ 没有什么好注意的，$\\text{Dfs2}$ 的时候记得先往重儿子搜，至于为什么？ 维护链$\\text{DFS}$ 序首先讲一下，为什么要先搜重儿子。因为我们要维护的是重链，而一条链的要求必须是连续的，而我们维护时使用数据结构，必然是要将它转换到数列上来做的，如何转换呢？最好的方法就是按照 $\\text{DFS}$ 序，此时如果不先搜重儿子的话，重链上的 $\\text{DFS}$ 序就可能会断掉，如下图（橙、绿线是 $\\text{DFS}$ 搜索顺序）： 这条链的 $\\text{DFS}$ 序就断开了，此时就无法用数据结构去维护了。 如何维护这一节很简单，没什么好讲的，因为要维护的是链，而且我们现在已经保证链上的 $\\text{DFS}$ 序连续了，所以我们直接取结点的 $top$ 到它自己这一段进行修改或查询（即使用 $\\text{DFS}$ 序修改），然后再将当前结点跳到它 $top$ 的 $faz$ 即可。为了防止一个结点无限往上跳，我们先选 $top$ 比较深的那个结点进行修改/查询，再往上跳，就可以防止无限跳的情况了。而如果选的是浅的，而它又往上跳，则深度越来越浅，必然会无限跳，最终死循环。 最后，这两个结点一定会到一条链上，而且必然有一个点会是 $\\text{LCA}$，我们最后进行一次操作即可。 至于为什么是跳到 $top$ 的 $faz$，因为 $top$ 已经被修改/查询过了，跳到上一个结点防止重复操作。 修改： 1234567891011void ModifyOnTree(int u,int v,int val)&#123; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); Modify(1,1,n,dfn[top[u]],dfn[u],val); u=faz[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); Modify(1,1,n,dfn[u],dfn[v],val);&#125; 查询（根据求和、求最小值、求最大值修改，仅给出求和）： 12345678910111213int QueryOnTree(int u,int v)&#123; int res=0; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); res+=Query(1,1,n,dfn[top[u]],dfn[u]); u=faz[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); res+=Query(1,1,n,dfn[u],dfn[v]); return res;&#125; 至于其中的 $\\text{Modify}$ 和 $\\text{Query}$ 函数，根据不同的需求和使用的数据结构的不同，应自行修改。 例题P3384 【模板】树链剖分链接 操作涉及区间加、区间和、子树加、子树和，区间的两种操作直接用线段树配合上面的模板可以轻松过去，而子树加和子树和这两个新操作呢？其实更简单。我们知道，一个子树的 $\\text{DFS}$ 序必然是连续的，所以我们直接对 $dfn[x]$ 到 $dfn[x]+siz[x]-1$ 这个序列进行区间加、区间和的操作即可，使用线段树即可无脑水过。 代码因为年代久远，码风太丑，不贴了。 重要注意点：子树操作在 $\\text{PushDown}$ 传 $tag$ 的时候，对 $sum$ 的加需要乘上区间长度的一半，切记。 P2590 [ZJOI2008]树的统计链接 操作涉及单点修改、区间最大值、区间和，无脑水过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;#define MAXN 100005#define inf 2147400000using namespace std;int cnt,fst[MAXN],nxt[MAXN],to[MAXN];int n,Q,a[MAXN&gt;&gt;1],Index,sum[MAXN&lt;&lt;2],maxn[MAXN&lt;&lt;2];int siz[MAXN],son[MAXN],faz[MAXN],dep[MAXN],top[MAXN],rk[MAXN],id[MAXN];void AddEdge(int u,int v)&#123; to[++cnt]=v; nxt[cnt]=fst[u]; fst[u]=cnt;&#125;void Dfs1(int u,int fa)&#123; siz[u]=1; son[u]=0; for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==fa) continue; dep[v]=dep[u]+1; faz[v]=u; Dfs1(v,u); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]]) son[u]=v; &#125;&#125;void Dfs2(int u,int rt)&#123; id[u]=++Index; rk[Index]=u; top[u]=rt; if(son[u]) Dfs2(son[u],rt); for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u] || v==son[u]) continue; Dfs2(v,v); &#125;&#125;void PushUp(int rt)&#123; sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1]; maxn[rt]=max(maxn[rt&lt;&lt;1],maxn[rt&lt;&lt;1|1]);&#125;void BuildSegmentTree(int rt,int l,int r)&#123; if(l==r) &#123; sum[rt]=maxn[rt]=a[rk[l]]; return; &#125; int mid=l+r&gt;&gt;1; BuildSegmentTree(rt&lt;&lt;1,l,mid); BuildSegmentTree(rt&lt;&lt;1|1,mid+1,r); PushUp(rt);&#125;void Modify(int rt,int l,int r,int pos,int val)&#123; if(l==r) &#123; sum[rt]=maxn[rt]=val; return; &#125; int mid=l+r&gt;&gt;1; if(pos&lt;=mid) Modify(rt&lt;&lt;1,l,mid,pos,val); else Modify(rt&lt;&lt;1|1,mid+1,r,pos,val); PushUp(rt);&#125;int QuerySum(int rt,int l,int r,int tl,int tr)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) return sum[rt]; int mid=l+r&gt;&gt;1,res=0; if(tl&lt;=mid) res+=QuerySum(rt&lt;&lt;1,l,mid,tl,tr); if(tr&gt;mid) res+=QuerySum(rt&lt;&lt;1|1,mid+1,r,tl,tr); PushUp(rt); return res;&#125;int QueryMaxn(int rt,int l,int r,int tl,int tr)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) return maxn[rt]; int mid=l+r&gt;&gt;1,res=-inf; if(tl&lt;=mid) res=max(res,QueryMaxn(rt&lt;&lt;1,l,mid,tl,tr)); if(tr&gt;mid) res=max(res,QueryMaxn(rt&lt;&lt;1|1,mid+1,r,tl,tr)); PushUp(rt); return res;&#125;int QuerySumOnTree(int u,int v)&#123; int res=0; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); res+=QuerySum(1,1,n,id[top[u]],id[u]); u=faz[top[u]]; &#125; if(dep[u]&lt;dep[v]) swap(u,v); res+=QuerySum(1,1,n,id[v],id[u]); return res;&#125;int QueryMaxOnTree(int u,int v)&#123; int res=-inf; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); res=max(res,QueryMaxn(1,1,n,id[top[u]],id[u])); u=faz[top[u]]; &#125; if(dep[u]&lt;dep[v]) swap(u,v); res=max(res,QueryMaxn(1,1,n,id[v],id[u])); return res;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;i++) &#123; int x,y; scanf(\"%d %d\",&amp;x,&amp;y); AddEdge(x,y); AddEdge(y,x); &#125; for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); dep[1]=1; faz[1]=1; Dfs1(1,0); Dfs2(1,1); BuildSegmentTree(1,1,n); scanf(\"%d\",&amp;Q); while(Q--) &#123; int x,y; string opt; cin&gt;&gt;opt&gt;&gt;x&gt;&gt;y; if(opt==\"CHANGE\") Modify(1,1,n,id[x],y); else if(opt==\"QMAX\") printf(\"%d\\n\",QueryMaxOnTree(x,y)); else if(opt==\"QSUM\") printf(\"%d\\n\",QuerySumOnTree(x,y)); &#125; return 0;&#125; P3178 [HAOI2015]树上操作链接 操作涉及单点加、子树加、区间和，依然无脑水过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define MAXN 100005#define ll long longusing namespace std;int cnt,fst[MAXN],nxt[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1];int n,Q;int dfn[MAXN],Index,top[MAXN],faz[MAXN],dep[MAXN],siz[MAXN],son[MAXN];ll t[MAXN&lt;&lt;2],tag[MAXN&lt;&lt;2],rk[MAXN],a[MAXN];void AddEdge(int u,int v)&#123; to[++cnt]=v; nxt[cnt]=fst[u]; fst[u]=cnt;&#125;void Dfs1(int u)&#123; siz[u]=1; son[u]=0; for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u]) continue; dep[v]=dep[u]+1; faz[v]=u; Dfs1(v); siz[u]+=siz[v]; if(siz[son[u]]&lt;siz[v]) son[u]=v; &#125;&#125;void Dfs2(int u,int rt)&#123; dfn[u]=++Index; rk[Index]=a[u]; top[u]=rt; if(son[u]) Dfs2(son[u],rt); for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u] || v==son[u]) continue; Dfs2(v,v); &#125;&#125;void PushUp(int rt)&#123; t[rt]=t[rt&lt;&lt;1]+t[rt&lt;&lt;1|1];&#125;void PushDown(int rt,ll len)&#123; if(tag[rt]) &#123; tag[rt&lt;&lt;1]+=tag[rt]; tag[rt&lt;&lt;1|1]+=tag[rt]; t[rt&lt;&lt;1]+=tag[rt]*(len-(len&gt;&gt;1)); t[rt&lt;&lt;1|1]+=tag[rt]*(len&gt;&gt;1); tag[rt]=0; &#125;&#125;void BuildSegmentTree(int rt,int l,int r)&#123; if(l==r) &#123; t[rt]=rk[l]; return; &#125; int mid=l+r&gt;&gt;1; BuildSegmentTree(rt&lt;&lt;1,l,mid); BuildSegmentTree(rt&lt;&lt;1|1,mid+1,r); PushUp(rt);&#125;void Modify(int rt,int l,int r,int tl,int tr,ll val)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) &#123; tag[rt]+=val; t[rt]+=1ll*val*(r-l+1); return; &#125; PushDown(rt,r-l+1); int mid=l+r&gt;&gt;1; if(tl&lt;=mid) Modify(rt&lt;&lt;1,l,mid,tl,tr,val); if(tr&gt;mid) Modify(rt&lt;&lt;1|1,mid+1,r,tl,tr,val); PushUp(rt);&#125;ll Query(int rt,int l,int r,int tl,int tr)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) return t[rt]; PushDown(rt,r-l+1); int mid=l+r&gt;&gt;1; ll res=0; if(tl&lt;=mid) res+=Query(rt&lt;&lt;1,l,mid,tl,tr); if(tr&gt;mid) res+=Query(rt&lt;&lt;1|1,mid+1,r,tl,tr); return res;&#125;ll QueryOnTree(int u,int v)&#123; ll res=0; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); res+=Query(1,1,n,dfn[top[u]],dfn[u]); u=faz[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); res+=Query(1,1,n,dfn[u],dfn[v]); return res;&#125;int main()&#123; scanf(\"%d %d\",&amp;n,&amp;Q); for(int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;a[i]); for(int i=1;i&lt;n;i++) &#123; int x,y; scanf(\"%d %d\",&amp;x,&amp;y); AddEdge(x,y); AddEdge(y,x); &#125; Dfs1(1); Dfs2(1,1); BuildSegmentTree(1,1,n); while(Q--) &#123; int opt; scanf(\"%d\",&amp;opt); if(opt==1) &#123; int x,y; scanf(\"%d %d\",&amp;x,&amp;y); Modify(1,1,n,dfn[x],dfn[x],y); &#125; else if(opt==2) &#123; int x,y; scanf(\"%d %d\",&amp;x,&amp;y); Modify(1,1,n,dfn[x],dfn[x]+siz[x]-1,y); &#125; else &#123; int x; scanf(\"%d\",&amp;x); printf(\"%lld\\n\",QueryOnTree(1,x)); &#125; &#125; return 0;&#125; P4315 月下“毛景树”链接 操作涉及单点覆盖、区间覆盖、区间加、区间最大值，本来应该是无脑水过，但是因为要将边权转成点权，然后忽略掉 $\\text{LCA}$，还是有点难度，具体解析见：题解 P4315 【月下“毛景树”】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include&lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;int cnt,fst[MAXN],nxt[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1],w[MAXN&lt;&lt;1],fr[MAXN&lt;&lt;1];int n,a[MAXN],t[MAXN&lt;&lt;2],tag[MAXN&lt;&lt;2],cov[MAXN&lt;&lt;2];int siz[MAXN],son[MAXN],dfn[MAXN],Index,top[MAXN],rk[MAXN],dep[MAXN],faz[MAXN];string s;void AddEdge(int u,int v,int c)&#123; to[++cnt]=v; nxt[cnt]=fst[u]; fst[u]=cnt; w[cnt]=c; fr[cnt]=u;&#125;void Dfs1(int u)&#123; siz[u]=1; son[u]=0; for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u]) continue; faz[v]=u; dep[v]=dep[u]+1; rk[v]=w[i]; Dfs1(v); siz[u]+=siz[v]; if(siz[son[u]]&lt;siz[v]) son[u]=v; &#125;&#125;void Dfs2(int u,int rt)&#123; dfn[u]=++Index; top[u]=rt; a[Index]=rk[u]; if(son[u]) Dfs2(son[u],rt); for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u] || v==son[u]) continue; Dfs2(v,v); &#125;&#125;void PushUp(int rt)&#123; t[rt]=max(t[rt&lt;&lt;1],t[rt&lt;&lt;1|1]);&#125;void PushDown(int rt)&#123; if(~cov[rt]) &#123; cov[rt&lt;&lt;1]=cov[rt&lt;&lt;1|1]=cov[rt]; t[rt&lt;&lt;1]=t[rt&lt;&lt;1|1]=cov[rt]; tag[rt&lt;&lt;1]=tag[rt&lt;&lt;1|1]=0; cov[rt]=-1; &#125; tag[rt&lt;&lt;1]+=tag[rt]; tag[rt&lt;&lt;1|1]+=tag[rt]; t[rt&lt;&lt;1]+=tag[rt]; t[rt&lt;&lt;1|1]+=tag[rt]; tag[rt]=0;&#125;void BuildSegmentTree(int rt,int l,int r)&#123; cov[rt]=-1; if(l==r) &#123; t[rt]=a[l]; return; &#125; int mid=l+r&gt;&gt;1; BuildSegmentTree(rt&lt;&lt;1,l,mid); BuildSegmentTree(rt&lt;&lt;1|1,mid+1,r); PushUp(rt);&#125;void ModifyCover(int rt,int l,int r,int tl,int tr,int val)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) &#123; t[rt]=cov[rt]=val; tag[rt]=0; return; &#125; PushDown(rt); int mid=l+r&gt;&gt;1; if(tl&lt;=mid) ModifyCover(rt&lt;&lt;1,l,mid,tl,tr,val); if(tr&gt;mid) ModifyCover(rt&lt;&lt;1|1,mid+1,r,tl,tr,val); PushUp(rt);&#125;void ModifyAdd(int rt,int l,int r,int tl,int tr,int val)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) &#123; t[rt]+=val; tag[rt]+=val; return; &#125; PushDown(rt); int mid=l+r&gt;&gt;1; if(tl&lt;=mid) ModifyAdd(rt&lt;&lt;1,l,mid,tl,tr,val); if(tr&gt;mid) ModifyAdd(rt&lt;&lt;1|1,mid+1,r,tl,tr,val); PushUp(rt);&#125;int Query(int rt,int l,int r,int tl,int tr)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) return t[rt]; PushDown(rt); int mid=l+r&gt;&gt;1,res=0; if(tl&lt;=mid) res=max(res,Query(rt&lt;&lt;1,l,mid,tl,tr)); if(tr&gt;mid) res=max(res,Query(rt&lt;&lt;1|1,mid+1,r,tl,tr)); return res;&#125;void ModifyCoverOnTree(int u,int v,int val)&#123; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); ModifyCover(1,1,n,dfn[top[u]],dfn[u],val); u=faz[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); ModifyCover(1,1,n,dfn[u]+1,dfn[v],val);&#125;void ModifyAddOnTree(int u,int v,int val)&#123; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); ModifyAdd(1,1,n,dfn[top[u]],dfn[u],val); u=faz[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); ModifyAdd(1,1,n,dfn[u]+1,dfn[v],val);&#125;int QueryMaxnOnTree(int u,int v)&#123; int res=0; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); res=max(res,Query(1,1,n,dfn[top[u]],dfn[u])); u=faz[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); res=max(res,Query(1,1,n,dfn[u]+1,dfn[v])); return res;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;i++) &#123; int x,y,z; scanf(\"%d %d %d\",&amp;x,&amp;y,&amp;z); AddEdge(x,y,z); AddEdge(y,x,z); &#125; Dfs1(1); Dfs2(1,1); BuildSegmentTree(1,1,n); while(1) &#123; int x,y,z; cin&gt;&gt;s; if(s==\"Stop\") break; else &#123; scanf(\"%d %d\",&amp;x,&amp;y); if(s==\"Change\") &#123; x&lt;&lt;=1; int u=fr[x],v=to[x]; if(dep[u]&gt;dep[v]) swap(u,v); ModifyCoverOnTree(u,v,y); &#125; else if(s==\"Cover\") &#123; scanf(\"%d\",&amp;z); ModifyCoverOnTree(x,y,z); &#125; else if(s==\"Add\") &#123; scanf(\"%d\",&amp;z); ModifyAddOnTree(x,y,z); &#125; else if(s==\"Max\") printf(\"%d\\n\",QueryMaxnOnTree(x,y)); &#125; &#125; return 0;&#125; P4114 Qtree1链接 和上一题一样，边权转点权，无脑操作即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#define MAXN 100005using namespace std;int cnt,fst[MAXN],nxt[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1],w[MAXN&lt;&lt;1];int n,a[MAXN],t[MAXN&lt;&lt;2],fr[MAXN],tx[MAXN];int dfn[MAXN],Index,faz[MAXN],siz[MAXN],son[MAXN],dep[MAXN],top[MAXN],rk[MAXN];char ch[15];void AddEdge(int u,int v,int c)&#123; to[++cnt]=v; nxt[cnt]=fst[u]; fst[u]=cnt; w[cnt]=c;&#125;void Dfs1(int u)&#123; siz[u]=1; son[u]=0; for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u]) continue; dep[v]=dep[u]+1; faz[v]=u; a[v]=w[i]; Dfs1(v); siz[u]+=siz[v]; if(siz[v]&gt;siz[son[u]]) son[u]=v; &#125;&#125;void Dfs2(int u,int rt)&#123; dfn[u]=++Index; rk[Index]=u; top[u]=rt; if(son[u]) Dfs2(son[u],rt); for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u] || v==son[u]) continue; Dfs2(v,v); &#125;&#125;void PushUp(int rt)&#123; t[rt]=max(t[rt&lt;&lt;1],t[rt&lt;&lt;1|1]);&#125;void BuildSegmentTree(int rt,int l,int r)&#123; if(l==r) &#123; t[rt]=a[rk[l]]; return; &#125; int mid=l+r&gt;&gt;1; BuildSegmentTree(rt&lt;&lt;1,l,mid); BuildSegmentTree(rt&lt;&lt;1|1,mid+1,r); PushUp(rt);&#125;void Modify(int rt,int l,int r,int pos,int val)&#123; if(l==r) &#123; t[rt]=val; return; &#125; int mid=l+r&gt;&gt;1; if(pos&lt;=mid) Modify(rt&lt;&lt;1,l,mid,pos,val); else Modify(rt&lt;&lt;1|1,mid+1,r,pos,val); PushUp(rt);&#125;int Query(int rt,int l,int r,int tl,int tr)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) return t[rt]; int mid=l+r&gt;&gt;1; int res=0; if(tl&lt;=mid) res=max(res,Query(rt&lt;&lt;1,l,mid,tl,tr)); if(tr&gt;mid) res=max(res,Query(rt&lt;&lt;1|1,mid+1,r,tl,tr)); return res;&#125;int QueryOnTree(int u,int v)&#123; int res=0; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); res=max(res,Query(1,1,n,dfn[top[u]],dfn[u])); u=faz[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); res=max(res,Query(1,1,n,dfn[u]+1,dfn[v])); return res;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;i++) &#123; int x,y; int z; scanf(\"%d %d %intd\",&amp;x,&amp;y,&amp;z); fr[i]=x; tx[i]=y; AddEdge(x,y,z); AddEdge(y,x,z); &#125; Dfs1(1); Dfs2(1,1); BuildSegmentTree(1,1,n); while(1) &#123; scanf(\"%s\",ch+1); if(ch[1]=='D') break; else &#123; int x,y; scanf(\"%d %d\",&amp;x,&amp;y); if(ch[1]=='Q') printf(\"%d\\n\",QueryOnTree(x,y)); else &#123; int t=dep[fr[x]]&gt;dep[tx[x]]?fr[x]:tx[x]; Modify(1,1,n,dfn[t],y); &#125; &#125; &#125; return 0;&#125; P1505 [国家集训队]旅游链接 最后一道，来道毒瘤的，操作涉及单点修改，区间取相反数，区间和，区间最大值，区间最小值，其他的都简单，就是区间取相反数较难，我们在取相反时，将最大值和最小值交换，然后将和、最大值、最小值全部乘上 $-1$ 就行，码量较大，耐心码耐心调还是可以比较轻松的 $\\text{A}$ 掉的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include&lt;bits/stdc++.h&gt;#define MAXN 200005using namespace std;int cnt,fst[MAXN],nxt[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1],w[MAXN&lt;&lt;1];int n,Q,a[MAXN],t[MAXN&lt;&lt;2],tag[MAXN&lt;&lt;2],maxn[MAXN&lt;&lt;2],minx[MAXN&lt;&lt;2];int siz[MAXN],son[MAXN],top[MAXN],dep[MAXN],faz[MAXN],dfn[MAXN],Index,rk[MAXN];string s;void AddEdge(int u,int v,int c)&#123; to[++cnt]=v; nxt[cnt]=fst[u]; fst[u]=cnt; w[cnt]=c;&#125;void Dfs1(int u)&#123; siz[u]=1; son[u]=0; for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u]) continue; dep[v]=dep[u]+1; faz[v]=u; rk[v]=w[i]; Dfs1(v); siz[u]+=siz[v]; if(siz[son[u]]&lt;siz[v]) son[u]=v; &#125;&#125;void Dfs2(int u,int rt)&#123; top[u]=rt; dfn[u]=++Index; a[Index]=rk[u]; if(son[u]) Dfs2(son[u],rt); for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u] || v==son[u]) continue; Dfs2(v,v); &#125;&#125;void PushUp(int rt)&#123; t[rt]=t[rt&lt;&lt;1]+t[rt&lt;&lt;1|1]; maxn[rt]=max(maxn[rt&lt;&lt;1],maxn[rt&lt;&lt;1|1]); minx[rt]=min(minx[rt&lt;&lt;1],minx[rt&lt;&lt;1|1]);&#125;void PushDown(int rt)&#123; if(tag[rt]) &#123; t[rt&lt;&lt;1]*=-1; t[rt&lt;&lt;1|1]*=-1; tag[rt&lt;&lt;1]^=1; tag[rt&lt;&lt;1|1]^=1; swap(maxn[rt&lt;&lt;1],minx[rt&lt;&lt;1]); swap(maxn[rt&lt;&lt;1|1],minx[rt&lt;&lt;1|1]); maxn[rt&lt;&lt;1]*=-1; minx[rt&lt;&lt;1]*=-1; maxn[rt&lt;&lt;1|1]*=-1; minx[rt&lt;&lt;1|1]*=-1; tag[rt]=0; &#125;&#125;void BuildSegmentTree(int rt,int l,int r)&#123; if(l==r) &#123; t[rt]=maxn[rt]=minx[rt]=a[l]; return; &#125; int mid=l+r&gt;&gt;1; BuildSegmentTree(rt&lt;&lt;1,l,mid); BuildSegmentTree(rt&lt;&lt;1|1,mid+1,r); PushUp(rt);&#125;void ModifyPoint(int rt,int l,int r,int pos,int val)&#123; if(l==r) &#123; t[rt]=maxn[rt]=minx[rt]=val; return; &#125; PushDown(rt); int mid=l+r&gt;&gt;1; if(pos&lt;=mid) ModifyPoint(rt&lt;&lt;1,l,mid,pos,val); else ModifyPoint(rt&lt;&lt;1|1,mid+1,r,pos,val); PushUp(rt);&#125;void ModifyNega(int rt,int l,int r,int tl,int tr)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) &#123; t[rt]*=-1; tag[rt]^=1; swap(maxn[rt],minx[rt]); maxn[rt]*=-1; minx[rt]*=-1; return; &#125; PushDown(rt); int mid=l+r&gt;&gt;1; if(tl&lt;=mid) ModifyNega(rt&lt;&lt;1,l,mid,tl,tr); if(tr&gt;mid) ModifyNega(rt&lt;&lt;1|1,mid+1,r,tl,tr); PushUp(rt);&#125;int QuerySum(int rt,int l,int r,int tl,int tr)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) return t[rt]; PushDown(rt); int mid=l+r&gt;&gt;1,res=0; if(tl&lt;=mid) res+=QuerySum(rt&lt;&lt;1,l,mid,tl,tr); if(tr&gt;mid) res+=QuerySum(rt&lt;&lt;1|1,mid+1,r,tl,tr); return res;&#125;int QueryMaxn(int rt,int l,int r,int tl,int tr)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) return maxn[rt]; PushDown(rt); int mid=l+r&gt;&gt;1,res=-2e9; if(tl&lt;=mid) res=max(res,QueryMaxn(rt&lt;&lt;1,l,mid,tl,tr)); if(tr&gt;mid) res=max(res,QueryMaxn(rt&lt;&lt;1|1,mid+1,r,tl,tr)); return res;&#125;int QueryMinx(int rt,int l,int r,int tl,int tr)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) return minx[rt]; PushDown(rt); int mid=l+r&gt;&gt;1,res=2e9; if(tl&lt;=mid) res=min(res,QueryMinx(rt&lt;&lt;1,l,mid,tl,tr)); if(tr&gt;mid) res=min(res,QueryMinx(rt&lt;&lt;1|1,mid+1,r,tl,tr)); return res;&#125;void ModifyToNegative(int u,int v)&#123; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); ModifyNega(1,1,n,dfn[top[u]],dfn[u]); u=faz[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); ModifyNega(1,1,n,dfn[u]+1,dfn[v]);&#125;int QuerySumOnTree(int u,int v)&#123; int res=0; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); res+=QuerySum(1,1,n,dfn[top[u]],dfn[u]); u=faz[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); res+=QuerySum(1,1,n,dfn[u]+1,dfn[v]); return res;&#125;int QueryMaxnOnTree(int u,int v)&#123; int res=-2e9; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); res=max(res,QueryMaxn(1,1,n,dfn[top[u]],dfn[u])); u=faz[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); res=max(res,QueryMaxn(1,1,n,dfn[u]+1,dfn[v])); return res;&#125;int QueryMinxOnTree(int u,int v)&#123; int res=2e9; while(top[u]!=top[v]) &#123; if(dep[top[u]]&lt;dep[top[v]]) swap(u,v); res=min(res,QueryMinx(1,1,n,dfn[top[u]],dfn[u])); u=faz[top[u]]; &#125; if(dep[u]&gt;dep[v]) swap(u,v); res=min(res,QueryMinx(1,1,n,dfn[u]+1,dfn[v])); return res;&#125;int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;n;i++) &#123; int x,y,z; scanf(\"%d %d %d\",&amp;x,&amp;y,&amp;z); AddEdge(x+1,y+1,z); AddEdge(y+1,x+1,z); &#125; Dfs1(1); Dfs2(1,1); BuildSegmentTree(1,1,n); scanf(\"%d\",&amp;Q); while(Q--) &#123; cin&gt;&gt;s; int x,y; scanf(\"%d %d\",&amp;x,&amp;y); if(s==\"C\") ModifyPoint(1,1,n,dfn[x+1],y); else if(s==\"N\") ModifyToNegative(x+1,y+1); else if(s==\"SUM\") printf(\"%d\\n\",QuerySumOnTree(x+1,y+1)); else if(s==\"MAX\") printf(\"%d\\n\",QueryMaxnOnTree(x+1,y+1)); else if(s==\"MIN\") printf(\"%d\\n\",QueryMinxOnTree(x+1,y+1)); &#125; return 0;&#125; P3613 睡觉困难综合征链接 这道题是真的难了，首先观察原版 P2114 [NOI2014]起床困难综合症 的做法，用一个每一个二进制位都是 $0$ 数（即 $0$）和一个每一个二进制位都是 $1$ 的数（即 $2^{31}-1$）跑一遍，然后从高位贪心选，这道题的核心思想也是这样的，线段树记录的是每一段路径上，$0$ 和 $1$ 分别从左往右跑和从右往左跑最终的结果。显然，我们每一个二进制位都要维护一个值，这样的时间复杂度显然是 $\\text{O}(nklog^2n)$，即树链剖分的时间复杂度乘上每次计算二进制位的结果的时间复杂度，虽然看着不大，但是因为有一个 $log^2n$，以及时限只有 $0.5s$，而且出题人又是那个谁谁谁，这个复杂度就算是卡常也过不去，此时我们就要想办法优化了。 观察时间复杂度，$nlog^2n$ 是树剖的基础时间复杂度，怎么优化都是优化不掉的，我们考虑优化掉那个 $k$，我们现在算结果是一位一位算的，所以是 $\\text{O}(k)$，那么有没有方法在 $\\text{O}(1)$ 的时间复杂度内就把结果算出来呢？其实是有的，只是我不会证，看不懂。 总而言之就是： $now.T0=((L.T0 and R.T1) or ((not L.T0) and R.T0))$ $now.T1=((L.T1 and R.T1) or ((not L.T1) and R.T0))$ 其中 $now$ 是当前结点，$L$ 是左儿子，$R$ 是右儿子，$T$ 是类型，即从左往右或从右往左，当然，在计算从右往左的时候要把 所有 $L$ 和 $R$ 反过来，毕竟是反的嘛。 按照这个式子，我们可以写出一个计算的函数，然后就可以建线段树了。当然，事情还没有完，因为在树上查询的时候，我们原来是两边交替往上跳，但是因为这道题，方向不同结果也不同，比如 $u-v$ 这条路径，一般走法应该是 $u-lca$，$lca-v$，但是在平时树剖的过程中，就可能是 $u-lca$，$v-lca$，一般是没有影响的，但是这题涉及了位运算，操作乱序结果显然会不同，所以我们要分别跳，对于不同的情况存在两个不同的序列里，然后最后把其中一个序列的从左往右从右往左交换一下，最后再做位运算跑贪心。 记得开 $\\text{unsigned long long}$ 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include&lt;bits/stdc++.h&gt;#define MAXN 200005#define ull unsigned long longusing namespace std;const ull MAXULL=-1;struct Node&#123; ull l0,l1,r0,r1;&#125;t[MAXN&lt;&lt;2],ans1[MAXN],ans2[MAXN];int cnt,fst[MAXN],nxt[MAXN&lt;&lt;1],to[MAXN&lt;&lt;1];int n,Q,K,opt[MAXN],tot1,tot2;int siz[MAXN],son[MAXN],dfn[MAXN],Index,dep[MAXN],faz[MAXN],top[MAXN],rk[MAXN];ull a[MAXN];template &lt;typename T&gt; void Read(T &amp;x)&#123; int fu=1; x=0; char ch=getchar(); for(;!isdigit(ch);ch=getchar()) if(ch=='-') fu=-1; for(;isdigit(ch);ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch-48); x*=fu;&#125;void AddEdge(int u,int v)&#123; to[++cnt]=v; nxt[cnt]=fst[u]; fst[u]=cnt;&#125;void Dfs1(int u)&#123; siz[u]=1; son[u]=0; for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u]) continue; faz[v]=u; dep[v]=dep[u]+1; Dfs1(v); siz[u]+=siz[v]; if(siz[son[u]]&lt;siz[v]) son[u]=v; &#125;&#125;void Dfs2(int u,int rt)&#123; dfn[u]=++Index; rk[Index]=u; top[u]=rt; if(son[u]) Dfs2(son[u],rt); for(int i=fst[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==faz[u] || v==son[u]) continue; Dfs2(v,v); &#125;&#125;ull Calc(ull x,int rt)&#123; return opt[rt]==1?x&amp;a[rt]:(opt[rt]==2?x|a[rt]:x^a[rt]);&#125;Node CalcNode(Node x,Node y)&#123; Node res; res.l0=((x.l0&amp;y.l1)|(((~x.l0)&amp;y.l0))); res.l1=((x.l1&amp;y.l1)|(((~x.l1)&amp;y.l0))); res.r0=((y.r0&amp;x.r1)|(((~y.r0)&amp;x.r0))); res.r1=((y.r1&amp;x.r1)|(((~y.r1)&amp;x.r0))); return res;&#125;void BuildSegmentTree(int rt,int l,int r)&#123; if(l==r) &#123; t[rt].l0=t[rt].r0=Calc(0,rk[l]); t[rt].l1=t[rt].r1=Calc(MAXULL,rk[l]); return; &#125; int mid=l+r&gt;&gt;1; BuildSegmentTree(rt&lt;&lt;1,l,mid); BuildSegmentTree(rt&lt;&lt;1|1,mid+1,r); t[rt]=CalcNode(t[rt&lt;&lt;1],t[rt&lt;&lt;1|1]);&#125;void Modify(int rt,int l,int r,int pos)&#123; if(l==r) &#123; t[rt].l0=t[rt].r0=Calc(0,rk[l]); t[rt].l1=t[rt].r1=Calc(MAXULL,rk[l]); return; &#125; int mid=l+r&gt;&gt;1; if(mid&gt;=pos) Modify(rt&lt;&lt;1,l,mid,pos); else Modify(rt&lt;&lt;1|1,mid+1,r,pos); t[rt]=CalcNode(t[rt&lt;&lt;1],t[rt&lt;&lt;1|1]);&#125;Node Query(int rt,int l,int r,int tl,int tr)&#123; if(tl&lt;=l &amp;&amp; r&lt;=tr) return t[rt]; int mid=l+r&gt;&gt;1; Node res; if(tr&lt;=mid) res=Query(rt&lt;&lt;1,l,mid,tl,tr); else if(tl&gt;mid) res=Query(rt&lt;&lt;1|1,mid+1,r,tl,tr); else res=CalcNode(Query(rt&lt;&lt;1,l,mid,tl,tr),Query(rt&lt;&lt;1|1,mid+1,r,tl,tr)); return res;&#125;Node QueryOnTree(int u,int v)&#123; Node res; tot1=tot2=0; while(top[u]!=top[v]) &#123; if(dep[top[u]]&gt;=dep[top[v]]) &#123; ans1[++tot1]=Query(1,1,n,dfn[top[u]],dfn[u]); u=faz[top[u]]; &#125; else &#123; ans2[++tot2]=Query(1,1,n,dfn[top[v]],dfn[v]); v=faz[top[v]]; &#125; &#125; if(dep[u]&gt;dep[v]) ans1[++tot1]=Query(1,1,n,dfn[v],dfn[u]); else ans2[++tot2]=Query(1,1,n,dfn[u],dfn[v]); for(int i=1;i&lt;=tot1;i++) &#123; swap(ans1[i].l0,ans1[i].r0); swap(ans1[i].l1,ans1[i].r1); &#125; if(tot1) &#123; res=ans1[1]; for(int i=2;i&lt;=tot1;i++) res=CalcNode(res,ans1[i]); if(tot2) res=CalcNode(res,ans2[tot2]); &#125; else res=ans2[tot2]; for(int i=tot2-1;i&gt;=1;i--) res=CalcNode(res,ans2[i]); return res;&#125;int main()&#123; Read(n); Read(Q); Read(K); for(int i=1;i&lt;=n;i++) &#123; Read(opt[i]); Read(a[i]); &#125; for(int i=1;i&lt;n;i++) &#123; int x,y; Read(x); Read(y); AddEdge(x,y); AddEdge(y,x); &#125; Dfs1(1); Dfs2(1,1); BuildSegmentTree(1,1,n); while(Q--) &#123; int Opt; ull x,y,z; Read(Opt); Read(x); Read(y); Read(z); if(Opt==1) &#123; Node res=QueryOnTree(x,y); ull ans=0; for(int i=63;i&gt;=0;i--) &#123; ull l=(res.l0&gt;&gt;i)&amp;1ull,r=(res.l1&gt;&gt;i)&amp;1ull; if(l&gt;=r || (1ull&lt;&lt;i)&gt;z) &#123; if(l) ans|=(1ull&lt;&lt;i); &#125; else &#123; if(r) ans|=(1ull&lt;&lt;i); z-=(1ull&lt;&lt;i); &#125; &#125; printf(\"%llu\\n\",ans); &#125; else if(Opt==2) &#123; opt[x]=y; a[x]=z; Modify(1,1,n,dfn[x]); &#125; &#125; return 0;&#125; 总结无。 树链剖分是树上操作强大的工具，配合着数据结构对大部分操作有奇效，需要认真学习巩固。 $\\text{FIN.}$","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://VenusNero.github.io/tags/学习笔记/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://VenusNero.github.io/tags/树链剖分/"}]},{"title":"LaTeX 测试","slug":"text_of_latex","date":"2019-01-22T12:20:44.033Z","updated":"2019-01-22T12:46:45.652Z","comments":true,"path":"2019/01/22/text_of_latex/","link":"","permalink":"http://VenusNero.github.io/2019/01/22/text_of_latex/","excerpt":"","text":"\\max{(S)}=\\sum_{T\\subseteq S}^{}(-1)^{|T|-1}\\min{(T)}","categories":[],"tags":[]},{"title":"Hello the Cruel World","slug":"hello-world","date":"2019-01-22T11:48:43.687Z","updated":"2019-01-22T12:18:12.373Z","comments":true,"path":"2019/01/22/hello-world/","link":"","permalink":"http://VenusNero.github.io/2019/01/22/hello-world/","excerpt":"","text":"这里是我的新博客，平时随缘更新，望关注【笑","categories":[],"tags":[]}]}